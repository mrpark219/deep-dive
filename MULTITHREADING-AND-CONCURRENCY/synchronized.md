# 동기화

## 1. 동시성 문제

- 멀티스레드 환경에서 가장 주의해야 할 점은, **하나의 자원(Resource)에 여러 스레드가 동시에 접근**할 때 발생하는 **동시성 문제(Concurrency Issue)** 이다.
- 이때, 여러 스레드가 동시에 접근하는 자원을 **공유 자원(Shared Resource)** 이라고 한다.
- 대표적인 공유 자원으로는 **인스턴스의 필드(멤버 변수)**, `static` 필드, 파일 등이 있다.
- 따라서 멀티스레드 환경에서는 이러한 공유 자원에 대한 접근을 **적절하게 동기화(Synchronize)** 하여, 동시성 문제가 발생하지 않도록 방지하는 것이 매우 중요하다.

## 2. 임계 영역

- 동시성 문제가 발생하는 근본 원인은, 여러 스레드가 함께 사용하는 **공유 자원을 여러 단계에 걸쳐 변경**하기 때문이다.
- 예를 들어, '잔액 확인'과 '실제 출금'이라는 두 단계로 나뉜 출금 로직이 있다면, **한 스레드가 1단계를 마친 뒤 2단계를 진행하기 전에 다른 스레드가 끼어들어 값을 변경**할 수 있다.
- 이 경우 데이터의 일관성이 깨지는 혼란이 발생한다.

### 2.1. 공유 자원

- 출금 예시에서 **'잔액'은 여러 스레드가 함께 사용하는 공유 자원**이다. 따라서 한 스레드가 출금 로직을 수행하는 중간에 다른 스레드가 이 값을 얼마든지 변경할 수 있다.

#### 한 번에 하나의 스레드만 실행

- 만약 '출금' 메서드 자체를 **한 번에 하나의 스레드만 실행할 수 있도록 제한**한다면, 한 스레드가 잔액을 확인하고 출금하는 전 과정을 마칠 때까지 다른 스레드는 기다려야 한다.
- 예를 들어 t1, t2 스레드가 함꼐 출금을 호출하면 t1 스레드가 처음부터 끝까지 출금 메서드를 완료하고, 그 다음에 t2 스레드가 처음부터 끝까지 출금 메서드를 완료하는 것이다.
- 이를 통해 **공유 자원인 '잔액'의 일관성을 보장**할 수 있다.

### 2.2. 임계 영역 (Critical Section)

- 여러 스레드가 동시에 접근할 경우 **데이터 불일치와 같은 문제가 발생할 수 있는 코드 부분**을 의미한다.
- 위 예시에서는 **공유 변수인 '잔액'을 수정하는 출금 로직 전체**가 임계 영역에 해당한다.
- 임계 영역은 **한 번에 하나의 스레드만 접근할 수 있도록 반드시 보호**해야 한다. 자바에서는 **`synchronized`** 키워드를 통해 이를 간단하게 구현할 수 있다.

## 3. synchronized

### 3.1. 모니터 락 (Monitor Lock)

- 모든 자바 객체는 내부에 자신만의 **고유한 락(Lock)** 을 하나씩 가지고 있다. 이를 **모니터 락(Monitor Lock)** 이라고 부른다.
- 객체 내부에 있고, 확인하기는 어렵다.

### 3.2. 동작 방식

- `synchronized` 키워드가 붙은 메서드나 코드 블록(임계 영역)에 진입하려면, 해당 **인스턴스의 모니터 락을 획득**해야 한다.
- 한 스레드(T1)가 락을 획득하여 임계 영역을 실행하는 동안, 다른 스레드(T2)는 락을 획득할 수 없으므로 **`BLOCKED` 상태가 되어 대기**한다.
- BLOCKED 상태가 되면 락을 다시 획득하기 전까지는 계속 대기하고, CPU 실행 스케줄링에 들어가지 않는다.
- T1이 임계 영역 실행을 마치고 락을 반납하면, 대기하던 T2가 비로소 락을 획득하고 `RUNNABLE` 상태로 변경되어 임계 영역을 실행한다.
- 이처럼 `synchronized`를 사용하면, **한 번에 하나의 스레드만 임계 영역을 실행**하도록 보장할 수 있다.

### 3.3. 락 획득 순서

- 한 스레드가 락을 반납했을 때, 대기 중인 여러 스레드 중 **어떤 스레드가 다음으로 락을 획득할지에 대한 순서는 보장되지 않는다**.
- 이는 자바 표준에 정의되어 있지 않으며, JVM 구현이나 운영체제에 따라 달라질 수 있다.

### 3.4. 메모리 가시성 보장

- `synchronized`는 **`happens-before` 관계를 보장**한다.
- 한 스레드가 블록을 종료(unlock)하기 전에 변경한 모든 내용은, 이후 동일한 락을 획득(lock)하는 다른 스레드에게 **보이는 것이 보장**된다. 따라서 `volatile` 키워드 없이도 **메모리 가시성 문제를 해결**할 수 있다.

## 4. synchronized 코드 블록

- `synchronized`는 동시성을 보장하지만, **한 번에 하나의 스레드만 실행**하도록 제한하므로 성능 저하의 원인이 될 수 있다.
- 따라서 동기화가 필요한 코드 구간, 즉 **임계 영역(Critical Section)은 가능한 한 최소한으로** 줄이는 것이 중요하다.
- **`synchronized` 코드 블록**을 사용하면, 메서드 전체가 아닌 **필요한 부분에만 정확히 임계 영역을 지정**할 수 있다.
- `synchronized(this)`에서 괄호 안에 들어가는 값은 **락을 획득할 객체의 참조**이다. `this`를 사용하면, 메서드 전체에 `synchronized`를 선언한 것과 동일한 객체의 락을 사용한다.
- 코드 블록을 사용하면 **임계 영역의 범위를 줄여** 여러 스레드가 동시에 수행될 수 있는 구간을 늘릴 수 있으므로, **전체적인 성능 향상**에 도움이 된다.

## 5. synchronized 정리

- `synchronized`는 다음과 같이 **메서드 동기화**와 **블록 동기화** 두 가지 방식으로 사용할 수 있다.
  - 메서드 동기화: 메서드 전체를 `synchronized`로 선언하여, 한 번에 하나의 스레드만 접근하도록 보장한다.
    ```java
    public synchronized void synchronizedMethod() {
        // 임계 영역
    }
    ```
  - 블록 동기화: 코드 블록을 `synchronized`로 감싸서, 필요한 부분만 동기화를 구현한다.
    ```java
    public void method() {
        // ... 동기화가 필요 없는 코드
        synchronized (this) {
            // 임계 영역
        }
        // ... 동기화가 필요 없는 코드
    }
    ```
- 이러한 동기화 기법을 사용하면, 아래와 같은 동시성 문제를 해결할 수 있다.
  - **경합 조건 (Race Condition)**: 두 개 이상의 스레드가 경쟁적으로 동일한 자원을 수정할 때 발생하는 문제이다.
  - **데이터 일관성 (Data Consistency)**: 여러 스레드가 동시에 데이터를 읽고 쓸 때, 데이터의 일관성을 유지하는 것이다.
