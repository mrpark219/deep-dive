# 생산자 소비자 문제2

## 1. Lock과 Condition 인터페이스

- `notify()`의 비효율 문제를 해결하려면, **생산자는 소비자만 깨우고, 소비자는 생산자만 깨워야** 한다.
- 이를 위해서는 **생산자 스레드가 대기하는 공간**과 **소비자 스레드가 대기하는 공간을 분리**할 필요가 있다.
- `java.util.concurrent.locks` 패키지의 **`Lock`과 `Condition` 인터페이스**를 사용하면 이를 구현할 수 있다.

### 1.1. Condition

- `Condition` 인터페이스는 `Lock` 객체와 연결된 **별도의 스레드 대기 공간(Wait Set)을 제공**한다.
- `Object.wait()`가 사용하는 내장 대기 집합과 달리, `Condition`은 `lock.newCondition()`을 통해 **직접, 그리고 여러 개를 생성**하여 사용할 수 있다.

### 1.2. condition.await()

- `Condition.await()` 메서드는 **`Object.wait()`와 유사한 기능**이다.
- 현재 스레드가 `Lock`을 반납하고, **해당 `Condition`의 대기 집합에서 `WAITING` 상태**로 대기하게 한다.

### 1.3. condition.signal()

- `Condition.signal()` 메서드는 **`Object.notify()`와 유사한 기능**이다.
- 해당 `Condition`의 대기 집합에서 **대기 중인 스레드 중 하나를 깨워** 락 획득 경쟁에 참여시킨다.
- 일반적으로 FIFO 순서대로 꺠운다. 자바 버전과 구현에 따라 달라질 수 있지만 대부분 Queue 구조로 구현하기 때문에 FIFO 순서로 꺠운다.

## 2. Synchronized의 대기 상태

- 모든 자바 객체는 `synchronized`와 `wait/notify`를 이용한 멀티스레드 동기화를 위해, 내부에 다음과 같은 **세 가지 기본 요소**를 가진다.
  - **모니터 락**
  - **락 대기 집합**: 모니터 락을 기다리는 스레드들의 집합이다.
  - **스레드 대기 집합**: `wait()` 호출로 대기하는 스레드들의 집합이다.

### 2.1. BLOCKED 상태의 동작

- `synchronized` 임계 영역에 진입하려면 **모니터 락**이 필요하다.
- 만약 다른 스레드가 이미 락을 점유하고 있다면, 현재 스레드는 **'락 대기 집합'에 들어가 `BLOCKED` 상태**로 대기한다.
- 다른 스레드가 락을 반납하면, '락 대기 집합'에 있던 스레드 중 하나가 락을 획득하고 `RUNNABLE` 상태로 변경된다.

### 2.2. WAITING 상태의 동작

- `wait()` 메서드를 호출하여 **'스레드 대기 집합'에 들어가기 위해서도, 우선 모니터 락을 획득**해야 한다.
- 스레드가 `wait()`을 호출하면, **획득했던 모니터 락을 반납하고 `WAITING` 상태**가 되어 '스레드 대기 집합'으로 이동한다.
- 다른 스레드가 `notify()`를 호출하면, '스레드 대기 집합'에 있던 스레드 중 하나가 깨어나 **다시 모니터 락 획득을 시도**한다.
  - 락을 획득하면 `RUNNABLE` 상태가 되어 임계 영역을 계속 수행한다.
  - 만약 다른 스레드가 락을 가지고 있어 획득에 실패하면 '락 대기 집합'으로 이동하여 **`BLOCKED` 상태**가 된다.

## 3. ReentrantLock의 대기 상태

- `ReentrantLock`도 `synchronized`와 마찬가지로, **락(Lock)을 기다리는 상태**와 **조건(Condition)을 기다리는 상태**, 두 종류의 대기 상태를 가진다.

### 3.1. Lock 획득 대기

- `lock.lock()`을 호출했으나 다른 스레드가 이미 락을 점유하고 있을 때, 현재 스레드는 **`ReentrantLock` 내부의 대기 큐**에 들어가 **`WAITING` 상태**로 대기한다.
- 다른 스레드가 `lock.unlock()`을 호출하여 락을 반납하면, 대기 큐에 있던 스레드가 깨어나 **락 획득을 다시 시도**한다.

### 3.2. await() 대기

- `condition.await()`를 호출하면, 현재 스레드는 **`Condition` 객체의 대기 공간(Wait Set)에 들어가 `WAITING` 상태**로 대기한다.
- 다른 스레드가 `condition.signal()`을 호출하면, 대기 공간에서 빠져나와 **`Lock` 획득을 다시 시도**한다.
- 이때, 만약 다른 스레드가 `Lock`을 가지고 있다면, 락을 획득하기 위해 **`ReentrantLock`의 대기 큐**로 들어가 다시 `WAITING` 상태가 된다.

## 4. BlockingQueue

- `BlockingQueue`는 `java.util.concurrent` 패키지에 포함되어 있으며, **생산자-소비자 문제를 쉽게 해결**하도록 돕는다.
- 큐가 특정 조건(가득 참/비어 있음)일 때 스레드의 작업을 **차단(blocking)**하는 것이 핵심이다.
  - **데이터 추가 차단**: 큐가 가득 차면, 데이터 추가(`put()`)를 시도하는 스레드는 **빈 공간이 생길 때까지 차단**된다.
  - **데이터 조회 차단**: 큐가 비어 있으면, 데이터 조회(`take()`)를 시도하는 스레드는 **새로운 데이터가 들어올 때까지 차단**된다.
- 하지만 실무에서는 무작정 기다리는 것보다, **대기를 중단하거나 포기하는 등 응답성을 고려**해야 한다.
- 예를 들어, 선착순 이벤트에서 주문이 폭주하여 큐가 가득 찼을 때, 생산자 스레드(주문 생성)가 무한정 대기하는 것보다 **'요청량이 많으니 잠시 후 다시 시도해달라'고 사용자에게 즉시 알리는 것**이 더 좋은 선택이다.

### 4.1 큐가 가득 찼을 때 선택지

1. 예외를 던진다. 예외를 받아서 처리한다.
2. 대기하지 않는다. 즉시 false를 반환한다.
3. 대기한다.
4. 특정 시간 만큼만 대기한다.

| 작업 구분          | 예외 발생   | 특정 값 반환 | 블로킹   | 타임아웃               |
| :----------------- | :---------- | :----------- | :------- | :--------------------- |
| **추가 (Insert)**  | `add(e)`    | `offer(e)`   | `put(e)` | `offer(e, time, unit)` |
| **제거 (Remove)**  | `remove()`  | `poll()`     | `take()` | `poll(time, unit)`     |
| **조회 (Examine)** | `element()` | `peek()`     | N/A      | N/A                    |

#### 예외 발생 (Throws Exception)

- `add(e)`: 큐가 가득 차면 `IllegalStateException` 예외를 던진다.
- `remove()`: 큐가 비어 있으면 `NoSuchElementException` 예외를 던진다.
- `element()`: 큐가 비어 있으면 `NoSuchElementException` 예외를 던진다.

#### 특정 값 반환 (Special Value)

- `offer(e)`: 큐가 가득 차면 `false`를 반환한다.
- `poll()`: 큐가 비어 있으면 `null`을 반환한다.
- `peek()`: 큐가 비어 있으면 `null`을 반환한다.

#### 블로킹 (Blocks)

- `put(e)`: 큐가 가득 차면 공간이 생길 때까지 대기한다.
- `take()`: 큐가 비어 있으면 데이터가 들어올 때까지 대기한다.

#### 타임아웃 (Times Out)

- `offer(e, time, unit)`: 지정된 시간 동안 기다리다 시간이 초과되면 `false`를 반환한다.
- `poll(time, unit)`: 지정된 시간 동안 기다리다 시간이 초과되면 `null`을 반환한다.
