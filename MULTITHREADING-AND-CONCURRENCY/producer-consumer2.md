# 생산자 소비자 문제2

## 1. Lock과 Condition 인터페이스

- `notify()`의 비효율 문제를 해결하려면, **생산자는 소비자만 깨우고, 소비자는 생산자만 깨워야** 한다.
- 이를 위해서는 **생산자 스레드가 대기하는 공간**과 **소비자 스레드가 대기하는 공간을 분리**할 필요가 있다.
- `java.util.concurrent.locks` 패키지의 **`Lock`과 `Condition` 인터페이스**를 사용하면 이를 구현할 수 있다.

### 1.1. Condition

- `Condition` 인터페이스는 `Lock` 객체와 연결된 **별도의 스레드 대기 공간(Wait Set)을 제공**한다.
- `Object.wait()`가 사용하는 내장 대기 집합과 달리, `Condition`은 `lock.newCondition()`을 통해 **직접, 그리고 여러 개를 생성**하여 사용할 수 있다.

### 1.2. condition.await()

- `Condition.await()` 메서드는 **`Object.wait()`와 유사한 기능**이다.
- 현재 스레드가 `Lock`을 반납하고, **해당 `Condition`의 대기 집합에서 `WAITING` 상태**로 대기하게 한다.

### 1.3. condition.signal()

- `Condition.signal()` 메서드는 **`Object.notify()`와 유사한 기능**이다.
- 해당 `Condition`의 대기 집합에서 **대기 중인 스레드 중 하나를 깨워** 락 획득 경쟁에 참여시킨다.
- 일반적으로 FIFO 순서대로 꺠운다. 자바 버전과 구현에 따라 달라질 수 있지만 대부분 Queue 구조로 구현하기 때문에 FIFO 순서로 꺠운다.

## 2. Synchronized의 대기 상태

- 모든 자바 객체는 `synchronized`와 `wait/notify`를 이용한 멀티스레드 동기화를 위해, 내부에 다음과 같은 **세 가지 기본 요소**를 가진다.
  - **모니터 락**
  - **락 대기 집합**: 모니터 락을 기다리는 스레드들의 집합이다.
  - **스레드 대기 집합**: `wait()` 호출로 대기하는 스레드들의 집합이다.

### 2.1. BLOCKED 상태의 동작

- `synchronized` 임계 영역에 진입하려면 **모니터 락**이 필요하다.
- 만약 다른 스레드가 이미 락을 점유하고 있다면, 현재 스레드는 **'락 대기 집합'에 들어가 `BLOCKED` 상태**로 대기한다.
- 다른 스레드가 락을 반납하면, '락 대기 집합'에 있던 스레드 중 하나가 락을 획득하고 `RUNNABLE` 상태로 변경된다.

### 2.2. WAITING 상태의 동작

- `wait()` 메서드를 호출하여 **'스레드 대기 집합'에 들어가기 위해서도, 우선 모니터 락을 획득**해야 한다.
- 스레드가 `wait()`을 호출하면, **획득했던 모니터 락을 반납하고 `WAITING` 상태**가 되어 '스레드 대기 집합'으로 이동한다.
- 다른 스레드가 `notify()`를 호출하면, '스레드 대기 집합'에 있던 스레드 중 하나가 깨어나 **다시 모니터 락 획득을 시도**한다.
  - 락을 획득하면 `RUNNABLE` 상태가 되어 임계 영역을 계속 수행한다.
  - 만약 다른 스레드가 락을 가지고 있어 획득에 실패하면 '락 대기 집합'으로 이동하여 **`BLOCKED` 상태**가 된다.

## 3. ReentrantLock의 대기 상태

- `ReentrantLock`도 `synchronized`와 마찬가지로, **락(Lock)을 기다리는 상태**와 **조건(Condition)을 기다리는 상태**, 두 종류의 대기 상태를 가진다.

### 3.1. Lock 획득 대기

- `lock.lock()`을 호출했으나 다른 스레드가 이미 락을 점유하고 있을 때, 현재 스레드는 **`ReentrantLock` 내부의 대기 큐**에 들어가 **`WAITING` 상태**로 대기한다.
- 다른 스레드가 `lock.unlock()`을 호출하여 락을 반납하면, 대기 큐에 있던 스레드가 깨어나 **락 획득을 다시 시도**한다.

### 3.2. await() 대기

- `condition.await()`를 호출하면, 현재 스레드는 **`Condition` 객체의 대기 공간(Wait Set)에 들어가 `WAITING` 상태**로 대기한다.
- 다른 스레드가 `condition.signal()`을 호출하면, 대기 공간에서 빠져나와 **`Lock` 획득을 다시 시도**한다.
- 이때, 만약 다른 스레드가 `Lock`을 가지고 있다면, 락을 획득하기 위해 **`ReentrantLock`의 대기 큐**로 들어가 다시 `WAITING` 상태가 된다.
