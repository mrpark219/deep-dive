# 동시성 컬렉션

## 1. 동시성 컬렉션이 필요한 이유

- 여러 스레드가 동시에 접근해도 괜찮은 경우를 스레드 세이프하다고 한다.
- 이때 java.util 패키지에 소속되어 있는 컬렉션 프레임워크는 원자적인 연산을 제공하며 스레드 세이프할까?
- 예를 들어 컬렉션에 데이터를 추가하는 add() 메서드를 생각해보면, 단순히 컬렉션에 데이터를 하나 추가하는 것뿐이다. 따라서 이것은 마치 연산이 하나만 있는 원자적인 연산처럼 느껴진다. 원자적인 연산은 쪼갤 수 없기 떄문에 멀티스레드 상황에서 문제가 되지 않는다.
- 하지만 컬렉션 프레임워크가 제공하는 대부분의 연산은 원자적이 아니다.

### 1.1 동시성 문제

- add() 메서드는 원자적이지 않은 연산이다. 단순히 데이터를 하나 추가하는 기능을 제공하지만, 내부적으로는 내부에 있는 배열에 데이터를 추가해야 하고, size도 증가시켜야 한다. 심지어 내부적으로 size++연산 자체도 원자적이지 않다. 이렇게 원자적이지 않은 연산을 멀티스레드 상황에서 안전하게 사용하려면 synchronized, Lock 등을 사용해서 동기화를 해야 한다.
- 따라서 일반적인 컬렉션들은 절대 스레드 세이프하지 않다.
- 단일 스레드가 컬렉션에 접근하는 경우라면 아무런 문제가 없지만, 멀티스레드 상황에서 여러 스레드가 동시에 컬렉션에 접근하는 경우라면 java.util에 있는 일반적인 컬렉션들은 사용하면 안 된다. 일부 예외는 있다.

## 1. 동시성 컬렉션이 필요한 이유

- 여러 스레드가 동시에 접근해도 데이터의 일관성이 유지되는 것을 **스레드 세이프(Thread-Safe)** 하다고 한다.
- 그렇다면, `java.util` 패키지에 포함된 `ArrayList`나 `HashMap`과 같은 일반적인 컬렉션들은 스레드 세이프할까?
- 예를 들어, `list.add()` 메서드는 단순히 데이터를 하나 추가하는 것처럼 보여 **원자적(Atomic) 연산으로 착각하기 쉽다**.
- 하지만 일반적인 컬렉션 프레임워크가 제공하는 **대부분의 연산은 원자적이지 않다**.

### 1.1. 동시성 문제

- `add()` 메서드는 겉보기엔 단순하지만, 내부적으로는 `배열에 데이터를 추가하는 연산`과 `size를 1 증가시키는 연산`으로 나뉜다. 심지어 `size++` 연산 자체도 원자적이지 않다.
- 이처럼 원자적이 아닌 연산을 멀티스레드 환경에서 안전하게 사용하려면 **`synchronized`나 `Lock`과 같은 동기화 처리**가 반드시 필요하다.
- 결론적으로 `ArrayList`, `HashMap` 등 `java.util` 패키지의 **일반적인 컬렉션들은 스레드 세이프하지 않다**.
- 따라서, **여러 스레드가 동시에 접근할 가능성**이 있는 공유 자원으로 일반 컬렉션을 사용해서는 안 된다. 이를 위해 자바는 **동시성 컬렉션(Concurrent Collections)** 을 별도로 제공한다.

### 1.2. 동기화

- 만약 컬렉션의 모든 메서드에 **`synchronized`** 키워드를 붙인다면, **한 번에 하나의 스레드만** 접근하여 값을 변경할 수 있게 된다.
- 이를 통해 동시성 문제에서 벗어날 수 있다.

### 1.3. 프록시 도입

- 컬렉션의 모든 메서드에 `synchronized`를 직접 추가하는 방식은 번거롭고 관리하기 어렵다. 이 문제를 해결하기 위해 **프록시(Proxy)** 패턴을 사용할 수 있다.
- 프록시는 우리말로 **'대리자'** 를 의미하며, 이름 그대로 무언가를 대신 처리해주는 역할을 한다.
- 예를 들어, 웨이터에게 말 걸기 어려워하는 친구의 주문을 내가 대신 받아서 전달해주는 상황을 생각할 수 있다. 이때 나의 역할이 바로 프록시이다.
- 이처럼, **동기화 기능을 대신 처리해주는 프록시 객체**를 만들면 이 문제를 쉽게 해결할 수 있다.

#### 프록시 패턴

- 어떤 객체에 대한 접근을 제어하기 위해, 그 객체의 **대리인 역할을 하는 또 다른 객체를 제공**하는 디자인 패턴이다.
- 프록시 객체는 실제 객체에 대한 참조를 유지하면서, 실제 객체에 접근하기 전에 **추가적인 처리를 수행**할 수 있다.
- 프록시 패턴의 주요 목적은 다음과 같다.
  - **접근 제어**: 실제 객체에 대한 접근을 제한하거나 통제할 수 있다.
  - **성능 향상**: 실제 객체의 생성을 지연시키거나 캐싱하여 성능을 최적화할 수 있다.
  - **부가 기능 제공**: 실제 객체의 코드 수정 없이 로깅, 인증, 동기화와 같은 **부가 기능을 투명하게 제공**할 수 있다.

## 2. 자바 동시성 컬렉션

- `java.util` 패키지의 일반적인 컬렉션 프레임워크는 대부분 **스레드 세이프(Thread-Safe)하지 않다**.
- 만약 처음부터 모든 컬렉션에 `synchronized`를 적용했다면, **동기화에 따른 성능 저하**가 발생했을 것이다.
- 동기화가 필요 없는 단일 스레드 환경에서는 불필요한 비용이 발생하므로, **동기화는 꼭 필요할 때만 적용**하는 것이 좋다.

### 2.1. synchronized 프록시

- 이를 위해 자바는 `Collections.synchronizedXXX()`와 같은 **synchronized 프록시**를 제공한다.
- `Collections.synchronizedList(new ArrayList<>());`와 같이 사용하면, 원본 컬렉션을 감싸서 **모든 메서드에 `synchronized`가 적용된 프록시 객체**를 반환해준다.
- 이 방식은 기존 컬렉션을 스레드 세이프하게 만드는 가장 간단한 방법이다.
- 하지만, 단순 무식하게 모든 메서드에 synchronized를 걸었기 때문에 **동기화에 대한 최적화가 전혀 이루어지지 않았다**. 자바는 이러한 단점을 보완하기 위해 `java.util.concurrent` 패키지에 다양한 **동시성 컬렉션(Concurrent Collections)**을 별도로 제공한다.

#### synchronized 프록시의 단점

- **동기화 오버헤드 발생**
  - 각 메서드를 호출할 때마다 **동기화 비용이 발생**하여 성능 저하의 원인이 된다.
- **넓은 잠금 범위**
  - 컬렉션 전체를 하나의 락(lock)으로 제어하므로, 한 스레드가 컬렉션을 사용하는 동안 다른 모든 스레드는 **작업의 종류와 상관없이 무조건 대기**해야 한다. 이는 **잠금 경합(lock contention)을 증가**시켜 병렬 처리 효율을 저하시킨다.
- **정교한 동기화 불가**
  - 특정 부분이나 메서드에 대해서만 **선택적으로 동기화를 적용하는 것이 불가능**하여, 이는 과도한 동기화로 이어질 수 있다.

### 2.2. 동시성 컬렉션

- 자바 1.5부터 동시성에 대한 많은 혁신이 이루어졌으며, 이때 등장한 **동시성 컬렉션(Concurrent Collections)** 은 **스레드 세이프한 컬렉션을 의미**한다.
- `java.util.concurrent` 패키지는 멀티스레드 환경을 지원하는 `ConcurrentHashMap`, `CopyOnWriteArrayList` 등 다양한 동시성 컬렉션을 제공한다.
- 이 컬렉션들은 더 정교한 잠금 메커니즘을 사용하여 동시 접근을 효율적으로 처리하며, **필요한 부분에만 동기화를 적용**하는 등 유연한 전략을 제공한다.
- 성능 최적화를 위해 `synchronized`, `Lock`, `CAS`, 분할 잠금(Segment Lock) 등 다양한 기술을 조합하여 매우 정교하게 구현되어 있다.

### 2.3. 동시성 컬렉션의 종류

#### List

- `CopyOnWriteArrayList`: `ArrayList`의 동시성 버전이다.

#### Set

- `CopyOnWriteArraySet`: `HashSet`의 동시성 버전이다.
- `ConcurrentSkipListSet`: `TreeSet`의 동시성 버전으로, 정렬된 순서를 유지한다.

#### Map

- `ConcurrentHashMap`: `HashMap`의 동시성 버전이다.
- `ConcurrentSkipListMap`: `TreeMap`의 동시성 버전으로, 정렬된 순서를 유지한다.

#### Deque

- `ConcurrentLinkedDeque`: 동시성을 지원하는 **비차단(non-blocking)** 데크(Deque)이다.

#### 참고

- 입력 순서를 유지하면서 스레드 세이프한 `LinkedHashSet`이나 `LinkedHashMap`의 동시성 버전은 기본으로 제공되지 않는다. 이 경우 `Collections.synchronizedSet/Map()`을 사용해야 한다.

#### 블로킹 큐 (Blocking Queue)

- `ArrayBlockingQueue`: **크기가 고정된** 블로킹 큐이며, **공정(fair) 모드**를 지원한다. (공정 모드는 성능 저하가 발생할 수 있다.)
- `LinkedBlockingQueue`: **크기가 고정되거나 무한할 수 있는** 블로킹 큐이다.
- `PriorityBlockingQueue`: **우선순위가 높은 요소**를 먼저 처리하는 블로킹 큐이다.
- `SynchronousQueue`: **데이터를 저장하지 않는** 특별한 큐이다. 생산자의 `put()`은 소비자의 `take()`가 호출될 때까지 대기하며, **생산자와 소비자 간의 직접적인 데이터 전달(hand-off)** 을 구현한다.
- `DelayQueue`: **지연된(delayed) 요소를 처리**하는 큐이다. 각 요소는 지정된 지연 시간이 지나야만 큐에서 꺼낼 수 있으며, 스케줄링 작업에 유용하다.
