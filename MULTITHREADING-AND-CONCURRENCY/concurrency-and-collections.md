# 동시성 컬렉션

## 1. 동시성 컬렉션이 필요한 이유

- 여러 스레드가 동시에 접근해도 괜찮은 경우를 스레드 세이프하다고 한다.
- 이때 java.util 패키지에 소속되어 있는 컬렉션 프레임워크는 원자적인 연산을 제공하며 스레드 세이프할까?
- 예를 들어 컬렉션에 데이터를 추가하는 add() 메서드를 생각해보면, 단순히 컬렉션에 데이터를 하나 추가하는 것뿐이다. 따라서 이것은 마치 연산이 하나만 있는 원자적인 연산처럼 느껴진다. 원자적인 연산은 쪼갤 수 없기 떄문에 멀티스레드 상황에서 문제가 되지 않는다.
- 하지만 컬렉션 프레임워크가 제공하는 대부분의 연산은 원자적이 아니다.

### 1.1 동시성 문제

- add() 메서드는 원자적이지 않은 연산이다. 단순히 데이터를 하나 추가하는 기능을 제공하지만, 내부적으로는 내부에 있는 배열에 데이터를 추가해야 하고, size도 증가시켜야 한다. 심지어 내부적으로 size++연산 자체도 원자적이지 않다. 이렇게 원자적이지 않은 연산을 멀티스레드 상황에서 안전하게 사용하려면 synchronized, Lock 등을 사용해서 동기화를 해야 한다.
- 따라서 일반적인 컬렉션들은 절대 스레드 세이프하지 않다.
- 단일 스레드가 컬렉션에 접근하는 경우라면 아무런 문제가 없지만, 멀티스레드 상황에서 여러 스레드가 동시에 컬렉션에 접근하는 경우라면 java.util에 있는 일반적인 컬렉션들은 사용하면 안 된다. 일부 예외는 있다.

## 1. 동시성 컬렉션이 필요한 이유

- 여러 스레드가 동시에 접근해도 데이터의 일관성이 유지되는 것을 **스레드 세이프(Thread-Safe)** 하다고 한다.
- 그렇다면, `java.util` 패키지에 포함된 `ArrayList`나 `HashMap`과 같은 일반적인 컬렉션들은 스레드 세이프할까?
- 예를 들어, `list.add()` 메서드는 단순히 데이터를 하나 추가하는 것처럼 보여 **원자적(Atomic) 연산으로 착각하기 쉽다**.
- 하지만 일반적인 컬렉션 프레임워크가 제공하는 **대부분의 연산은 원자적이지 않다**.

### 1.1. 동시성 문제

- `add()` 메서드는 겉보기엔 단순하지만, 내부적으로는 `배열에 데이터를 추가하는 연산`과 `size를 1 증가시키는 연산`으로 나뉜다. 심지어 `size++` 연산 자체도 원자적이지 않다.
- 이처럼 원자적이 아닌 연산을 멀티스레드 환경에서 안전하게 사용하려면 **`synchronized`나 `Lock`과 같은 동기화 처리**가 반드시 필요하다.
- 결론적으로 `ArrayList`, `HashMap` 등 `java.util` 패키지의 **일반적인 컬렉션들은 스레드 세이프하지 않다**.
- 따라서, **여러 스레드가 동시에 접근할 가능성**이 있는 공유 자원으로 일반 컬렉션을 사용해서는 안 된다. 이를 위해 자바는 **동시성 컬렉션(Concurrent Collections)** 을 별도로 제공한다.
