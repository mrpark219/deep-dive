# 프로세스와 스레드 소개

## 1. 단일 프로그램 실행

- **프로그램 실행**이란, 프로그램을 구성하는 코드를 순서대로 CPU에서 연산하는 것이다.
- 만약 CPU 코어가 하나뿐인 환경(한 번에 하나의 프로그램 코드만 실행 가능)에서 두 개 이상의 프로그램을 동시에 실행한다면 어떻게 될까? 예를 들어, 음악을 들으면서 문서를 작성하는 상황이다.
- 하나의 프로그램이 끝난 뒤에야 다음 프로그램을 실행할 수 있다면, 음악이 끝날 때까지 기다렸다가 문서를 작성해야 하는 불편함이 있다.
- 초창기 컴퓨터는 이처럼 동작했지만, 오늘날에는 하나의 CPU 코어로 여러 프로그램을 **동시에 실행하는 것처럼 보이게 하는 멀티태스킹(Multi-tasking)** 기술을 통해 이 문제를 해결한다.

## 2. 멀티태스킹

- 만약 CPU가 매우 짧은 시간(0.01초) 단위로 여러 프로그램의 코드를 번갈아 가며 실행한다면, 사람은 마치 **두 프로그램이 동시에 실행되는 것처럼** 느끼게 된다.
- 이처럼 각 프로그램의 실행 시간을 잘게 나누어, 마치 동시에 실행되는 것처럼 보이게 하는 기법을 **시분할(Time Sharing)** 이라고 한다.
- 하나의 컴퓨터 시스템이 이 시분할 기법을 이용해 **동시에 여러 작업을 수행하는 능력**을 **멀티태스킹(Multi-tasking)** 이라고 한다.

### 2.1. 스케줄링

- CPU가 어떤 프로그램을, 얼마만큼의 시간 동안 실행할지를 결정하는 것을 **스케줄링(Scheduling)** 이라고 하며, 이는 **운영체제(OS)의 핵심 역할** 중 하나이다.
- 스케줄링 시에는 단순히 시간을 나누는 것을 넘어, CPU를 최대한 효율적으로 활용하기 위해 **다양한 우선순위와 최적화 기법**이 사용된다.
- 대표적인 스케줄링 알고리즘으로는 FIFO, SJF, Round Robin(RR), Multi-level Queue 등이 있다.

## 3. 멀티프로세싱

- **멀티프로세싱(Multi-processing)** 이란, 컴퓨터 시스템에서 **두 개 이상의 프로세서(CPU 코어)를 사용하여 여러 작업을 동시에 처리**하는 기술을 의미한다.
- CPU 코어가 두 개 이상인 상황으로, 예를 들어 코어가 두 개라면 **두 개의 프로그램을 물리적으로 동시에 실행**할 수 있다.

## 4. 멀티태스킹 VS 멀티프로세싱

- 멀티태스킹은 운영체제 소프트웨어의 관점이고, 멀티프로세싱은 하드웨어의 관점이다.

| 구분          | 멀티태스킹 (Multi-tasking)                                       | 멀티프로세싱 (Multi-processing)                              |
| :------------ | :--------------------------------------------------------------- | :----------------------------------------------------------- |
| **핵심 개념** | 단일 CPU가 여러 작업을 **동시에 수행하는 것처럼 보이게** 하는 것 | 여러 CPU(코어)를 사용하여 **동시에 여러 작업을 수행**하는 것 |
| **기반**      | **소프트웨어** 기반 (CPU 시간 분할)                              | **하드웨어** 기반 (다중 코어)                                |
| **주요 환경** | 운영체제에서 여러 앱 실행                                        | 다중 코어 프로세서를 가진 컴퓨터 시스템                      |

## 5. 프로세스

- 컴퓨터에 저장된 프로그램은 실행되기 전까지는 단순한 파일에 불과하다.
- 이 프로그램을 실행하면, 운영체제는 해당 프로그램을 위한 **프로세스(Process)** 를 생성한다. 즉, 프로세스는 **실행 중인 프로그램의 인스턴스**이다.
- 자바 언어에 비유하자면, 클래스(Class)가 프로그램이고, `new` 키워드를 통해 메모리에 생성된 인스턴스(Instance)가 프로세스라고 할 수 있다.
- 일반적으로 운영체제 안에 여러 프로세스가 존재하고, 각 프로세스는 하나 이상의 스레드(Thread)를 가지는 구조이다.
- 각 프로세스는 **운영체제로부터 자신만의 독립적인 메모리 공간을 할당**받는다. 이 때문에 다른 프로세스의 메모리 공간에 직접 접근할 수 없으며, 서로 간섭하지 않는다.
- 이러한 **격리(Isolation)** 특성 덕분에, 하나의 프로세스에 문제가 발생하여 충돌하더라도 **다른 프로세스에는 영향을 미치지 않는다**.
- 프로세스는 **실행 환경을 제공하는 컨테이너**와 같은 역할을 한다. 여기에는 독립된 메모리 공간뿐만 아니라, 파일 핸들, 네트워크 연결과 같은 각종 시스템 자원이 포함된다.
- 프로세스 자체는 실행의 단위가 아니며, 실제로 운영체제의 스케줄러에 의해 실행되는 것은 **프로세스 내에 포함된 스레드(Thread)** 이다.

### 5.1 프로세스 메모리 구성

- 코드(Code) 영역: 실행할 **프로그램의 코드**가 저장되는 부분이다.
- 데이터(Data) 영역: **전역 변수와 정적(static) 변수**가 저장되는 부분이다.
- 힙(Heap) 영역: 개발자가 코드를 통해 **동적으로 할당하는 메모리 영역**이다. (예: `new` 키워드로 생성된 객체)
- 스택(Stack) 영역: 메서드가 호출될 때 생성되는 **지역 변수와 반환 주소 등이 저장**되는 영역이다. (스택 영역은 스레드마다 개별적으로 할당된다.)

## 6. 스레드

- **스레드(Thread)** 는 프로세스 내에서 **실행되는 작업의 흐름 단위**이다.
- **하나의 프로세스는 반드시 하나 이상의 스레드를 가지며**, 이 스레드들은 **프로세스의 메모리 공간을 공유**한다.
- 스레드는 프로세스보다 생성 및 관리 비용이 훨씬 적다.

### 6.1. 스레드 메모리 구성

- 공유 메모리: 한 프로세스 내의 모든 스레드는 부모 프로세스의 **코드(Code), 데이터(Data), 힙(Heap) 영역을 공유**한다.
- 개별 스택(Stack): 각 스레드는 **자신만의 독립적인 스택 영역**을 가진다. 이는 메서드 호출 시 생성되는 지역 변수나 매개변수 등이 다른 스레드에 의해 영향을 받지 않도록 하기 위함이다.

## 7. 멀티 스레드가 필요한 이유

- 하나의 프로세스(프로그램) 안에서도 **동시에 여러 종류의 작업을 처리**해야 할 필요가 있다.
- 워드 프로세서로 문서를 편집할 때, 키보드 입력(문서 편집)을 하는 동시에 백그라운드에서는 자동 저장과 맞춤법 검사가 함께 수행된다.
- 이러한 동시 작업을 처리하기 위해, 워드 프로세스(하나의 프로세스)는 **여러 개의 스레드를 사용**한다.
  - 스레드 1: 사용자의 키보드 입력을 받아 화면에 보여주는 문서 편집 작업을 처리한다.
  - 스레드 2: 일정 시간마다 문서를 자동으로 저장하는 작업을 처리한다.
  - 스레드 3: 사용자가 입력한 내용의 맞춤법을 검사하는 작업을 처리한다.

## 8. 스레드와 스케줄링

### 8.1. 단일 코어 스케줄링

- 운영체제는 내부에 **스케줄링 큐(Scheduling Queue)** 를 가지고 있으며, 실행 대기 중인 스레드들은 이 큐에서 순서를 기다린다.
- 스케줄러는 정해진 규칙에 따라 큐에서 **다음 실행할 스레드를 하나 꺼내** CPU에 할당하여 실행시킨다.
- 일정 시간이 지나면, 스케줄러는 현재 실행 중인 스레드의 작업을 잠시 멈추고 다시 큐에 넣은 뒤, 큐에서 새로운 작업을 꺼내 실행한다.
- 이 과정을 **문맥 교환(Context Switching)** 이라고 하며, 멀티태스킹은 이 과정을 매우 빠르게 반복하는 것이다.

## 9. 컨텍스트 스위칭

- 하나의 CPU 코어가 멀티태스킹으로 여러 스레드를 처리하는 상황을 가정한다. 스레드 A를 실행하다가 잠시 멈추고 스레드 B를 실행한 뒤, 다시 A로 돌아오려면 이전에 **어디까지 코드를 수행했는지, 어떤 값들을 계산하고 있었는지** 기억해야 한다.
- 이를 위해, 스레드를 전환할 때는 현재 스레드의 **작업 상태(문맥)를 메모리에 저장**하고, 다음에 실행할 스레드의 **이전 작업 상태를 메모리에서 다시 불러오는** 과정이 필요하다.
- 이처럼 **현재 작업 문맥(Context) 을 다른 문맥으로 전환(Switching)** 하는 과정을 **문맥 교환(Context Switching)** 이라고 한다.
- 문맥 교환 과정에서는 이전 상태를 저장하고 새로운 상태를 불러오는 데 **오버헤드(비용)** 가 발생한다.
- 따라서 멀티스레딩은 대부분 효율적이지만, **빈번한 문맥 교환은 오히려 전체적인 성능을 저하시키는 원인**이 될 수 있다.

### 9.1. 참고: CPU 코어 수와 스레드 개수의 관계

- CPU 코어 수 > 스레드 수
  - 문맥 교환(Context Switching) 비용은 줄어들지만, **모든 CPU 코어를 100% 활용할 수 없는 비효율**이 발생한다.
- CPU 코어 수 < 스레드 수
  - CPU 코어를 100% 활용할 수 있지만, 코어 수보다 많은 스레드들이 경쟁하면서 **불필요한 문맥 교환 비용이 증가**한다.
- CPU 코어 수 = 스레드 수
  - CPU를 100% 활용하면서도, 문맥 교환 비용을 최소화하여 **이론적으로 최적의 상태**가 된다.
  - 하지만 실제로는 스레드가 I/O 작업 등으로 잠시 대기(waiting) 상태에 빠질 수 있다. 이때 다른 스레드가 CPU를 사용할 수 있도록, **이상적으로는 `CPU 코어 수 + 1개` 정도**로 스레드 개수를 설정하는 것이 좋다.

## 10. 스레드 작업 종류

### 10.1. CPU 바운드 작업 (CPU-bound Task)

- **CPU의 연산 능력을 많이 요구**하는 작업을 의미한다.
- 주로 계산, 데이터 처리, 알고리즘 실행 등 **CPU의 처리 속도가 전체 작업 완료 시간을 결정**하는 경우이다.
- 예: 복잡한 수학 계산, 데이터 암호화, 대규모 데이터 정렬 등

### 10.2. I/O 바운드 작업 (I/O-bound Task)

- 디스크나 네트워크와 같은 **입출력(I/O) 작업을 많이 요구**하는 작업을 의미한다.
- **I/O 작업이 완료될 때까지 대기 시간**이 길게 발생하며, 그동안 **CPU는 상대적으로 유휴(대기) 상태**에 있는 경우가 많다.
- 예: 데이터베이스 쿼리, 파일 읽기/쓰기, 외부 API 호출 등

## 11. 웹 애플리케이션과 스레드 개수

- 백엔드 서버는 **CPU 바운드 작업보다 I/O 바운드 작업이 훨씬 많다**. 대부분의 시간은 데이터베이스를 호출하고 그 결과를 기다리는 데 사용된다.
- 일반적으로 웹 애플리케이션 서버는 **사용자의 요청 하나를 하나의 스레드로 처리**한다. 즉, 4명의 사용자가 동시에 요청하면 4개의 스레드가 필요하다.
- 만약 I/O 작업 동안 CPU가 거의 쉬는 상황에서, **CPU 코어 수만큼만 스레드를 생성하면 CPU 자원을 심각하게 낭비**하게 된다. 예를 들어, 4코어 CPU에 스레드를 4개만 설정하면, CPU는 대부분의 시간 동안 쉬게 되고 동시 접속자 수도 4명으로 제한된다.
- 따라서 스레드 풀의 크기는 **작업의 종류(CPU 바운드 vs I/O 바운드)에 따라 다르게 설정**해야 한다.

### 11.1. CPU 바운드 작업의 경우

- 스레드 개수는 **`CPU 코어 수 + 1개`** 로 설정하는 것이 일반적이다.
- CPU를 거의 100% 사용하므로, **문맥 교환(Context Switching) 비용을 최소화**하기 위해 스레드 개수를 CPU 코어 수에 맞게 최적화하는 것이다.

### 11.2. I/O 바운드 작업의 경우

- 스레드 개수는 **CPU 코어 수보다 훨씬 많은 개수**로 설정해야 한다.
- 스레드가 I/O 작업으로 대기 상태에 있는 동안 다른 스레드가 CPU를 사용할 수 있도록 하여, **CPU 활용률을 최대한으로 끌어올리는 것**이 목표이다.
- 하지만 스레드 개수를 무작정 늘리면 **과도한 문맥 교환 비용으로 오히려 성능이 저하**될 수 있다. 따라서 **반드시 성능 테스트를 통해 최적의 스레드 개수**를 찾아야 한다.
