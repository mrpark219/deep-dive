# CAS - 동기화와 원자적 연산

## 1. 원자적 연산(Atomic Operation)

### 1.1. 원자적 연산이란?

- **더 이상 나눌 수 없는 하나의 단위**로 수행되는 연산을 의미한다.
- 이는 연산이 실행되는 중간에 다른 스레드가 끼어들 수 없으며, **'모두 실행되거나, 아예 실행되지 않거나(All-or-Nothing)'** 를 보장한다.

### 1.2. 원자적 연산의 예시

- **원자적인 연산**: `i = 10;`과 같은 단순 대입 연산은 원자적이다. 이는 값을 변수에 대입하는 **단 하나의 기계어 명령**으로 실행되기 때문이다.
- **원자적이 아닌 연산**: `i++;` 또는 `i = i + 1;`과 같은 증감 연산은 원자적이 아니다. 이 연산은 내부적으로 `i의 값을 읽는다`, `값에 1을 더한다`, `결과를 i에 다시 쓴다` 의 세 단계로 나뉘어 실행되기 때문이다. 각 단계 사이에 다른 스레드가 개입할 수 있다.

### 1.3. 동시성 문제와의 관계

- 원자적 연산은 **그 자체로 동시성 문제로부터 안전**하다.
- 하지만, 원자적이 아닌 연산을 공유 자원에 대해 수행할 경우에는, **`synchronized`나 `Lock` 등을 사용**하여 **임계 영역(Critical Section)** 으로 만들어 반드시 보호해야 한다.

## 2. 락 기반 방식의 문제점

- 공유 데이터를 보호하기 위해 **락(Lock)** 을 사용하는 방식이 있다. 여기서 말하는 락은 `synchronized`나 `ReentrantLock`과 같은 기술을 의미한다.
- 락은 특정 자원을 보호하기 위해 스레드의 접근을 제한하며, 한 스레드가 락을 점유하고 있는 동안 다른 스레드들은 **락이 해제될 때까지 대기**해야 한다.
- 락 기반 방식은 **락을 획득하고 해제하는 과정에서 시간**이 소요되는 단점이 있다.
  1.  락이 있는지 확인한다.
  2.  락을 획득하고 임계 영역에 들어간다.
  3.  작업을 수행한다.
  4.  락을 반납한다.
- 이처럼 락을 획득하고 반납하는 과정이 반복되므로, 구현은 직관적이지만 **상대적으로 무거운 방식**이라고 할 수 있다.

## 3. CAS (Compare-And-Swap)

- 락 기반 방식의 문제점을 해결하기 위해, **락을 사용하지 않고 원자적 연산을 수행**하는 방법을 **CAS(Compare-And-Swap, Compare-And-Set)** 연산이라고 한다.
- 이 방법은 락을 사용하지 않으므로 **락-프리(Lock-Free)** 기법이라고도 한다.
- CAS 연산은 락을 완전히 대체하는 것이 아니다. 기본적으로는 락을 사용하고, 특별한 경우에만 CAS를 적용하는 것이 일반적이다.
- 자바는 `java.util.concurrent.atomic` 패키지의 클래스들이 제공하는 **`compareAndSet()`** 메서드를 통해 CAS 연산을 지원한다.

### 3.1. compareAndSet()

- `compareAndSet(expectedValue, newValue)` 메서드는 '현재 값이 **기대하는 값(expected value)과 같다면, 새로운 값(new value)으로 변경**하라'는 매우 단순한 연산이다.
  - 만약 현재 값이 기대 값과 같다면, 값을 새로운 값으로 변경하고 `true`를 반환한다.
  - 만약 현재 값이 기대 값과 다르다면, 아무것도 변경하지 않고 `false`를 반환한다.
- 이 **'비교하고 변경하는' 과정 전체가 원자적으로 실행**된다는 것이 핵심이다.
- 소프트웨어 관점에서는 이 연산이 **값을 확인하는 단계**와 **값을 변경하는 단계**로 나뉘는 것처럼 보이지만, 실제로는 원자적으로 동작한다.

### 3.2. CPU 하드웨어의 지원

- CAS 연산은 소프트웨어 수준에서는 원자적이 아닌 연산을, **CPU 하드웨어 차원에서 하나의 원자적 연산으로 묶어서 제공**하는 기능이다.
- 즉, 소프트웨어가 아닌 **하드웨어가 직접 지원**하는 기능이며, 대부분의 현대 CPU는 CAS를 위한 명령어를 제공한다.
- CPU는 **'값을 확인하는 과정'과 '값을 변경하는 과정'을 하나의 원자적인 명령어로 만들어**, 중간에 다른 스레드가 개입할 수 없도록 한다.
- CPU는 이 두 과정 사이에 다른 스레드가 해당 메모리 주소의 값을 변경하지 못하도록 하드웨어 수준에서 막는다. 이 과정은 CPU 입장에서 보면 아주 찰나의 순간에 일어나므로, 락을 사용하는 방식보다 **성능상 이점**이 크다.

### 3.3. CAS 동작 방식

- CAS는 락을 사용하는 대신, 다른 스레드와의 **충돌이 발생하면 루프를 돌며 재시도하는 방식**을 사용한다.
- 동작 방식은 다음과 같다.
  1.  현재 변수의 값을 읽어온다.
  2.  값을 변경하기 전에, CAS 연산을 사용해서 **현재 값이 이전에 읽은 값과 동일한지 확인**한다.
  3.  값이 동일하다면, 새로운 값을 변수에 저장하고 연산을 종료한다.
  4.  값이 동일하지 않다면, 다른 스레드가 먼저 값을 변경한 것이므로 **처음부터 다시 과정을 반복**한다.
- 이처럼 충돌이 발생할 때마다 재시도하므로, 결과적으로 **락 없이도 데이터를 안전하게 변경**할 수 있다.
- CAS 방식은 **충돌이 드물게 발생하는 환경**에서, 스레드가 락을 얻기 위해 대기하지 않으므로 **대기 시간과 문맥 교환(Context Switching) 오버헤드가 줄어들어** 높은 성능을 발휘할 수 있다.
- 하지만, **충돌이 빈번하게 발생하는 환경**에서는 오히려 성능 문제가 발생할 수 있다. CAS 연산이 계속 실패하고 재시도 루프를 반복하게 되므로, **CPU 자원을 많이 소모하여 성능 저하**가 발생할 수 있다.

## 4. CAS와 LOCK 방식의 비교

### 4.1. 락 방식

- **비관적(Pessimistic) 접근법**이다.
- 데이터에 접근하기 전에 **항상 락(Lock)을 획득**하여, 다른 스레드의 접근을 원천적으로 막는 방식이다.
- 이는 **다른 스레드가 항상 방해할 것**이라고 비관적으로 가정하는 것이다.

### 4.2. CAS 방식

- **낙관적(Optimistic) 접근법**이다.
- 락을 사용하지 않고 **데이터에 우선 접근**한 뒤, 충돌이 발생하면 그때 재시도하는 방식이다.
- 이는 **대부분의 경우 충돌이 없을 것**이라고 낙관적으로 가정하는 것이다.
- 간단한 CPU 연산은 매우 빠르게 처리되므로 **충돌이 자주 발생하지 않는다**. 충돌이 일어나기도 전에 연산이 완료되는 경우가 더 많기 때문이다.
- 따라서 간단한 CPU 연산에는 **락 방식보다 CAS 방식이 더 유리**하다.
