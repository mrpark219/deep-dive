# CAS - 동기화와 원자적 연산

## 1. 원자적 연산(Atomic Operation)

### 1.1. 원자적 연산이란?

- **더 이상 나눌 수 없는 하나의 단위**로 수행되는 연산을 의미한다.
- 이는 연산이 실행되는 중간에 다른 스레드가 끼어들 수 없으며, **'모두 실행되거나, 아예 실행되지 않거나(All-or-Nothing)'** 를 보장한다.

### 1.2. 원자적 연산의 예시

- **원자적인 연산**: `i = 10;`과 같은 단순 대입 연산은 원자적이다. 이는 값을 변수에 대입하는 **단 하나의 기계어 명령**으로 실행되기 때문이다.
- **원자적이 아닌 연산**: `i++;` 또는 `i = i + 1;`과 같은 증감 연산은 원자적이 아니다. 이 연산은 내부적으로 `i의 값을 읽는다`, `값에 1을 더한다`, `결과를 i에 다시 쓴다` 의 세 단계로 나뉘어 실행되기 때문이다. 각 단계 사이에 다른 스레드가 개입할 수 있다.

### 1.3. 동시성 문제와의 관계

- 원자적 연산은 **그 자체로 동시성 문제로부터 안전**하다.
- 하지만, 원자적이 아닌 연산을 공유 자원에 대해 수행할 경우에는, **`synchronized`나 `Lock` 등을 사용**하여 **임계 영역(Critical Section)** 으로 만들어 반드시 보호해야 한다.

## 2. 락 기반 방식의 문제점

- 공유 데이터를 보호하기 위해 **락(Lock)** 을 사용하는 방식이 있다. 여기서 말하는 락은 `synchronized`나 `ReentrantLock`과 같은 기술을 의미한다.
- 락은 특정 자원을 보호하기 위해 스레드의 접근을 제한하며, 한 스레드가 락을 점유하고 있는 동안 다른 스레드들은 **락이 해제될 때까지 대기**해야 한다.
- 락 기반 방식은 **락을 획득하고 해제하는 과정에서 시간**이 소요되는 단점이 있다.
  1.  락이 있는지 확인한다.
  2.  락을 획득하고 임계 영역에 들어간다.
  3.  작업을 수행한다.
  4.  락을 반납한다.
- 이처럼 락을 획득하고 반납하는 과정이 반복되므로, 구현은 직관적이지만 **상대적으로 무거운 방식**이라고 할 수 있다.

## 3. CAS (Compare-And-Swap)

- 락 기반 방식의 문제점을 해결하기 위해, **락을 사용하지 않고 원자적 연산을 수행**하는 방법을 **CAS(Compare-And-Swap, Compare-And-Set)** 연산이라고 한다.
- 이 방법은 락을 사용하지 않으므로 **락-프리(Lock-Free)** 기법이라고도 한다.
- CAS 연산은 락을 완전히 대체하는 것이 아니다. 기본적으로는 락을 사용하고, 특별한 경우에만 CAS를 적용하는 것이 일반적이다.
- 자바는 `java.util.concurrent.atomic` 패키지의 클래스들이 제공하는 **`compareAndSet()`** 메서드를 통해 CAS 연산을 지원한다.

### 3.1. compareAndSet()

- `compareAndSet(expectedValue, newValue)` 메서드는 '현재 값이 **기대하는 값(expected value)과 같다면, 새로운 값(new value)으로 변경**하라'는 매우 단순한 연산이다.
  - 만약 현재 값이 기대 값과 같다면, 값을 새로운 값으로 변경하고 `true`를 반환한다.
  - 만약 현재 값이 기대 값과 다르다면, 아무것도 변경하지 않고 `false`를 반환한다.
- 이 **'비교하고 변경하는' 과정 전체가 원자적으로 실행**된다는 것이 핵심이다.
- 소프트웨어 관점에서는 이 연산이 **값을 확인하는 단계**와 **값을 변경하는 단계**로 나뉘는 것처럼 보이지만, 실제로는 원자적으로 동작한다.

### 3.2. CPU 하드웨어의 지원

- CAS 연산은 소프트웨어 수준에서는 원자적이 아닌 연산을, **CPU 하드웨어 차원에서 하나의 원자적 연산으로 묶어서 제공**하는 기능이다.
- 즉, 소프트웨어가 아닌 **하드웨어가 직접 지원**하는 기능이며, 대부분의 현대 CPU는 CAS를 위한 명령어를 제공한다.
- CPU는 **'값을 확인하는 과정'과 '값을 변경하는 과정'을 하나의 원자적인 명령어로 만들어**, 중간에 다른 스레드가 개입할 수 없도록 한다.
- CPU는 이 두 과정 사이에 다른 스레드가 해당 메모리 주소의 값을 변경하지 못하도록 하드웨어 수준에서 막는다. 이 과정은 CPU 입장에서 보면 아주 찰나의 순간에 일어나므로, 락을 사용하는 방식보다 **성능상 이점**이 크다.
