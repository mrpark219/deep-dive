# 스레드 풀과 Executor 프레임워크1

## 1. 스레드를 직접 사용할 때의 문제점

- 스레드를 직접 생성해서 사용하면, **성능, 관리, 불편함**이라는 세 가지 주요 문제점이 있다.

### 1.1. 스레드 생성 비용으로 인한 성능 문제

- 스레드를 생성하는 작업은 단순히 자바 객체를 만드는 것과는 비교할 수 없을 정도로 **무거운 작업**이다. 그 이유는 다음과 같다.
  - **메모리 할당**: 각 스레드는 자신만의 호출 스택(Call Stack)을 위한 메모리(보통 1MB 이상)를 할당받아야 한다.
  - **운영체제 자원 사용**: 스레드 생성은 운영체제 커널 수준에서 시스템 콜(System Call)을 통해 처리되므로, CPU와 메모리 자원을 소모한다.
  - **운영체제 스케줄러 설정**: 새로운 스레드가 생성되면 운영체제의 스케줄러가 이를 관리해야 하므로, 추가적인 오버헤드가 발생한다.
- 이처럼 스레드 생성 비용이 크기 때문에, **가벼운 작업을 처리할 때마다 스레드를 새로 만들면 작업 시간보다 스레드 생성 시간이 더 오래 걸리는** 비효율이 발생할 수 있다.
- 이 문제를 해결하려면, **생성한 스레드를 재사용**하는 방법을 고려해야 한다.

### 1.2. 스레드 관리 문제

- 시스템의 CPU나 메모리 자원은 한정되어 있으므로, **스레드를 무한정 만들 수는 없다**.
- 만약 사용자의 요청이 들어올 때마다 스레드를 계속 생성하면, 사용자가 몰릴 때 시스템 자원이 고갈되어 서버가 다운될 수 있다. 따라서 시스템이 감당할 수 있는 **최대 스레드 개수를 관리**해야 한다.
- 또한, 애플리케이션을 안전하게 종료하려면 실행 중인 스레드들이 **남은 작업을 마치도록 기다리거나, 급하게 종료해야 할 때 인터럽트 신호**를 보내야 한다. 이러한 작업을 위해서도 스레드는 어딘가에서 관리되어야 한다.

### 1.3. Runnable 인터페이스의 불편함

- **`Runnable` 인터페이스**는 스레드 작업을 정의하는 데 사용되지만, 몇 가지 불편함이 있다.
  - **반환 값 부재**: `run()` 메서드는 반환 값이 없으므로, **스레드의 실행 결과를 직접 받을 수 없다**. 결과를 얻으려면 멤버 변수에 값을 저장한 뒤, `join()` 등으로 스레드가 종료되기를 기다려야 하는 번거로움이 있다.
  - **예외 처리의 제약**: `run()` 메서드는 **체크 예외(Checked Exception)를 밖으로 던질 수 없다**. 따라서 예외 처리는 반드시 `run()` 메서드 내부에서 `try-catch`로 처리해야 한다.

### 1.4. 해결 방법: 스레드 풀과 Executor 프레임워크

- 앞서 언급한 문제들을 해결하기 위해 **스레드 풀(Thread Pool)** 이라는 개념이 필요하다.
- 스레드 풀은 **필요한 만큼의 스레드를 미리 만들어두고, 재사용**하는 방식이다.
  1.  작업 요청이 오면, 스레드 풀에서 대기 중인 스레드를 하나 꺼내 작업을 처리한다.
  2.  작업이 완료되면, 스레드를 종료하는 대신 **다시 스레드 풀에 반납하여 재사용**을 준비한다.
- 스레드 풀을 사용하면 **스레드 생성 비용을 절약**할 수 있고, **최대 스레드 개수를 관리**하여 시스템을 안정적으로 유지할 수 있다.
- 이러한 스레드 풀의 복잡한 동작(생산자-소비자 패턴, 스레드 상태 관리 등)을 직접 구현하는 것은 매우 어렵다.
- 자바는 이 모든 문제를 한 번에 해결해주는 **Executor 프레임워크**를 제공한다.
