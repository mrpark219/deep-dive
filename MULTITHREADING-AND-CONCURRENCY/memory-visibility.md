# 메모리 가시성

## 1. 메모리 가시성 문제

- 보통 변수를 읽을 때 **메인 메모리(Main Memory)에서 직접 값을 가져온다**고 생각한다. 하지만 실제로는 그렇지 않다.

### 1.1. 실제 메모리 접근 방식: CPU 캐시

- CPU는 처리 성능을 높이기 위해, 메인 메모리보다 **훨씬 빠르지만 용량이 작은 캐시 메모리(Cache Memory)** 를 중간에 사용한다.
- CPU가 특정 변수를 사용하면, 그 값을 **캐시 메모리에 복사**해두고 다음부터는 메인 메모리가 아닌 캐시에서 값을 읽어온다.
- 캐시 메모리는 대부분 코어 단위로 가지고 있으며 여러 코어가 공유하는 캐시 메모리도 가지고 있다.

### 1.2. 가시성 문제가 발생하는 과정

- 멀티스레드 환경에서는, **각 스레드가 별도의 CPU 코어에서 실행**될 수 있다. 이때 각 스레드는 **자신만의 캐시 메모리**에 변수 값을 저장한다.
- 만약 스레드 A가 공유 변수의 값을 변경하면, 이 변경은 **스레드 A의 캐시 메모리에만 반영**된다. 이 변경 사항이 **언제 메인 메모리에 반영될지는 보장되지 않는다**.
- 따라서, 스레드 B는 스레드 A가 값을 변경했더라도, **자신의 캐시 메모리에 남아있는 이전 값**을 계속 사용하게 될 수 있다.
- 스레드 A의 변경 사항이 메인 메모리에 반영되었더라도, **스레드 B가 자신의 캐시 메모리를 갱신하지 않으면** 여전히 과거의 값을 보게 된다.
- 캐시가 갱신되는 시점은 CPU 아키텍처나 상황에 따라 다르며, 예측할 수 없다. 보통 컨텍스트 스위칭이 발생할 때(`Thread.sleep()` 호출 시나, 콘솔에 내용 출력 시) 캐시 메모리를 갱신하지만 보장되지 않는다.

### 1.3. 메모리 가시성 문제란?

- 이처럼 멀티스레드 환경에서 **한 스레드의 변경 사항이 다른 스레드에 즉시 보이지 않는 문제**를 **메모리 가시성(Memory Visibility) 문제**라고 한다.
