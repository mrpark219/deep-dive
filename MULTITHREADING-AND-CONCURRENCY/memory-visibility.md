# 메모리 가시성

## 1. 메모리 가시성 문제

- 보통 변수를 읽을 때 **메인 메모리(Main Memory)에서 직접 값을 가져온다**고 생각한다. 하지만 실제로는 그렇지 않다.

### 1.1. 실제 메모리 접근 방식: CPU 캐시

- CPU는 처리 성능을 높이기 위해, 메인 메모리보다 **훨씬 빠르지만 용량이 작은 캐시 메모리(Cache Memory)** 를 중간에 사용한다.
- CPU가 특정 변수를 사용하면, 그 값을 **캐시 메모리에 복사**해두고 다음부터는 메인 메모리가 아닌 캐시에서 값을 읽어온다.
- 캐시 메모리는 대부분 코어 단위로 가지고 있으며 여러 코어가 공유하는 캐시 메모리도 가지고 있다.

### 1.2. 가시성 문제가 발생하는 과정

- 멀티스레드 환경에서는, **각 스레드가 별도의 CPU 코어에서 실행**될 수 있다. 이때 각 스레드는 **자신만의 캐시 메모리**에 변수 값을 저장한다.
- 만약 스레드 A가 공유 변수의 값을 변경하면, 이 변경은 **스레드 A의 캐시 메모리에만 반영**된다. 이 변경 사항이 **언제 메인 메모리에 반영될지는 보장되지 않는다**.
- 따라서, 스레드 B는 스레드 A가 값을 변경했더라도, **자신의 캐시 메모리에 남아있는 이전 값**을 계속 사용하게 될 수 있다.
- 스레드 A의 변경 사항이 메인 메모리에 반영되었더라도, **스레드 B가 자신의 캐시 메모리를 갱신하지 않으면** 여전히 과거의 값을 보게 된다.
- 캐시가 갱신되는 시점은 CPU 아키텍처나 상황에 따라 다르며, 예측할 수 없다. 보통 컨텍스트 스위칭이 발생할 때(`Thread.sleep()` 호출 시나, 콘솔에 내용 출력 시) 캐시 메모리를 갱신하지만 보장되지 않는다.

### 1.3. 메모리 가시성 문제란?

- 이처럼 멀티스레드 환경에서 **한 스레드의 변경 사항이 다른 스레드에 즉시 보이지 않는 문제**를 **메모리 가시성(Memory Visibility) 문제**라고 한다.

## 2. 메모리 가시성 해결

- 메모리 가시성 문제는, **성능을 약간 포기하는 대신 변수를 읽고 쓸 때 모두 메인 메모리에 직접 접근**하도록 강제하면 해결할 수 있다.
- 자바에서는 **`volatile`** 키워드를 통해 이 기능을 제공한다.

## 3. 자바 메모리 모델 (JMM)

- **자바 메모리 모델(JMM)**은 자바 프로그램의 메모리 접근 방식을 규정하며, 특히 멀티스레드 환경에서 스레드 간의 상호작용을 정의한다.
- 핵심은 여러 스레드의 작업 순서를 보장하는 **`happens-before` 관계**에 대한 정의이다.

### 3.1. happens-before 관계란?

- **`happens-before`** 관계는 자바 메모리 모델에서 **두 작업 사이의 순서를 보장**하는 핵심 규칙이다.
- 만약 '작업 A'가 '작업 B'보다 `happens-before` 관계에 있다면, **작업 A에서 변경된 모든 메모리 내용은 작업 B가 시작되기 전에 모두 메모리에 반영되는 것이 보장**된다.
- 이름 그대로, **한 동작이 다른 동작보다 '반드시 먼저 일어났다'고 확신**할 수 있게 해주는 약속이다.

### 3.2. happens-before 규칙

- **프로그램 순서 규칙**: 한 스레드 안에서는 코드를 작성한 순서대로 일이 일어난다.
- **volatile 변수 규칙**: `volatile 변수`에 값을 쓰는(write) 동작은, 그 이후에 다른 스레드가 그 변수를 읽는(read) 동작보다 반드시 먼저 일어난다.
- **스레드 시작 규칙**: 부모 스레드에서 `Thread.start()`를 호출하는 동작은, 새로 생긴 자식 스레드 내부의 모든 동작보다 반드시 먼저 일어난다.
- **스레드 종료 규칙**: 자식 스레드의 모든 동작은, 그 스레드에 대해 `Thread.join()`을 호출한 부모 스레드가 join()에서 깨어난 이후의 동작보다 반드시 먼저 일어난다.
- **인터럽트(Interrupt) 규칙**: 스레드 A가 스레드 B에게 `interrupt()`를 호출하는 동작은, 스레드 B가 인터럽트 상태를 감지하는 동작보다 반드시 먼저 일어난다.
- **모니터 락(Monitor Lock) 규칙**: 어떤 락을 해제(unlock)하는 동작(`synchronized 블록`, `ReentrantLock`)은, 그 이후에 다른 스레드가 같은 락을 획득(lock)하는 동작보다 반드시 먼저 일어난다.
- **전이성(Transitivity) 규칙**: 만약 A가 B보다 happens-before이고, B가 C보다 happens-before이면, A는 C보다 happens-before이다.

## 4. 정리

- **`volatile`** 키워드나 **`synchronized`와 같은 스레드 동기화 기법**을 사용하면, **메모리 가시성 문제가 발생하지 않는다**.
