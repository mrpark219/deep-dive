# 스레드 제어와 생명 주기

## 1. 스레드 생성

- `Thread`를 생성할 때, `Runnable` 구현체와 함께 스레드의 이름을 인자로 전달할 수 있다.

```java
// 실행할 작업(Runnable)과 스레드 이름("myThread")을 전달하여 스레드 생성
Thread myThread = new Thread(new HelloRunnable(), "myThread");
```

- `Runnable` 인터페이스: 스레드가 실행할 작업을 정의하는 인터페이스이다.
- 스레드 이름: **디버깅이나 로깅 시 스레드를 식별**하는 데 유용한 이름이다. 이름을 지정하지 않으면 `Thread-0`과 같이 자동으로 생성된다.

## 2. 스레드 객체 정보

- `Thread` 클래스의 `toString()` 메서드는 스레드에 대한 **주요 정보를 요약한 문자열을 반환**한다.
- 예시: `Thread[#1,main,5,main]`는 각각 **스레드 ID, 이름, 우선순위, 그룹**을 의미한다.

### 2.1. 스레드 ID (`threadId()`)

- **스레드의 고유 식별자(ID)**를 반환하는 메서드이다. 이 ID는 JVM 내에서 유일하며, **직접 지정할 수 없다**.

### 2.2. 스레드 이름 (`getName()`)

- **스레드의 이름을 반환**하는 메서드이다. 스레드 이름은 **서로 중복될 수 있다**.

### 2.3. 스레드 우선순위 (`getPriority()`)

- **스레드의 우선순위를 반환**하는 메서드이다. 우선순위는 **1(가장 낮음)부터 10(가장 높음)까지의 값**을 가지며, 기본값은 5이다.
- 우선순위는 스케줄러가 어떤 스레드를 먼저 실행할지 결정하는 데 영향을 주지만, **실제 실행 순서는 운영체제에 따라 달라질 수 있다**.

### 2.4. 스레드 그룹 (`getThreadGroup()`)

- **스레드가 속한 스레드 그룹을 반환**하는 메서드이다. 스레드 그룹은 여러 스레드를 하나의 단위로 묶어 관리하는 기능을 제공한다.
- 스레드는 자신을 생성한 **부모 스레드(Parent Thread)와 동일한 스레드 그룹**에 속하게 된다.
- `main()` 메서드에서 생성된 `myThread`의 부모는 `main` 스레드이므로, `myThread` 역시 `main` 스레드가 속한 `main` 그룹에 소속된다.

### 2.5. 스레드 상태 (`getState()`)

- **스레드의 현재 상태**를 `Thread.State` 열거형으로 반환하는 메서드이다.
  - `NEW`: 스레드가 생성되었지만 아직 `start()`가 호출되지 않은 상태이다.
  - `RUNNABLE`: 실행 가능 상태로, CPU를 할당받으면 언제든지 실행될 수 있는 상태이다.
  - `BLOCKED`: 동기화 락(synchronized)을 얻기 위해 대기하는 상태이다.
  - `WAITING`: 다른 스레드가 특정 작업을 수행하고 통지(notify)해주기를 무한정 기다리는 상태이다.
  - `TIMED_WAITING`: 지정된 시간 동안만 기다리는 상태이다.
  - `TERMINATED`: `run()` 메서드의 실행이 완전히 종료된 상태이다.

## 3. 스레드의 생명 주기

- 자바 스레드는 여러 상태를 가지며, 이 상태들의 변화 과정을 **스레드 생명 주기(Thread Lifecycle)** 라고 한다.
- 주요 상태는 `New`, `Runnable`, `Terminated`이며, `Runnable` 상태에서 다른 작업을 기다리는 여러 **'일시 중지' 상태**(`Blocked`, `Waiting`, `Timed Waiting`)로 전환될 수 있다.

### 3.1. New (생성)

- **`Thread` 객체가 생성되었지만, 아직 `start()` 메서드가 호출되지 않은 상태**이다.

### 3.2. Runnable (실행 대기)

- `start()` 메서드가 호출되면 스레드는 이 상태로 들어간다.
- 이 상태는 스레드가 **실행 중이거나 또는 실행될 준비가 되어** 언제든 CPU를 할당받을 수 있음을 의미한다.
- 자바에서는 OS 스케줄러의 실행 대기열에 있는 상태와, 실제 CPU에서 실행 중인 상태를 **구분하지 않고 모두 `Runnable` 상태**로 본다.

### 3.3. Blocked (일시 중지: 동기화 블록)

- **`synchronized` 블록에 진입하기 위해 다른 스레드가 점유한 락(lock)을 기다리는 상태**이다.

### 3.4. Waiting (일시 중지: 무한 대기)

- **다른 스레드가 특정 작업을 완료하고 `notify()` 또는 `notifyAll()`을 호출해줄 때까지 무한정 기다리는 상태**이다.
- `Object.wait()`, `Thread.join()` 메서드 등이 호출될 때 이 상태가 된다.

### 3.5. Timed Waiting (일시 중지: 시간 제한 대기)

- **지정된 시간 동안만 다른 스레드의 작업이 완료되기를 기다리는 상태**이다.
- 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태에서 벗어난다. `Thread.sleep(long)`, `Object.wait(long)` 등이 호출될 때 이 상태가 된다.

### 3.6. Terminated (종료)

- `run()` 메서드의 실행이 정상적으로, 혹은 예외로 인해 **완전히 종료된 상태**이다.
- 한번 `Terminated` 상태가 된 스레드는 다시 시작할 수 없다.

### 3.7. 자바 스레드의 상태 전이 과정

- **`New` → `Runnable`**
  - `start()` 메서드를 호출하면 전이된다.
- **`Runnable` → `Blocked`/`Waiting`/`Timed Waiting`**
  - 동기화 락을 기다리거나, `wait()`, `sleep()`, `join()` 등의 메서드를 호출하면 전이된다.
- **`Blocked`/`Waiting`/`Timed Waiting` → `Runnable`**
  - 락을 얻거나, 기다림이 끝나면(시간 초과, `notify` 등) 다시 `Runnable` 상태로 돌아가 실행 순서를 기다린다.
- **`Runnable` → `Terminated`**
  - `run()` 메서드가 완료되면 `Terminated` 상태가 된다.

## 4. run() 메서드와 체크 예외

### 4.1. 왜 run()은 체크 예외를 던질 수 없는가?

- `Runnable` 인터페이스의 `run()` 메서드를 구현할 때, `InterruptedException`과 같은 **체크 예외(Checked Exception)를 메서드 밖으로 던질 수 없다**.
- 이는 자바의 **메서드 재정의(Overriding) 규칙** 때문이다. `Runnable` 인터페이스의 정의는 다음과 같다.

```java
public interface Runnable {
    void run();
}
```

### 4.2. 자바의 예외 재정의 규칙

- 자바에서 메서드를 재정의할 때, 예외와 관련된 규칙은 다음과 같다.
  - **체크 예외**: 자식 클래스의 메서드는 **부모 클래스의 메서드가 던지는 예외보다 더 넓은 범위의 체크 예외를 던질 수 없다**. 부모 메서드가 예외를 던지지 않는다면, 자식 메서드 역시 체크 예외를 던질 수 없다.
  - **언체크 예외(런타임 예외)**: 예외 처리를 강제하지 않으므로, 이러한 **규칙에 상관없이 자유롭게** 던질 수 있다.
- `Runnable` 인터페이스의 `run()` 메서드는 아무런 체크 예외도 던지고 있지 않으므로, 이 규칙에 따라 **`run()`을 재정의한 메서드 역시 체크 예외를 던질 수 없다**.

### 4.3. 규칙의 이유와 효과

- 이러한 제약이 있는 이유는 **클라이언트 코드의 일관성**을 지키기 위함이다. 부모 타입으로 메서드를 호출하는 코드는 부모 메서드가 던지는 예외만 처리하도록 작성된다. 만약 자식 클래스가 예상치 못한 더 넓은 범위의 예외를 던지면, 클라이언트 코드는 이를 제대로 처리하지 못할 수 있다.
- `run()` 메서드가 체크 예외를 던질 수 없도록 강제함으로써, 개발자는 **`try-catch` 블록을 사용해 스레드 내부에서 예외를 반드시 처리**하게 된다.
- 이는 특히 멀티스레딩 환경에서 **예외로 인해 스레드가 비정상적으로 종료되는 상황을 방지**하고, 시스템의 안정성을 유지하는 데 도움을 준다.

## 5. 다른 스레드의 종료를 기다리기: join()

- 메인 스레드가 다른 스레드(스레드 1, 2)에게 계산 작업을 나누어 시킨 뒤, **두 스레드의 계산 결과를 모두 합쳐서 최종 작업을 마무리**하고 싶다고 가정한다.
- 하지만 `start()` 메서드는 스레드를 실행시키기만 할 뿐, 그 작업이 끝날 때까지 기다려주지 않는다. 따라서 별도의 장치 없이는, **다른 스레드의 계산이 끝나기도 전에 메인 스레드가 먼저 종료**되는 문제가 발생한다.
- 이 문제를 해결하기 위해 **`Thread.sleep()`을 이용해 무작정 기다리는 방법**을 생각할 수 있다. 하지만 이는 다른 스레드의 작업 시간을 정확히 예측할 수 없으므로 **매우 부정확하고 비효율적인 나쁜 방법**이다.
- 이럴 때 사용하는 올바른 방법이 바로 **`join()`** 메서드이다. `thread1.join()`을 호출하면, `main` 스레드는 `thread1`의 작업이 끝날 때(`Terminated` 상태)까지 **`WAITING` 상태**가 되어 기다린다.
- `join()` 메서드는 다른 스레드가 완료될 때까지 무기한 기다리는 단점이 있다. 만약 다른 스레드의 작업을 **일정 시간 동안만 기다리고 싶다면 `join(long millis)`**를 호출하면 된다.
- 이 경우, `main` 스레드는 무기한 대기하는 `WAITING` 상태가 아니라, 지정된 시간 동안만 대기하는 **`TIMED_WAITING` 상태**가 된다.

## 6. 인터럽트

### 6.1. 인터럽트의 개념

- 실행 중인 다른 스레드의 작업을 **안전하게 중단시키거나, 대기 상태의 스레드를 깨워야 할 때** 사용하는 것이 바로 **인터럽트(Interrupt)** 이다.
- 단순히 `volatile` flag 변수를 사용하는 방법도 있지만, 이는 스레드가 대기 상태(`WAITING`, `TIMED_WAITING`)일 때 즉시 작업을 중단시킬 수 없는 한계가 있다.

### 6.2. 인터럽트 발생시키기

- 다른 스레드 객체의 **`interrupt()` 메서드를 호출**하면, 해당 스레드에 **인터럽트 신호**를 보낼 수 있다.
- 만약 대상 스레드가 `sleep()`, `join()` 등으로 **대기 상태(`WAITING`, `TIMED_WAITING`)에 있다면, `InterruptedException` 예외가 발생**하며 즉시 깨어난다.
- 예외가 발생하면, 스레드는 **`Runnable` 상태**가 되며, **인터럽트 상태는 다시 `false`(정상)로 초기화**된다.

### 6.3. 인터럽트 상태 확인하기

- 만약 스레드가 대기 상태가 아니라 계속 실행 중이라면, `interrupt()`가 호출되어도 즉시 예외가 발생하지 않는다. 이 경우, **직접 인터럽트 상태를 확인하고 종료 로직을 처리**해야 한다.
- 인터럽트 상태를 확인하는 메서드는 두 가지가 있다.
  - `isInterrupted()`
    - 인스턴스 메서드이며(`Thread.currentThread().isInterrupted()`), 인터럽트 상태를 **확인만 하고 변경하지는 않는다**.
  - `Thread.interrupted()`
    - 정적(static) 메서드이며(`Thread.interrupted()`), **현재 스레드의 인터럽트 상태를 확인한 뒤, 그 상태를 `false`(정상)로 다시 초기화**한다.
- 만약 `InterruptedException`을 `catch` 블록에서 처리한 뒤, **상위 호출자에게도 인터럽트가 발생했음을 알려야 할 경우**에는, `Thread.currentThread().interrupt()`를 다시 호출하여 인터럽트 상태를 복원하는 것이 좋은 패턴이다.

## 7. yield: 스레드 실행 양보하기

- 어떤 스레드를 얼마나 실행할지는 운영체제의 스케줄링에 따라 결정된다.
- 하지만 때로는 현재 스레드가 **다른 스레드에게 CPU 실행 기회를 양보**하고 싶을 수 있다. 이를 통해 대기 중인 다른 스레드가 실행 기회를 더 빨리 얻을 수 있다.

### 7.1. 양보하지 않는 경우

- 양보 로직이 없는 경우, 운영체제 스케줄러가 정해준 시간만큼 **하나의 스레드가 가능한 한 길게 실행**된 후 다른 스레드로 전환된다.

### 7.2. `sleep()`을 이용한 양보

- `Thread.sleep()`은 스레드의 상태를 `RUNNABLE`에서 **`TIMED_WAITING` 상태로 변경**한다. 이 상태에서는 스레드가 CPU 자원을 사용하지 않고, 스케줄링에서 잠시 제외된다.
- 이 방식은 `RUNNABLE` → `TIMED_WAITING` → `RUNNABLE`로 상태를 전환하는 비용이 발생하며, **양보할 다른 스레드가 없더라도 무조건 지정된 시간만큼 대기**하는 비효율이 발생할 수 있다.

### 7.3. `yield()`를 이용한 양보

- 자바의 `RUNNABLE` 상태는, 운영체제 관점에서 다시 아래 두 가지 상태로 나눌 수 있다.
  - **실행(Running) 상태**: 스레드가 CPU에서 실제로 실행 중인 상태이다.
  - **실행 대기(Ready) 상태**: 스레드가 실행될 준비가 되었지만, 스케줄링 큐에서 대기 중인 상태이다.
- 운영체제 스케줄러는 이 두 상태를 매우 빠르게 오가며 여러 스레드를 번갈아 실행시킨다.
- `Thread.yield()` 메서드는 현재 **'실행' 상태인 스레드를 '실행 대기' 상태로 전환**하여, 스케줄링 큐의 맨 뒤로 보내도록 **운영체제 스케줄러에게 힌트(hint)** 를 주는 것이다.
- `yield()`는 `sleep()`과 달리 **`RUNNABLE` 상태를 그대로 유지**한다. 따라서 양보할 다른 스레드가 없다면, **즉시 다시 CPU를 할당받아 계속 실행**될 수 있다.
- `yield()`는 **단지 힌트일 뿐 강제성이 없으므로**, 스케줄러에 의해 무시될 수 있으며, 반드시 다른 스레드가 실행된다는 보장도 없다.
