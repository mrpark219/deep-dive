# 스레드 제어와 생명 주기

## 1. 스레드 생성

- `Thread`를 생성할 때, `Runnable` 구현체와 함께 스레드의 이름을 인자로 전달할 수 있다.

```java
// 실행할 작업(Runnable)과 스레드 이름("myThread")을 전달하여 스레드 생성
Thread myThread = new Thread(new HelloRunnable(), "myThread");
```

- `Runnable` 인터페이스: 스레드가 실행할 작업을 정의하는 인터페이스이다.
- 스레드 이름: **디버깅이나 로깅 시 스레드를 식별**하는 데 유용한 이름이다. 이름을 지정하지 않으면 `Thread-0`과 같이 자동으로 생성된다.

## 2. 스레드 객체 정보

- `Thread` 클래스의 `toString()` 메서드는 스레드에 대한 **주요 정보를 요약한 문자열을 반환**한다.
- 예시: `Thread[#1,main,5,main]`는 각각 **스레드 ID, 이름, 우선순위, 그룹**을 의미한다.

### 2.1. 스레드 ID (`threadId()`)

- **스레드의 고유 식별자(ID)**를 반환하는 메서드이다. 이 ID는 JVM 내에서 유일하며, **직접 지정할 수 없다**.

### 2.2. 스레드 이름 (`getName()`)

- **스레드의 이름을 반환**하는 메서드이다. 스레드 이름은 **서로 중복될 수 있다**.

### 2.3. 스레드 우선순위 (`getPriority()`)

- **스레드의 우선순위를 반환**하는 메서드이다. 우선순위는 **1(가장 낮음)부터 10(가장 높음)까지의 값**을 가지며, 기본값은 5이다.
- 우선순위는 스케줄러가 어떤 스레드를 먼저 실행할지 결정하는 데 영향을 주지만, **실제 실행 순서는 운영체제에 따라 달라질 수 있다**.

### 2.4. 스레드 그룹 (`getThreadGroup()`)

- **스레드가 속한 스레드 그룹을 반환**하는 메서드이다. 스레드 그룹은 여러 스레드를 하나의 단위로 묶어 관리하는 기능을 제공한다.
- 스레드는 자신을 생성한 **부모 스레드(Parent Thread)와 동일한 스레드 그룹**에 속하게 된다.
- `main()` 메서드에서 생성된 `myThread`의 부모는 `main` 스레드이므로, `myThread` 역시 `main` 스레드가 속한 `main` 그룹에 소속된다.

### 2.5. 스레드 상태 (`getState()`)

- **스레드의 현재 상태**를 `Thread.State` 열거형으로 반환하는 메서드이다.
  - `NEW`: 스레드가 생성되었지만 아직 `start()`가 호출되지 않은 상태이다.
  - `RUNNABLE`: 실행 가능 상태로, CPU를 할당받으면 언제든지 실행될 수 있는 상태이다.
  - `BLOCKED`: 동기화 락(synchronized)을 얻기 위해 대기하는 상태이다.
  - `WAITING`: 다른 스레드가 특정 작업을 수행하고 통지(notify)해주기를 무한정 기다리는 상태이다.
  - `TIMED_WAITING`: 지정된 시간 동안만 기다리는 상태이다.
  - `TERMINATED`: `run()` 메서드의 실행이 완전히 종료된 상태이다.

## 3. 스레드의 생명 주기

- 자바 스레드는 여러 상태를 가지며, 이 상태들의 변화 과정을 **스레드 생명 주기(Thread Lifecycle)** 라고 한다.
- 주요 상태는 `New`, `Runnable`, `Terminated`이며, `Runnable` 상태에서 다른 작업을 기다리는 여러 **'일시 중지' 상태**(`Blocked`, `Waiting`, `Timed Waiting`)로 전환될 수 있다.

### 3.1. New (생성)

- **`Thread` 객체가 생성되었지만, 아직 `start()` 메서드가 호출되지 않은 상태**이다.

### 3.2. Runnable (실행 대기)

- `start()` 메서드가 호출되면 스레드는 이 상태로 들어간다.
- 이 상태는 스레드가 **실행 중이거나 또는 실행될 준비가 되어** 언제든 CPU를 할당받을 수 있음을 의미한다.
- 자바에서는 OS 스케줄러의 실행 대기열에 있는 상태와, 실제 CPU에서 실행 중인 상태를 **구분하지 않고 모두 `Runnable` 상태**로 본다.

### 3.3. Blocked (일시 중지: 동기화 블록)

- **`synchronized` 블록에 진입하기 위해 다른 스레드가 점유한 락(lock)을 기다리는 상태**이다.

### 3.4. Waiting (일시 중지: 무한 대기)

- **다른 스레드가 특정 작업을 완료하고 `notify()` 또는 `notifyAll()`을 호출해줄 때까지 무한정 기다리는 상태**이다.
- `Object.wait()`, `Thread.join()` 메서드 등이 호출될 때 이 상태가 된다.

### 3.5. Timed Waiting (일시 중지: 시간 제한 대기)

- **지정된 시간 동안만 다른 스레드의 작업이 완료되기를 기다리는 상태**이다.
- 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태에서 벗어난다. `Thread.sleep(long)`, `Object.wait(long)` 등이 호출될 때 이 상태가 된다.

### 3.6. Terminated (종료)

- `run()` 메서드의 실행이 정상적으로, 혹은 예외로 인해 **완전히 종료된 상태**이다.
- 한번 `Terminated` 상태가 된 스레드는 다시 시작할 수 없다.

### 3.7. 자바 스레드의 상태 전이 과정

- **`New` → `Runnable`**
  - `start()` 메서드를 호출하면 전이된다.
- **`Runnable` → `Blocked`/`Waiting`/`Timed Waiting`**
  - 동기화 락을 기다리거나, `wait()`, `sleep()`, `join()` 등의 메서드를 호출하면 전이된다.
- **`Blocked`/`Waiting`/`Timed Waiting` → `Runnable`**
  - 락을 얻거나, 기다림이 끝나면(시간 초과, `notify` 등) 다시 `Runnable` 상태로 돌아가 실행 순서를 기다린다.
- **`Runnable` → `Terminated`**
  - `run()` 메서드가 완료되면 `Terminated` 상태가 된다.

## 4. run() 메서드와 체크 예외

### 4.1. 왜 run()은 체크 예외를 던질 수 없는가?

- `Runnable` 인터페이스의 `run()` 메서드를 구현할 때, `InterruptedException`과 같은 **체크 예외(Checked Exception)를 메서드 밖으로 던질 수 없다**.
- 이는 자바의 **메서드 재정의(Overriding) 규칙** 때문이다. `Runnable` 인터페이스의 정의는 다음과 같다.

```java
public interface Runnable {
    void run();
}
```

### 4.2. 자바의 예외 재정의 규칙

- 자바에서 메서드를 재정의할 때, 예외와 관련된 규칙은 다음과 같다.
  - **체크 예외**: 자식 클래스의 메서드는 **부모 클래스의 메서드가 던지는 예외보다 더 넓은 범위의 체크 예외를 던질 수 없다**. 부모 메서드가 예외를 던지지 않는다면, 자식 메서드 역시 체크 예외를 던질 수 없다.
  - **언체크 예외(런타임 예외)**: 예외 처리를 강제하지 않으므로, 이러한 **규칙에 상관없이 자유롭게** 던질 수 있다.
- `Runnable` 인터페이스의 `run()` 메서드는 아무런 체크 예외도 던지고 있지 않으므로, 이 규칙에 따라 **`run()`을 재정의한 메서드 역시 체크 예외를 던질 수 없다**.

### 4.3. 규칙의 이유와 효과

- 이러한 제약이 있는 이유는 **클라이언트 코드의 일관성**을 지키기 위함이다. 부모 타입으로 메서드를 호출하는 코드는 부모 메서드가 던지는 예외만 처리하도록 작성된다. 만약 자식 클래스가 예상치 못한 더 넓은 범위의 예외를 던지면, 클라이언트 코드는 이를 제대로 처리하지 못할 수 있다.
- `run()` 메서드가 체크 예외를 던질 수 없도록 강제함으로써, 개발자는 **`try-catch` 블록을 사용해 스레드 내부에서 예외를 반드시 처리**하게 된다.
- 이는 특히 멀티스레딩 환경에서 **예외로 인해 스레드가 비정상적으로 종료되는 상황을 방지**하고, 시스템의 안정성을 유지하는 데 도움을 준다.

## 5. 다른 스레드의 종료를 기다리기: join()

- 메인 스레드가 다른 스레드(스레드 1, 2)에게 계산 작업을 나누어 시킨 뒤, **두 스레드의 계산 결과를 모두 합쳐서 최종 작업을 마무리**하고 싶다고 가정한다.
- 하지만 `start()` 메서드는 스레드를 실행시키기만 할 뿐, 그 작업이 끝날 때까지 기다려주지 않는다. 따라서 별도의 장치 없이는, **다른 스레드의 계산이 끝나기도 전에 메인 스레드가 먼저 종료**되는 문제가 발생한다.
- 이 문제를 해결하기 위해 **`Thread.sleep()`을 이용해 무작정 기다리는 방법**을 생각할 수 있다. 하지만 이는 다른 스레드의 작업 시간을 정확히 예측할 수 없으므로 **매우 부정확하고 비효율적인 나쁜 방법**이다.
- 이럴 때 사용하는 올바른 방법이 바로 **`join()`** 메서드이다. `thread1.join()`을 호출하면, `main` 스레드는 `thread1`의 작업이 끝날 때(`Terminated` 상태)까지 **`WAITING` 상태**가 되어 기다린다.
- `join()` 메서드는 다른 스레드가 완료될 때까지 무기한 기다리는 단점이 있다. 만약 다른 스레드의 작업을 **일정 시간 동안만 기다리고 싶다면 `join(long millis)`**를 호출하면 된다.
- 이 경우, `main` 스레드는 무기한 대기하는 `WAITING` 상태가 아니라, 지정된 시간 동안만 대기하는 **`TIMED_WAITING` 상태**가 된다.
