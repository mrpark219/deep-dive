# 애그리거트

## 1. 애그리거트

- 수백 개의 테이블을 한 장의 ERD에 모두 표시하면 개별 관계에 집중하느라 큰 틀의 데이터 구조를 놓치기 쉽다.
- 마찬가지로 도메인 모델이 복잡해지면, 개발자는 개별 객체 위주로 모델을 보게 되어 **전체적인 구조나 상위 수준의 관계를 파악하기 어려워진다**.
- 이처럼 큰 그림을 이해하지 못하면, **요구사항 변경 및 확장에 소극적으로 대처**하게 되고 코드 수정을 회피하려는 경향이 생길 수 있다.
- 이러한 복잡성을 해결하고 상위 수준에서 모델을 조망하기 위한 방법이 바로 **애그리거트(Aggregate)** 이다.
- 애그리거트는 **서로 연관된 객체들을 하나의 군집으로 묶어주는 역할**을 한다. 수많은 객체를 애그리거트 단위로 묶어서 바라보면, 상위 수준에서 도메인 모델 간의 관계를 쉽게 파악할 수 있다.
- 애그리거트는 단순히 모델을 이해하는 데 도움을 줄 뿐만 아니라, **데이터의 일관성을 관리하는 기준**이 되기도 한다.
- 결론적으로 애그리거트는 복잡한 도메인을 더 단순한 구조로 만들어 주며, 이를 통해 **도메인 기능을 확장하고 변경하는 데 필요한 노력을 줄여준다**.

### 1.1. 애그리거트 설계 지침

- 애그리거트의 경계를 정하는 기준은 **도메인 규칙과 요구사항**이다. 'A가 B를 소유한다'는 관계가 있다고 해서 A와 B가 **반드시 하나의 애그리거트에 속하는 것은 아니다**.
- 예를 들어 제품과 리뷰라는 두 엔티티가 있을 때 제품과 리뷰가 한 애그리거트에 속한다고 생각할 수 있다. 하지만 두 엔티티는 함께 생성되거나 변경되지 않고, 변경 주체도 다르기 때문에 서로 다른 애그리거트에 속한다.
- 애그리거트는 **독립적인 객체 군집**이다. 각 애그리거트는 자기 자신을 관리할 뿐, 다른 애그리거트를 관리하지 않는다.
- 처음에는 애그리거트를 크게 설계하는 경향이 있지만, **도메인을 깊이 이해할수록 애그리거트의 크기는 작아지는 경우가 많다**. 실제로 다수의 애그리거트는 하나의 엔티티만으로 구성되기도 한다.
- 한 애그리거트에 속한 객체들은 **유사하거나 동일한 라이프사이클**을 가지는 경우가 많다.

## 2. 애그리거트 루트

- 애그리거트는 여러 객체가 모여있기 때문에, **도메인 규칙을 지키려면 애그리거트 전체의 일관성**이 유지되어야 한다.
- 이처럼 애그리거트의 일관성을 관리하는 주체가 바로 **애그리거트 루트(Aggregate Root)** 이다.
- 애그리거트 루트는 애그리거트를 대표하는 엔티티이며, 애그리거트에 속한 모든 객체는 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

### 2.1. 일관성 관리와 캡슐화

- 애그리거트 루트의 핵심 역할은 **애그리거트의 일관성이 깨지지 않도록 하는 것**이다.
- 이를 위해, 애그리거트 외부에서는 **내부 객체를 직접 변경할 수 없도록** 만들어야 한다. 외부에서 내부 상태를 마음대로 변경할 수 있다면, 논리적인 데이터 일관성이 깨질 수 있기 때문이다.
- 일관성을 위한 상태 확인 로직을 응용 서비스에 구현하면, **여러 서비스에 동일한 코드가 중복될 가능성**이 커진다.
- 따라서 불필요한 중복을 피하고 캡슐화를 강화하려면, 다음 두 가지를 습관적으로 적용하는 것이 중요하다.
  - 단순히 필드 값을 변경하는 `set` 메서드를 **공개(public) 범위로 만들지 않는다**.
  - 밸류(Value) 타입은 **불변(Immutable)으로 구현**한다.
- 공개 `set` 메서드가 없으면 **기능의 의도가 드러나는 메서드를 작성**하게 되며, 불변 밸류를 사용하면 애그리거트 외부에서 상태를 변경하는 것을 원천적으로 차단할 수 있다.

### 2.2. 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내의 **다른 객체들을 조합하여 필요한 기능을 완성**한다.
- 때로는 기능 실행을 내부의 다른 객체에 위임하기도 한다.
- 만약 팀 표준이나 기술 제약으로 밸류 타입을 불변으로 만들 수 없다면, 변경 관련 기능을 **`protected` 범위 등으로 제한**하여 외부에서의 직접적인 사용을 막는 방법도 있다.

### 2.3. 트랜잭션 범위

- 트랜잭션의 범위는 가능한 한 작아야 한다. 일반적으로 **'한 트랜잭션에서는 한 개의 애그리거트만 수정한다'** 는 규칙을 따르는 것이 좋다.
- 한 번에 여러 애그리거트를 수정하면 **트랜잭션 충돌 가능성이 높아져** 전체 시스템의 처리량이 떨어질 수 있다.
- 또한, 한 애그리거트가 다른 애그리거트를 수정하는 것은 책임 범위를 넘어서는 것이며, **애그리거트 간 결합도를 높여** 수정 비용을 증가시킨다.
- 부득이하게 여러 애그리거트를 수정해야 한다면, 애그리거트가 다른 애그리거트를 직접 수정하는 대신 **응용 서비스에서 각 애그리거트를 순서대로 수정**하도록 구현해야 한다.
- 또는 **도메인 이벤트(Domain Event)** 를 사용하면, 하나의 트랜잭션을 유지하면서도 다른 애그리거트의 상태를 변경하는 작업을 동기 혹은 비동기로 처리할 수 있다.
- 물론 다음처럼 **예외적인 경우**에는 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 것을 고려할 수 있다.
  - **팀 표준**: 조직의 표준에 따라 특정 유스케이스를 단일 트랜잭션으로 처리해야 하는 경우
  - **기술 제약**: 이벤트 방식을 도입하기 어려운 기술적 환경인 경우
  - **UI 편의성**: 사용자의 편의를 위해 여러 데이터를 한 번에 수정해야 하는 경우

## 3. 리포지터리와 애그리거트

- 애그리거트는 개념적으로 하나의 완전한 도메인 모델을 표현한다. 따라서 **객체의 영속성을 처리하는 리포지터리(Repository)는 애그리거트 단위로 존재**해야 한다.
- 리포지터리는 일반적으로 애그리거트를 저장하고 조회하는 기능을 수행하므로, 보통 다음 두 메서드를 기본적으로 제공한다.
  - `save` : 애그리거트를 저장소에 영속화한다.
  - `findById` : 식별자(ID)로 애그리거트를 조회한다.
- 리포지터리를 **어떤 기술로 구현하느냐에 따라 애그리거트의 구현 방식도 영향**을 받는다.
- 예를 들어, JPA와 같은 ORM 기술을 사용하면 DB 테이블 구조에 맞게 도메인 모델을 일부 변경해야 할 수도 있다. 이 경우, 본래 밸류 타입으로 설계했던 모델을 `@Embeddable`이 아닌 `@Entity`로 구현해야 하는 상황이 발생하기도 한다.
- 리포지터리는 애그리거트 전체를 저장하고, **조회 시에는 완전한 상태의 애그리거트를 제공**해야 한다.
- 만약 리포지터리가 불완전한 애그리거트를 반환한다면, 애그리거트의 기능을 실행하는 도중에 **`NullPointerException`과 같은 예외가 발생**하여 도메인 규칙이 깨질 수 있다.

## 4. ID를 이용한 애그리거트 참조

- 애그리거트도 다른 애그리거트를 참조할 수 있다. 이는 한 애그리거트의 루트가 다른 애그리거트의 루트를 참조하는 것을 의미한다.
- 가장 쉬운 방법은 다른 애그리거트를 필드로 직접 참조하는 것이다. JPA와 같은 ORM 기술은 `@ManyToOne` 등의 애너테이션으로 이러한 **직접 참조 기능을 편리하게 제공**한다.
- 하지만 필드를 이용한 직접 참조는 다음과 같은 문제들을 야기할 수 있다.
  - **편한 탐색의 오용**: 한 애그리거트 내부에서 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다. 이는 **애그리거트 간의 결합도를 높여** 결국 전체 모델의 변경을 어렵게 만든다.
  - **성능 저하 우려**: 참조 객체를 즉시 로딩(Eager Loading)할지, 지연 로딩(Lazy Loading)할지에 대한 고민이 필요하다. 이는 **구현하는 기능에 따라 각 로딩 방식의 장단점이 뚜렷하기 때문이다**.
  - **확장성 저하**: 서비스 규모가 커져서 하위 도메인별로 시스템을 분리하게 되면, **더 이상 단일 DB 기술(JPA 등)에 의존하여 다른 애그리거트를 참조할 수 없게 된다**.
- 이러한 문제들을 해결하기 위해, 필드 직접 참조 대신 **ID를 이용해 다른 애그리거트를 참조**하는 방식을 사용할 수 있다. 이는 데이터베이스의 외래 키(FK) 참조와 유사하다.
- ID 참조 방식은 애그리거트 간의 **물리적인 연결을 끊어 경계를 명확히** 한다. 이를 통해 모델의 복잡도와 결합도를 낮추고, 응집도를 높여준다.
- 또한, 한 애그리거트가 다른 애그리거트의 내부 상태를 수정하는 문제를 **원천적으로 방지**할 수 있다.

### 4.1. ID를 이용한 참조와 조회 성능

- ID 참조 방식은 조회 시 성능 문제를 일으킬 수 있다. 연관된 여러 애그리거트를 가져오기 위해, 첫 조회 쿼리 이후 **참조하는 애그리거트의 수만큼 추가 쿼리가 발생하는 N+1 조회 문제**가 생길 수 있기 때문이다.
- 이 문제를 해결하는 가장 좋은 방법은, ID 참조 방식을 유지하면서 **조회 전용 쿼리(예: JPQL Fetch Join)를 사용**하여 한 번의 쿼리로 필요한 데이터를 모두 가져오는 것이다.
- 만약 애그리거트마다 서로 다른 저장소를 사용한다면, 한 번의 쿼리로 조회하는 것이 불가능하다. 이때는 **캐시(Cache)를 적용하거나 조회 전용 저장소를 별도로 구성**하여 성능을 높일 수 있다.
- 이러한 방법은 구현 복잡도를 높이지만, 대규모 트래픽을 처리해야 하는 시스템에서는 **전체 처리량을 높이기 위해 필수적**일 수 있다.
