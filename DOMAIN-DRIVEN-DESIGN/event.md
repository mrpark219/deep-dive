# 이벤트

## 1. 시스템 간 강결합 문제

- 쇼핑몰에서 주문을 취소하면 외부 결제 시스템과 연동하여 환불을 처리해야 한다. 이처럼 **하나의 도메인 기능이 외부 시스템의 기능을 실행해야 할 때**, 두 시스템을 **직접 연동(강결합)** 하면 여러 문제가 발생할 수 있다.
- 이러한 **강결합(High Coupling) 문제**를 해결하는 좋은 방법이 바로 **이벤트(Event)**, 특히 **비동기 이벤트를 사용**하는 것이다. 강결합 시 발생하는 주요 문제는 다음과 같다.

### 1.1. 트랜잭션 처리의 모호함

- 외부 시스템 연동 시 예외(Exception)가 발생하면, **현재 트랜잭션을 롤백해야 할지 커밋해야 할지** 결정하기가 모호하다.
- 예를 들어, 주문 취소는 성공했지만 외부 시스템의 환불 기능이 실패했을 때, 주문 취소까지 함께 롤백하는 것이 항상 올바른 정책은 아니다.

### 1.2. 성능 저하

- 직접 연동 방식은 **외부 시스템의 성능에 직접적인 영향을 받는다**.
- 만약 외부 환불 시스템의 응답이 늦어지면, 주문 취소 기능의 대기 시간도 그만큼 길어져 사용자 경험을 저하시킨다.

### 1.3. 데이터 변경 로직의 복잡성 증가

- 주문 취소 기능에 '환불' 외에 '취소 통지'와 같은 새로운 기능이 추가되면, **하나의 기능 안에 여러 로직이 섞이게 된다**.
- 이는 **코드의 복잡도를 높이고, 트랜잭션 관리 또한 더욱 어렵게** 만든다.

## 2. 이벤트 개요

- **이벤트(Event)** 란, **과거에 벌어진 어떤 것**을 의미한다. 도메인 모델에서는 **상태가 변경되었다는 사실 자체**를 이벤트로 표현할 수 있다.
- 요구사항 중 '~할 때', '~가 발생하면'과 같이 도메인의 상태 변경과 관련된 내용은 이벤트를 이용해 구현하기에 적합하다.

### 2.1. 이벤트 관련 구성요소

- 도메인 모델에 이벤트를 도입하려면, **이벤트, 이벤트 생성 주체, 이벤트 핸들러, 이벤트 디스패처**를 구현해야 한다.
- **이벤트 생성 주체(Event Generator)**: 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 상태가 변경되면 관련 이벤트를 발생시킨다.
- **이벤트 핸들러(Event Handler/Subscriber)**: 발생한 이벤트에 반응하여, 필요한 기능을 실행하는 구독자이다.
- **이벤트 디스패처(Event Dispatcher/Publisher)**: 이벤트 생성 주체와 핸들러를 연결해주는 중간 다리이다. 이벤트를 전달받아, 해당 이벤트를 처리할 수 있는 핸들러에게 전파한다.
- 디스패처의 구현 방식에 따라, 이벤트 처리 과정이 **동기(Sync) 또는 비동기(Async)로 실행**될 수 있다.

### 2.2. 이벤트의 구성

- 이벤트는 **자신이 표현하는 상태 변경과 관련된 정보**를 담는다. 보통 다음과 같은 데이터를 포함한다.
  - **이벤트 종류**: 보통 클래스 이름으로 표현한다.
  - **이벤트 발생 시간**
  - **관련 데이터**: 주문 번호, 신규 배송지 정보 등
- 이벤트 핸들러가 추가적인 조회 없이 작업을 수행할 수 있도록, **필요한 데이터를 충분히 담는 것**이 좋다.
- 하지만 이벤트 자체와 **직접적인 관련이 없는 데이터를 과도하게 포함할 필요는 없다**.

### 2.3. 이벤트 용도

- 이벤트는 크게 두 가지 용도로 사용된다.
  - **트리거(Trigger)**: 도메인의 한 영역에서 상태가 변경되었을 때, **다른 영역의 후처리를 실행**하기 위한 용도이다. 예를 들어, '주문 취소' 이벤트는 '환불 처리' 기능의 트리거가 될 수 있다.
  - **시스템 간 데이터 동기화**: 한 바운디드 컨텍스트에서 발생한 변경 사항을 **다른 바운디드 컨텍스트에 전파**하여, 두 시스템 간의 데이터 일관성을 맞추는 용도이다.

### 2.4. 이벤트 장점

- 이벤트를 사용하면, **서로 다른 도메인 로직이 섞이는 것을 방지하여 시스템의 결합도를 낮출 수 있다**.
- 예를 들어, 주문 취소 시 환불 로직을 직접 호출하는 대신 '주문 취소 이벤트'를 발생시키면, 주문 도메인은 결제 도메인에 대한 의존을 제거할 수 있다. 환불 책임은 이벤트를 구독하는 별도의 핸들러로 이동한다.
- 또한, **기능 확장이 매우 용이**해진다. '주문 취소 시 이메일 발송' 기능이 필요하다면, 기존 코드를 수정할 필요 없이 **새로운 이벤트 핸들러를 추가**하기만 하면 된다.

## 3. 이벤트, 핸들러, 디스패처 구현

- 스프링 프레임워크가 제공하는 기능을 이용하면, 이벤트 관련 코드를 손쉽게 구현할 수 있다. 구현에 필요한 주요 구성요소는 다음과 같다.
  - **이벤트 클래스**: 도메인에서 발생한 이벤트를 표현하는 객체이다.
  - **ApplicationEventPublisher**: 스프링이 제공하는 이벤트 발행(Publish) 도구이다.
  - **이벤트 핸들러**: `@EventListener`를 이용해 특정 이벤트를 구독하고 처리하는 컴포넌트이다.

### 3.1. 이벤트 클래스

- 이벤트를 표현하는 클래스를 만들 때, 반드시 상속받아야 하는 상위 타입은 없다. **원하는 어떤 클래스든 이벤트로 사용**할 수 있다.
- 다만, 이벤트는 '과거에 벌어진 일'을 의미하므로, **클래스 이름을 `OrderCanceledEvent`와 같이 과거 시제**로 짓는 것이 좋다.
- 이벤트 클래스는 핸들러가 로직을 처리하는 데 **필요한 최소한의 데이터를 포함**해야 한다.
- 만약 모든 이벤트가 공통으로 가져야 할 프로퍼티(예: 발생 시간)가 있다면, **관련 상위 추상 클래스를 만들어 상속**받게 할 수도 있다.

### 3.2. 이벤트 발행: `ApplicationEventPublisher`

- 이벤트 발행을 위해서는 스프링이 제공하는 **`ApplicationEventPublisher` 인터페이스를 사용**한다. 스프링 컨테이너 자체가 이 인터페이스의 구현체이므로, 필요한 곳에 주입받아 사용할 수 있다.
- `ApplicationEventPublisher`의 **`publishEvent(eventObject)` 메서드를 호출**하여 이벤트를 발행한다.
- 도메인 객체가 `ApplicationEventPublisher`에 직접 의존하는 것을 피하기 위해, **이벤트 발행 로직을 `Events`와 같은 별도의 클래스에 위임**하는 방식을 사용하기도 한다.

### 3.3. 이벤트 처리: `@EventListener`

- 발행된 이벤트를 받아서 처리하는 핸들러는, 스프링이 제공하는 **`@EventListener` 애너테이션**을 사용하여 매우 간단하게 구현할 수 있다.
- 스프링은 `publishEvent()`로 특정 타입의 이벤트 객체가 발행되면, **해당 타입을 파라미터로 갖는 `@EventListener` 메서드를 자동으로 찾아 실행**해준다.

## 4. 동기 이벤트 처리 문제

- 이벤트를 사용하여 시스템 간의 강한 결합 문제는 해결했지만, **이벤트를 동기(Sync)로 처리할 경우** 아직 해결해야 할 문제가 남아있다.
- 동기 방식에서는 이벤트 핸들러가 외부 시스템과 연동할 때, **외부 시스템의 응답이 늦어지면 이벤트 발행 로직의 실행도 함께 늦어진다**.
- 이는 결국 **외부 서비스의 성능 저하가 현재 시스템의 성능 저하로 직접 연결**되는 결과를 낳는다.
- 이벤트 핸들러에서 예외가 발생했을 때, **이벤트 발행까지 포함된 현재 트랜잭션을 함께 롤백해야 할지** 결정하기가 모호하다.
- 예를 들어, '주문 완료'는 성공적으로 처리되었는데, '주문 완료 이벤트'를 받아 처리하던 '메일 발송' 기능이 실패했다고 해서, 이미 완료된 주문까지 롤백하는 것은 올바르지 않다.
- 이러한 성능과 트랜잭션 범위 문제를 해소하는 방법은 **이벤트를 비동기(Async)로 처리**하거나, **이벤트와 트랜잭션을 별도로 연계**하는 것이다.

## 5. 비동기 이벤트 처리

- 요구사항 중 'A를 하면 이어서 B를 하라'는 내용은, 실제로는 'A를 하면 **일정 시간 안에만 B를 처리하면 된다**'는 의미인 경우가 많다.
- 예를 들어, 회원 가입 시 인증 메일은 즉시 발송될 필요가 없으며, 실패 시 재시도를 해도 괜찮다. 이러한 요구사항은 **이벤트를 비동기(Async)로 처리**하는 방식으로 구현하기에 적합하다.
- 즉, **A라는 이벤트가 발생하면, B를 처리하는 핸들러를 별도의 스레드(Thread)로 실행**하여, 이벤트 발생 코드와 처리 코드를 시간적으로 분리하는 것이다.
- 이벤트를 비동기로 구현하는 대표적인 방법은 다음과 같다.
  - **로컬 핸들러를 비동기로 실행**
  - **메시지 큐(Message Queue) 사용**
  - **이벤트 저장소와 이벤트 포워더(Forwarder) 사용**
  - **이벤트 저장소와 이벤트 제공 API 사용**

### 5.1. 로컬 핸들러 비동기 실행

- 로컬 핸들러를 비동기로 실행하는 가장 간단한 방법은 **이벤트 핸들러를 별도의 스레드에서 실행**하는 것이다.
- 스프링 프레임워크가 제공하는 **`@Async` 애너테이션**을 사용하면 이 과정을 매우 손쉽게 구현할 수 있다.
- 필요한 설정은 아래 두 가지이다.
  - 설정 클래스에 **`@EnableAsync`** 애너테이션을 추가하여 비동기 기능을 활성화한다.
  - 비동기로 실행하고 싶은 **이벤트 핸들러 메서드에 `@Async` 애너테이션**을 붙인다.

### 5.2. 메시징 시스템을 이용한 비동기 구현

- 비동기 이벤트를 처리하는 또 다른 방법은 **카프카(Kafka)나 래빗MQ(RabbitMQ)와 같은 메시징 시스템을 사용**하는 것이다.
- 이벤트가 발생하면 **이벤트 디스패처는 이벤트를 메시지 큐에 발행(Publish)**한다. 이후 별도의 **메시지 리스너가 큐에서 이벤트를 구독(Subscribe)하여 이벤트 핸들러를 통해 처리**한다. 발행과 구독은 각각 다른 스레드나 프로세스에서 동작한다.
- 이벤트를 발생시키는 도메인 로직과, 해당 이벤트를 메시지 큐에 저장하는 과정을 **하나의 트랜잭션으로 묶어야 할 때**가 있다. 이를 위해서는 DB와 메시지 큐를 모두 묶는 **글로벌 트랜잭션(Global Transaction)**이 필요하다.
- 글로벌 트랜잭션은 **이벤트를 안전하게 전달하는 것을 보장**하지만, **전체 성능을 저하시키는 단점**이 있다. 또한, 이를 지원하지 않는 메시징 시스템도 있다.
- 메시지 큐는 주로 **서로 다른 프로세스(다른 서버) 간에 이벤트를 주고받을 때** 효과적이다. 동일한 JVM 내에서의 비동기 처리를 위해 메시지 큐를 사용하는 것은 시스템을 과도하게 복잡하게 만들 수 있다.
- **래빗MQ**는 글로벌 트랜잭션을 지원하여 안정적인 전달을 보장하며, **카프카**는 이를 지원하지 않지만 더 높은 처리량을 제공하는 등 메시징 시스템마다 특징이 다르므로 상황에 맞게 선택해야 한다.

### 5.3. 이벤트 저장소를 이용한 비동기 처리

- 이벤트를 일단 DB와 같은 **물리적인 저장소에 보관**한 뒤, 별도의 프로그램을 이용해 비동기적으로 처리하는 방법도 있다.

#### 이벤트 포워더(Forwarder) 방식

- 이벤트가 발생하면, 먼저 이벤트를 **이벤트 저장소에 저장**한다. 이후 **포워더(Forwarder)** 라는 별도의 프로그램이 주기적으로 저장소를 확인하여, 처리되지 않은 이벤트를 가져와 핸들러에 전달하는 **푸시(Push) 방식**이다.
- 이 방식의 가장 큰 장점은 **로컬 트랜잭션**으로 도메인의 상태 변경과 이벤트 저장을 함께 처리할 수 있다는 점이다. 즉, **글로벌 트랜잭션 없이도 데이터의 정합성**을 맞출 수 있다.
- 또한, 이벤트 처리에 실패하더라도 저장소에 이벤트가 남아있으므로 **안정적인 재시도가 가능**하다.

#### 이벤트 제공 API 방식

- 두 번째 방법은, **이벤트 목록을 제공하는 API**를 만들고 외부의 핸들러가 이 API를 통해 직접 이벤트를 가져가도록 하는 **풀(Pull) 방식**이다.
- 포워더 방식과의 가장 큰 차이점은 **어디까지 이벤트를 처리했는지 추적하는 주체**이다. 포워더 방식에서는 **포워더**가 그 책임을 지지만, API 방식에서는 이벤트를 가져가는 **외부 핸들러**가 직접 그 상태를 기억하고 관리해야 한다.

### 5.4. 이벤트 저장소 구현

- 포워더 방식과 API 방식 모두 **이벤트 저장소**를 사용한다.
- 이벤트는 과거에 일어난 사건이므로, 데이터가 변경되지 않는 **불변(Immutable)** 의 특징을 가진다. 따라서 이벤트 저장소는 **새로운 이벤트를 추가하는 기능**과 **이벤트를 조회하는 기능**만 있으면 된다.

### 5.5. 이벤트 저장을 위한 이벤트 핸들러

- 애플리케이션에서 발생한 이벤트를 **이벤트 저장소에 기록(저장)하는 역할을 담당하는 이벤트 핸들러**가 필요하다.

### 5.6. REST API 구현 방식

- **API 방식**에서는, 외부 클라이언트가 이벤트를 가져갈 수 있도록 **`offset`과 `limit` 파라미터를 이용해 이벤트 목록을 조회**하는 REST API를 구현한다.
- API를 사용하는 클라이언트는 주기적으로 아래의 과정을 실행한다.
  1.  가장 마지막에 처리한 데이터의 **`offset`을 내부에 기록**한다. (기록이 없으면 0부터 시작)
  2.  기록된 `offset`을 기준으로 API를 호출하여 새로운 이벤트 목록을 가져온다.
  3.  가져온 이벤트를 처리한 뒤, `offset + 처리한 데이터 개수`를 새로운 `offset`으로 다시 기록한다.
- 이 방식은 클라이언트가 자신의 처리 상태를 직접 관리하므로, **이벤트 처리에 실패하거나 API 서버에 장애가 발생해도 언제든지 원하는 시점부터 재처리가 가능**하다.

### 5.7. 포워더 구현 방식

- **포워더 방식**의 클라이언트(포워더)는 API 방식의 클라이언트와 유사하게 동작한다.
- 포워더 역시 **마지막으로 처리한 이벤트의 `offset`을 기억**해두었다가, 다음 조회 시 그 지점부터 이벤트를 가져온다.
- 포워더는 주기적으로 실행되어야 하므로, 스프링의 **`@Scheduled` 애너테이션**이나 별도의 스케줄링 프레임워크를 이용해 구현한다.
