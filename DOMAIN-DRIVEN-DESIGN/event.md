# 이벤트

## 1. 시스템 간 강결합 문제

- 쇼핑몰에서 주문을 취소하면 외부 결제 시스템과 연동하여 환불을 처리해야 한다. 이처럼 **하나의 도메인 기능이 외부 시스템의 기능을 실행해야 할 때**, 두 시스템을 **직접 연동(강결합)** 하면 여러 문제가 발생할 수 있다.
- 이러한 **강결합(High Coupling) 문제**를 해결하는 좋은 방법이 바로 **이벤트(Event)**, 특히 **비동기 이벤트를 사용**하는 것이다. 강결합 시 발생하는 주요 문제는 다음과 같다.

### 1.1. 트랜잭션 처리의 모호함

- 외부 시스템 연동 시 예외(Exception)가 발생하면, **현재 트랜잭션을 롤백해야 할지 커밋해야 할지** 결정하기가 모호하다.
- 예를 들어, 주문 취소는 성공했지만 외부 시스템의 환불 기능이 실패했을 때, 주문 취소까지 함께 롤백하는 것이 항상 올바른 정책은 아니다.

### 1.2. 성능 저하

- 직접 연동 방식은 **외부 시스템의 성능에 직접적인 영향을 받는다**.
- 만약 외부 환불 시스템의 응답이 늦어지면, 주문 취소 기능의 대기 시간도 그만큼 길어져 사용자 경험을 저하시킨다.

### 1.3. 데이터 변경 로직의 복잡성 증가

- 주문 취소 기능에 '환불' 외에 '취소 통지'와 같은 새로운 기능이 추가되면, **하나의 기능 안에 여러 로직이 섞이게 된다**.
- 이는 **코드의 복잡도를 높이고, 트랜잭션 관리 또한 더욱 어렵게** 만든다.

## 2. 이벤트 개요

- **이벤트(Event)** 란, **과거에 벌어진 어떤 것**을 의미한다. 도메인 모델에서는 **상태가 변경되었다는 사실 자체**를 이벤트로 표현할 수 있다.
- 요구사항 중 '~할 때', '~가 발생하면'과 같이 도메인의 상태 변경과 관련된 내용은 이벤트를 이용해 구현하기에 적합하다.

### 2.1. 이벤트 관련 구성요소

- 도메인 모델에 이벤트를 도입하려면, **이벤트, 이벤트 생성 주체, 이벤트 핸들러, 이벤트 디스패처**를 구현해야 한다.
- **이벤트 생성 주체(Event Generator)**: 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 상태가 변경되면 관련 이벤트를 발생시킨다.
- **이벤트 핸들러(Event Handler/Subscriber)**: 발생한 이벤트에 반응하여, 필요한 기능을 실행하는 구독자이다.
- **이벤트 디스패처(Event Dispatcher/Publisher)**: 이벤트 생성 주체와 핸들러를 연결해주는 중간 다리이다. 이벤트를 전달받아, 해당 이벤트를 처리할 수 있는 핸들러에게 전파한다.
- 디스패처의 구현 방식에 따라, 이벤트 처리 과정이 **동기(Sync) 또는 비동기(Async)로 실행**될 수 있다.

### 2.2. 이벤트의 구성

- 이벤트는 **자신이 표현하는 상태 변경과 관련된 정보**를 담는다. 보통 다음과 같은 데이터를 포함한다.
  - **이벤트 종류**: 보통 클래스 이름으로 표현한다.
  - **이벤트 발생 시간**
  - **관련 데이터**: 주문 번호, 신규 배송지 정보 등
- 이벤트 핸들러가 추가적인 조회 없이 작업을 수행할 수 있도록, **필요한 데이터를 충분히 담는 것**이 좋다.
- 하지만 이벤트 자체와 **직접적인 관련이 없는 데이터를 과도하게 포함할 필요는 없다**.

### 2.3. 이벤트 용도

- 이벤트는 크게 두 가지 용도로 사용된다.
  - **트리거(Trigger)**: 도메인의 한 영역에서 상태가 변경되었을 때, **다른 영역의 후처리를 실행**하기 위한 용도이다. 예를 들어, '주문 취소' 이벤트는 '환불 처리' 기능의 트리거가 될 수 있다.
  - **시스템 간 데이터 동기화**: 한 바운디드 컨텍스트에서 발생한 변경 사항을 **다른 바운디드 컨텍스트에 전파**하여, 두 시스템 간의 데이터 일관성을 맞추는 용도이다.

### 2.4. 이벤트 장점

- 이벤트를 사용하면, **서로 다른 도메인 로직이 섞이는 것을 방지하여 시스템의 결합도를 낮출 수 있다**.
- 예를 들어, 주문 취소 시 환불 로직을 직접 호출하는 대신 '주문 취소 이벤트'를 발생시키면, 주문 도메인은 결제 도메인에 대한 의존을 제거할 수 있다. 환불 책임은 이벤트를 구독하는 별도의 핸들러로 이동한다.
- 또한, **기능 확장이 매우 용이**해진다. '주문 취소 시 이메일 발송' 기능이 필요하다면, 기존 코드를 수정할 필요 없이 **새로운 이벤트 핸들러를 추가**하기만 하면 된다.

## 3. 이벤트, 핸들러, 디스패처 구현

- 스프링 프레임워크가 제공하는 기능을 이용하면, 이벤트 관련 코드를 손쉽게 구현할 수 있다. 구현에 필요한 주요 구성요소는 다음과 같다.
  - **이벤트 클래스**: 도메인에서 발생한 이벤트를 표현하는 객체이다.
  - **ApplicationEventPublisher**: 스프링이 제공하는 이벤트 발행(Publish) 도구이다.
  - **이벤트 핸들러**: `@EventListener`를 이용해 특정 이벤트를 구독하고 처리하는 컴포넌트이다.

### 3.1. 이벤트 클래스

- 이벤트를 표현하는 클래스를 만들 때, 반드시 상속받아야 하는 상위 타입은 없다. **원하는 어떤 클래스든 이벤트로 사용**할 수 있다.
- 다만, 이벤트는 '과거에 벌어진 일'을 의미하므로, **클래스 이름을 `OrderCanceledEvent`와 같이 과거 시제**로 짓는 것이 좋다.
- 이벤트 클래스는 핸들러가 로직을 처리하는 데 **필요한 최소한의 데이터를 포함**해야 한다.
- 만약 모든 이벤트가 공통으로 가져야 할 프로퍼티(예: 발생 시간)가 있다면, **관련 상위 추상 클래스를 만들어 상속**받게 할 수도 있다.

### 3.2. 이벤트 발행: `ApplicationEventPublisher`

- 이벤트 발행을 위해서는 스프링이 제공하는 **`ApplicationEventPublisher` 인터페이스를 사용**한다. 스프링 컨테이너 자체가 이 인터페이스의 구현체이므로, 필요한 곳에 주입받아 사용할 수 있다.
- `ApplicationEventPublisher`의 **`publishEvent(eventObject)` 메서드를 호출**하여 이벤트를 발행한다.
- 도메인 객체가 `ApplicationEventPublisher`에 직접 의존하는 것을 피하기 위해, **이벤트 발행 로직을 `Events`와 같은 별도의 클래스에 위임**하는 방식을 사용하기도 한다.

### 3.3. 이벤트 처리: `@EventListener`

- 발행된 이벤트를 받아서 처리하는 핸들러는, 스프링이 제공하는 **`@EventListener` 애너테이션**을 사용하여 매우 간단하게 구현할 수 있다.
- 스프링은 `publishEvent()`로 특정 타입의 이벤트 객체가 발행되면, **해당 타입을 파라미터로 갖는 `@EventListener` 메서드를 자동으로 찾아 실행**해준다.
