# 도메인 모델과 바운디드 컨텍스트

## 1. 도메인 모델과 경계

- 처음 도메인 모델을 만들 때 빠지기 쉬운 함정은, **도메인 전체를 완벽하게 표현하는 단일 모델을 만들려고 시도**하는 것이다.
- 하나의 도메인은 여러 하위 도메인으로 나뉘는데, 한 개의 모델로 모든 하위 도메인을 표현하려 하면 오히려 **모든 곳에 맞지 않는 애매한 모델**이 만들어지기 쉽다.
- 이는 하위 도메인마다 사용하는 용어와 개념이 다르기 때문이다. 예를 들어, 시스템을 사용하는 동일한 사람이라도 회원 컨텍스트에서는 '회원'으로, 주문 컨텍스트에서는 '주문자'로 불릴 수 있다.
- 이처럼 같은 대상이라도 컨텍스트에 따라 용어나 의미가 달라지므로, **하나의 모델로 모든 하위 도메인을 표현하는 것은 올바르지 않으며 가능하지도 않다**.
- 올바른 도메인 모델을 개발하려면, **각 하위 도메인마다 별도의 모델**을 만들어야 한다. 각 모델은 **명시적으로 구분되는 경계**를 가져서 서로 섞이지 않도록 해야 한다.
- 만약 여러 하위 도메인의 모델이 서로 섞이면, 모델의 의미가 모호해지고 서로 얽히게 되어 **요구사항 변경에 유연하게 대처하기 어려워진다**.
- 모델은 **특정한 컨텍스트(문맥) 하에서 완전한 의미**를 가진다. DDD에서는 이렇게 명확하게 구분되는 경계를 가진 컨텍스트를 **바운디드 컨텍스트(Bounded Context)** 라고 부른다.

## 2. 바운디드 컨텍스트

### 2.1. 바운디드 컨텍스트의 정의

- **바운디드 컨텍스트(Bounded Context)** 는 모델의 **경계를 결정**하며, 하나의 바운디드 컨텍스트는 논리적으로 하나의 모델을 가진다.
- 바운디드 컨텍스트를 구분하는 가장 중요한 기준은 **해당 컨텍스트에서 사용하는 용어**이다. 용어가 다르다는 것은 별개의 컨텍스트일 가능성이 높다는 것을 의미한다.
- 또한, 바운디드 컨텍스트는 실제로 **사용자에게 기능을 제공하는 물리적인 시스템 단위**이기도 하다.

### 2.2. 하위 도메인 및 조직과의 관계

- 이상적으로는 하나의 하위 도메인이 하나의 바운디드 컨텍스트와 1:1 관계를 갖는 것이지만, **현실에서는 항상 그렇지 않다**.
- 바운디드 컨텍스트는 **기업의 팀 조직 구조에 따라 결정**되기도 한다. 예를 들어, 규모가 작은 기업에서는 한 팀이 여러 하위 도메인을 하나의 바운디드 컨텍스트 안에서 구현할 수도 있다.

### 2.3. 모델이 섞이는 것에 대한 주의사항

- 하나의 바운디드 컨텍스트에서 여러 하위 도메인을 개발할 때 가장 주의할 점은, **각 하위 도메인의 모델이 서로 섞이지 않도록 하는 것**이다.
- 하나의 프로젝트에 코드가 위치하면, 모든 하위 도메인을 아우르는 단일 모델을 만들고 싶은 유혹에 빠지기 쉽지만, 이는 **각 하위 도메인의 특성을 제대로 반영하지 못하게 만들어** 결국 시스템의 경쟁력을 떨어뜨린다.
- 따라서 하나의 바운디드 컨텍스트 안에서도 **각 하위 도메인별로 패키지를 명확히 구분**하여, 모델이 섞이지 않도록 구현해야 한다.
- 결론적으로 바운디드 컨텍스트는 모델을 구분하는 명확한 경계가 된다. 따라서 같은 '사용자'라 하더라도, **주문 컨텍스트의 '주문자' 모델과 회원 컨텍스트의 '회원' 모델은 서로 다르게** 만들어져야 한다.

## 3. 바운디드 컨텍스트 구현

### 3.1. 구현 범위

- 바운디드 컨텍스트는 도메인 모델만으로 구성되는 것이 아니다. 도메인 기능을 사용자에게 제공하는 데 필요한 **표현, 응용, 인프라스트럭처 영역을 모두 포함**한다.
- DB 테이블 스키마 역시 도메인 모델의 일부이므로 바운디드 컨텍스트에 포함된다.

### 3.2. 다양한 구현 패턴 적용

- **모든 바운디드 컨텍스트를 반드시 도메인 주도 개발(DDD) 방식으로 구현할 필요는 없다**.
- 도메인 로직이 복잡하지 않은 바운디드 컨텍스트(예: 상품 리뷰)는, **서비스-DAO 구조를 사용하는 단순한 CRUD 방식으로 구현**해도 충분하다.
- 한 바운디드 컨텍스트 내에서 **두 가지 방식을 혼합**할 수도 있다. 대표적으로 **CQRS 패턴**을 적용하면, 상태를 변경하는 명령(Command) 기능은 DDD 방식으로, 데이터를 조회하는(Query) 기능은 서비스-DAO를 이용한 방식으로 구현할 수 있다.

### 3.3. 유연한 기술 선택

- 각 바운디드 컨텍스트의 기술적 요구사항이 다르므로, **컨텍스트마다 서로 다른 구현 기술(언어, 프레임워크, DB 등)을 선택**하여 사용할 수 있다.
- 또한, 모든 바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가질 필요는 없다. 외부 시스템과 연동만 하는 백엔드 서비스 형태의 컨텍스트도 존재할 수 있다.

## 4. 바운디드 컨텍스트 간 통합

- 하나의 도메인에 여러 바운디드 컨텍스트가 생기면, 자연스럽게 **컨텍스트 간의 통합이 필요**해진다.
- 예를 들어, 기존 '카탈로그 컨텍스트'에 새로운 '추천 컨텍스트'가 추가되면, 추천 컨텍스트는 카탈로그의 상품 정보를 필요로 하므로 두 컨텍스트는 서로 연동해야 한다.

### 4.1. 직접 통합: REST API 호출

- **REST API**를 호출하는 것은 두 바운디드 컨텍스트를 **직접 통합**하는 대표적인 방법이다.
- 이때 한 컨텍스트의 **도메인 서비스**가 다른 컨텍스트의 API를 호출하는 역할을 담당하며, 이 도메인 서비스의 구현체는 **인프라스트럭처 영역**에 위치한다.

### 4.2. 간접 통합: 메시지 큐

- 직접적인 API 호출 대신, **메시지 큐(Message Queue)** 를 사용하여 **간접적으로 통합**하는 방법도 있다.
- 이 방식은 한쪽 컨텍스트가 메시지를 발행(Publish)하면, 다른 쪽 컨텍스트가 해당 메시지를 구독(Subscribe)하여 처리하는 **발행/구독(Pub/Sub) 모델**을 따른다.
- 두 컨텍스트는 메시지 큐에 담길 **데이터의 구조에 대해서만 협의**하면 되므로, 서로에 대한 **직접적인 의존성을 낮출 수 있다**.

## 5. 바운디드 컨텍스트 간 관계

- 바운디드 컨텍스트들은 서로 연결되어 다양한 관계를 맺는다. 그중 가장 흔한 관계는 한쪽에서 API를 제공하고 다른 쪽에서 그 API를 호출하는 관계이다.

### 5.1. 상류-하류 관계 (Upstream-Downstream)

- 서비스를 제공하는 쪽을 **상류(Upstream) 컴포넌트**, 서비스를 사용하는 쪽을 **하류(Downstream) 컴포넌트**라고 한다. 이는 서비스 공급자와 고객의 관계와 같다.
- 이 관계에서는 두 팀의 **상호 협력이 필수적**이다. 상류 팀이 일방적으로 API를 변경하면 하류 팀의 개발이 마비될 수 있고, 반대로 하류 팀의 승인 절차가 너무 복잡하면 상류 팀의 발전이 저해될 수 있다.

### 5.2. 공개 호스트 서비스와 안티코럽션 계층

- 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들어 **서비스 형태로 일관성 있게 제공**하는데, 이를 **공개 호스트 서비스(Open Host Service, OHS)** 라고 한다. 대표적으로 검색 서비스가 있다.
- 하류 컨텍스트는 상류 컨텍스트의 모델이 자신의 도메인 모델을 침범하지 않도록 **보호 계층을 만들어야** 한다. 이 보호 계층을 **안티-코럽션 계층(Anti-Corruption Layer, ACL)** 이라고 부른다.
- ACL은 두 컨텍스트 간의 **모델 변환을 처리**하여, 외부 모델의 변경에 내 도메인 모델이 영향을 받지 않도록 보호하는 역할을 한다.

### 5.3. 공유 커널 (Shared Kernel)

- 두 개 이상의 바운디드 컨텍스트가 **도메인 모델의 일부를 공유**하는 경우, 이 공유하는 모델을 **공유 커널(Shared Kernel)** 이라고 부른다.
- 장점은 **모델 중복 개발을 방지**해준다는 것이고, 단점은 공유 커널을 변경할 때마다 **관련된 모든 팀이 긴밀하게 협의**해야 한다는 점이다. 팀 간의 관계가 원활하지 않다면 단점이 더 커질 수 있다.

### 5.4. 각자 방식 (Separate Ways)

- 두 바운디드 컨텍스트가 **서로를 통합하지 않고 독립적으로 발전**하는 방식을 **각자 방식(Separate Ways)** 이라고 부른다.
- 이 경우 두 컨텍스트 간의 통합은 **수동으로 이루어진다**. 시스템의 규모가 작을 때는 이 방식이 유효할 수 있지만, 규모가 커지면 수동 통합의 한계에 부딪히므로 자동화된 통합 방식을 고려해야 한다.

## 6. 컨텍스트 맵

- **컨텍스트 맵(Context Map)** 은 여러 바운디드 컨텍스트 간의 관계를 시각적으로 표현한 **전체 비즈니스 지도**이다. 이는 개별 개발에 매몰되지 않고 시스템 전체를 조망하도록 돕는다.
- 컨텍스트 맵에는 각 컨텍스트의 관계뿐만 아니라 주요 애그리거트, 팀 조직 구조 등을 함께 표시하면 더 유용하다.
- 컨텍스트 맵을 통해 **잘못된 경계를 바로잡고**, 비즈니스의 **핵심 도메인에 역량을 집중**하는 등 전략적인 판단을 내릴 수 있다.
- 맵을 그리는 데 **정해진 규칙은 없으며**, 프로젝트 상황에 맞게 유연하게 작성하면 된다.
