# 응용 서비스와 표현 영역

## 1. 표현 영역과 응용 영역

- 도메인 계층이 제 기능을 하려면, **사용자와 도메인을 연결하는 매개체**가 필요하다. 이 역할을 **표현(Presentation) 영역**과 **응용(Application) 영역**이 담당한다.

### 1.1. 표현 영역의 역할

- 표현 영역은 **사용자의 요청을 해석**하는 책임을 진다. 예를 들어, 웹 브라우저로부터 HTTP 요청을 받아 URL, 파라미터, 쿠키 등을 분석하여 사용자가 원하는 기능이 무엇인지 판별한다.
- 또한, 사용자의 요청 데이터를 **응용 서비스가 처리할 수 있는 형식으로 변환**하여, 알맞은 응용 서비스의 메서드를 호출한다.
- 마지막으로, 응용 서비스로부터 받은 **실행 결과를 사용자에게 적절한 형식(예: HTML, JSON)으로 변환하여 응답**한다.

### 1.2. 응용 영역의 역할

- 사용자가 원하는 **실질적인 기능을 제공하는 주체**는 응용 영역에 위치한 **응용 서비스**이다.
- 응용 서비스는 기능을 실행하는 데 필요한 데이터들을 **메서드의 인자(파라미터)로 전달받고, 실행 결과를 반환**하는 형태로 구현된다.

## 2. 응용 서비스의 역할

- 응용 서비스의 주요 역할은 **사용자가 요청한 기능을 실행**하는 것이다. 이를 위해 리포지터리에서 도메인 객체를 가져와 사용하거나 새로 생성하여 **도메인 객체 간의 흐름을 제어**한다.
- 이런 관점에서 응용 서비스는, 표현 영역과 도메인 영역을 연결하는 **창구(Facade)** 역할을 수행한다고 볼 수 있다.
- 응용 서비스는 도메인 로직을 직접 수행하지 않고 흐름 제어만 담당하므로, **코드가 복잡해서는 안 된다**. 만약 응용 서비스가 복잡하다면, 도메인 로직의 일부를 직접 구현하고 있을 가능성이 높으며 이는 코드 품질을 저하시킨다.
- 또한, 응용 서비스의 중요한 책임 중 하나는 **트랜잭션 관리**이다. 데이터의 일관성이 깨지지 않도록, 도메인의 상태 변경은 반드시 응용 서비스가 관리하는 트랜잭션 안에서 실행되어야 한다.

### 2.1. 도메인 로직 넣지 않기

- 가장 중요한 원칙은 **도메인 로직을 응용 서비스에 구현하지 않는 것**이다. 도메인 로직은 반드시 도메인 영역에 위치해야 한다.
- 만약 도메인 로직을 응용 서비스와 도메인 영역에 분산시키면, **코드의 응집성이 떨어진다**. 관련된 데이터와 로직이 서로 다른 곳에 흩어져 있어 전체 로직을 파악하기 어려워지기 때문이다.
- 또한, **여러 응용 서비스에서 동일한 도메인 로직을 중복으로 구현**할 가능성이 커진다.
- 결과적으로 이러한 문제들은 **코드를 변경하기 어렵게 만들어**, 소프트웨어의 핵심 경쟁력인 **변경 용이성을 떨어뜨리고 전체적인 가치를 저하**시킨다.

## 3. 응용 서비스 구현

### 3.1. 응용 서비스의 크기

- 응용 서비스를 구현할 때 생각할 거리 중 하나는 **클래스의 크기**이다. 응용 서비스의 크기를 설계하는 방식은 크게 아래 두 가지로 나눌 수 있다.
  - 한 도메인의 모든 기능을 **하나의 클래스**에 구현하기
  - 구분되는 기능별로 **여러 클래스**에 나누어 구현하기

#### 한 클래스에 모든 기능 구현

- **장점**: 한 도메인의 모든 기능이 한 클래스에 모여있어, **공통 로직의 중복을 쉽게 제거**할 수 있다.
- **단점**: 클래스의 크기가 비대해지고, 서로 관련 없는 기능들이 섞여 **코드의 응집도가 낮아진다**. 이는 결국 코드를 이해하고 유지보수하기 어렵게 만들며, 새로운 기능을 무분별하게 추가하게 만들어 코드 품질을 지속적으로 저하시킨다.

#### 기능별로 클래스 분리

- **장점**: 클래스당 1~3개의 기능만 구현하므로 **책임이 명확해지고 코드의 응집도가 높아진다**. 이는 코드 품질을 일정 수준으로 유지하고, 다른 기능의 변경에 영향을 받지 않는 유연한 구조를 만드는 데 도움이 된다.
- **단점**: 여러 클래스에 걸쳐 **동일한 로직이 중복될 가능성**이 있다. 이 경우, 공통 로직을 별도의 클래스로 추출하여 중복을 제거해야 한다.

### 3.2. 응용 서비스의 인터페이스와 클래스

- 응용 서비스를 구현할 때 **인터페이스가 필요한지에 대한 여부**는 종종 논쟁거리가 된다.
- 인터페이스는 보통 **런타임에 구현 객체를 교체**하거나 **하나의 인터페이스에 대해 여러 구현 클래스**가 존재할 때 유용하지만, 응용 서비스는 이러한 경우가 거의 드물다.
- 따라서 명확한 필요성이 생기기 전까지는, 인터페이스를 따로 만드는 것이 **소스 파일의 개수만 늘리고 구조를 더 복잡하게** 만들 수 있다.
- 다만, **표현 영역부터 개발을 시작**하거나, 표현 영역 단위 테스트 시 **응용 서비스를 가짜(mock) 객체로 대체**해야 하는 특정 상황에서는 인터페이스가 유용할 수 있다.
- 하지만 **Mockito와 같은 최신 테스트 도구**는 클래스 자체를 가짜 객체로 만들 수 있는 강력한 기능을 제공한다. 이 때문에, 순수하게 테스트만을 위해 인터페이스를 작성해야 할 **필요성은 많이 약화**되었다.

### 3.3. 메서드 파라미터와 값 리턴

#### 파라미터 전달 방식

- 응용 서비스의 메서드는 사용자의 요청을 처리하는 데 필요한 값들을 파라미터로 전달받아야 한다.
- 각 값을 개별 파라미터로 받을 수도 있고, **요청 데이터를 위한 별도의 클래스(DTO)를 만들어** 전달할 수도 있다. 파라미터가 두 개 이상이면 **별도의 클래스를 사용하는 것이 더 명확하고 편리**하다.

#### 결과 값 리턴 방식

- 응용 서비스는 **실행 결과를 표현 영역에서 사용할 수 있도록 리턴**해야 한다. 새로 생성한 애그리거트의 **식별자**가 대표적인 리턴 값이다.
- 때로는 편의를 위해 **애그리거트 객체 자체를 리턴**할 수도 있다.
- 하지만 이 방식은, 표현 영역에서도 도메인 객체의 기능을 실행할 수 있게 만들어 **도메인 로직이 여러 곳에 분산**되게 한다. 이는 **코드의 응집도를 떨어뜨리는 원인**이 된다.
- 따라서 기능 실행 로직의 응집도를 높이려면, 애그리거트 자체를 리턴하기보다는 **표현 영역에서 필요한 데이터만 DTO에 담아 리턴**하는 것이 더 좋은 방법이다.

### 3.4. 표현 영역에 의존하지 않기

- 응용 서비스의 파라미터 타입을 결정할 때 가장 중요한 원칙은, **표현 영역과 관련된 타입을 사용해서는 안 된다**는 것이다.
- 만약 응용 서비스가 표현 영역에 의존하면, **응용 서비스만 단독으로 테스트하기가 어려워지고**, 표현 영역의 기술이 바뀔 때마다 **응용 서비스의 코드도 함께 변경**해야 하는 문제가 생긴다.
- 또한 `HttpSession`이나 쿠키와 같은 **표현 영역의 상태를 응용 서비스가 다루게 되면**, 표현 영역의 응집도가 깨지고 상태 변경을 추적하기 어려워진다.
- 이러한 문제를 방지하는 가장 쉬운 방법은, **응용 서비스의 파라미터와 리턴 타입으로 `HttpSession`, `HttpServletRequest` 등 표현 영역의 기술과 관련된 타입을 사용하지 않는 것**이다.

### 3.5. 트랜잭션 처리

- **트랜잭션을 관리하는 것**은 응용 서비스의 중요한 역할 중 하나이다.
- 스프링과 같은 프레임워크가 제공하는 트랜잭션 관리 기능을 적극적으로 사용하는 것이 좋다. 프레임워크가 제공하는 규칙을 따르면, 간단한 설정만으로 트랜잭션을 시작하고 커밋하며, 예외 발생 시 자동으로 롤백할 수 있다.
- 예를 들어, 스프링의 **`@Transactional`** 애너테이션이 적용된 메서드는 **`RuntimeException`이 발생하면 트랜잭션을 롤백**하고, 그렇지 않으면 커밋한다. 이 규칙에 맞춰 코드를 작성하면 트랜잭션 관리가 매우 간결해진다.

## 4. 표현 영역

- 표현 영역의 책임은 크게 다음과 같이 세 가지로 나눌 수 있다.
- **1. 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.**
  - 웹 서비스의 경우, 사용자의 요청에 따라 알맞은 화면을 제공하고, 사용자가 다음 행동(링크 클릭, 폼 전송 등)을 이어갈 수 있도록 UI 흐름을 제어한다.
- **2. 사용자의 요청을 알맞은 응용 서비스에 전달하고, 그 결과를 다시 사용자에게 제공한다.**
  - 이 과정에서, 사용자의 요청 데이터를 응용 서비스가 이해할 수 있는 형식으로 변환하고, 반대로 응용 서비스의 실행 결과를 사용자가 볼 수 있는 형식(HTML, JSON 등)으로 변환하는 역할을 담당한다.
- **3. 사용자의 세션을 관리한다.**
  - 웹 애플리케이션의 경우, 쿠키나 서버 세션 등을 이용해 사용자의 연결 상태를 유지하며, 이는 **권한 검사(Authentication & Authorization)** 와도 밀접하게 연결된다.

## 5. 값 검증

- 값 검증은 **표현 영역**과 **응용 서비스** 두 곳에서 모두 수행할 수 있다.
- 만약 응용 서비스에서만 검증을 수행하고, 첫 번째 오류에서 바로 예외(Exception)를 발생시키면 사용자는 **한 번에 모든 필드의 오류를 확인하지 못하는 나쁜 경험**을 하게 된다.
- 물론 응용 서비스에서 모든 오류를 모아 하나의 예외로 발생시키는 방법도 있지만, 이는 구현을 복잡하게 만든다.
- 따라서 더 나은 사용자 경험과 코드 구조를 위해, **표현 영역과 응용 서비스가 검증 책임을 나누어 수행**하는 것이 효율적이다. 일반적으로 다음과 같이 역할을 나눌 수 있다.
  - **표현 영역**: 필수 값, 값의 형식(이메일, 숫자), 범위 등 **값에 대한 기본적인 검증**을 담당한다.
  - **응용 서비스**: ID 중복 여부와 같이, **데이터의 존재 유무나 여러 데이터를 비교해야 하는 논리적인 검증**을 담당한다.
- 이처럼 두 계층에서 모두 검증을 수행하면, 시스템의 **데이터 정합성과 전체적인 완성도**를 높일 수 있다.

## 6. 권한 검사

- **권한 검사**란, 사용자가 특정 기능을 실행할 수 있는지 확인하는 과정이다.
- 시스템의 요구사항에 따라 권한의 복잡도는 다양하며, 권한 검사는 **표현, 응용, 도메인 등 여러 영역에서 수행**될 수 있다.

### 6.1. 표현 영역에서의 권한 검사

- 표현 영역에서는 주로 **인증(Authentication) 여부를 확인**하거나 **URL 기반의 접근 제어**를 수행한다.
- 웹 애플리케이션의 경우, **서블릿 필터(Servlet Filter)** 나 스프링 인터셉터 등을 이용해 처리하는 것이 일반적이다.

### 6.2. 응용 서비스에서의 권한 검사

- URL만으로 접근 제어를 할 수 없는, 더 세밀한 권한 검사는 **응용 서비스의 메서드 수준**에서 이루어져야 한다.
- 스프링 시큐리티와 같은 프레임워크는 **AOP를 활용하여 `@PreAuthorize`와 같은 애너테이션**만으로도 메서드 단위의 권한 검사를 손쉽게 구현할 수 있도록 지원한다.

### 6.3. 도메인 영역에서의 권한 검사

- **개별 도메인 객체 단위**로 권한 검사를 해야 하는 경우도 있다. 예를 들어, '게시글의 작성자만 수정할 수 있다'와 같은 규칙이 이에 해당한다.
- 이런 로직은 **응용 서비스에서 애그리거트를 로딩한 뒤, 해당 애그리거트가 직접 권한을 검사**하도록 구현할 수 있다.
- 또는, 스프링 시큐리티와 같은 보안 프레임워크를 확장하여, 이러한 **객체 수준의 권한 검사 로직을 프레임워크에 통합**하는 것도 가능하다.

## 7. 조회 전용 기능과 응용 서비스

- 단순히 데이터를 조회하는 기능의 경우, 응용 서비스가 하는 일이 **조회 전용 기능을 그대로 호출하는 것 외에 아무것도 없을 수 있다**.
- 추가적인 로직이 없고, 단일 쿼리만 실행되어 **트랜잭션도 필요 없는 상황**이 바로 이에 해당한다.
- 이러한 경우, **굳이 응용 서비스를 만들지 않고 표현 영역에서 조회 전용 기능(예: 조회 전용 리포지터리)을 직접 사용**해도 문제가 없다.
- 응용 서비스가 아무런 부가적인 역할을 하지 못한다면, **불필요한 클래스를 만들기보다는 과감히 생략하는 것**이 더 실용적인 설계일 수 있다.
