# 애그리거트 트랜잭션 관리

## 1. 애그리거트와 트랜잭션

- 만약 **두 명의 사용자가 동시에 같은 애그리거트를 수정**한다면, 데이터의 **일관성이 깨지는 문제**가 발생할 수 있다.
- 이는 각 사용자가 서로 다른 트랜잭션에서 동일한 애그리거트를 조회하여, 마지막에 커밋된 트랜잭션의 수정 사항이 이전에 커밋된 **수정 사항을 덮어쓰기** 때문이다.
- 이러한 동시성 문제를 해결하려면, 일반적인 DBMS 트랜잭션과 더불어 애그리거트를 위한 **추가적인 잠금(Lock) 메커니즘**이 필요하다.
- 주로 사용되는 잠금 방식에는 **선점 잠금(Pessimistic Lock: 비관적 잠금)** 과 **비선점 잠금(Optimistic Lock: 낙관적 잠금)** 두 가지가 있다.

## 2. 선점 잠금

- **선점 잠금(Pessimistic Lock)** 은 먼저 애그리거트를 구한 스레드가 트랜잭션을 마칠 때까지, 다른 스레드가 **해당 애그리거트를 수정하지 못하도록 막는** 방식이다.
- 예를 들어, 스레드 1이 특정 애그리거트에 선점 잠금을 걸면, 스레드 2는 스레드 1이 트랜잭션을 커밋하여 **잠금을 해제할 때까지 대기(blocking) 상태**가 된다.
- 스레드 1의 트랜잭션이 끝나고 잠금이 해제된 뒤에야, 스레드 2는 비로소 해당 애그리거트에 접근할 수 있다. 이를 통해 **데이터 충돌 문제를 원천적으로 방지**한다.
- 선점 잠금은 보통 DBMS가 제공하는 **행 단위 잠금(row-level lock)** 기능을 이용해 구현되며, 대부분의 DBMS는 `SELECT ... FOR UPDATE`와 같은 구문을 통해 이를 지원한다.
- JPA에서는 `EntityManager.find()` 메서드를 호출할 때, `LockModeType.PESSIMISTIC_WRITE`를 인자로 전달하여 선점 잠금을 사용할 수 있다.
- 스프링 데이터 JPA에서는 리포지터리의 쿼리 메서드에 **`@Lock` 애너테이션**을 추가하여 더 간편하게 잠금 모드를 지정할 수 있다.

### 2.1. 선점 잠금과 교착 상태

- 선점 잠금을 사용할 때는, 여러 트랜잭션의 **잠금 순서가 꼬이면서 발생하는 교착 상태(Deadlock)**가 일어나지 않도록 주의해야 한다.
- 예를 들어, 아래와 같은 순서로 잠금을 시도하면 두 스레드 모두 영원히 대기하며 교착 상태에 빠지게 된다.
  1.  스레드 1: A 애그리거트에 대한 선점 잠금 구함
  2.  스레드 2: B 애그리거트에 대한 선점 잠금 구함
  3.  스레드 1: B 애그리거트에 대한 선점 잠금 시도 (스레드 2가 해제할 때까지 대기)
  4.  스레드 2: A 애그리거트에 대한 선점 잠금 시도 (스레드 1이 해제할 때까지 대기)
- 교착 상태는 **사용자 수가 많을수록 발생 가능성이 높아지며**, 한번 발생하면 시스템 전체의 성능에 심각한 영향을 줄 수 있다.
- 이런 문제를 방지하는 한 가지 방법은, 잠금을 구할 때 **최대 대기 시간(Timeout)을 지정**하는 것이다. 지정한 시간 내에 잠금을 얻지 못하면, 무한정 기다리는 대신 예외(Exception)를 발생시켜 교착 상태를 해소한다.
- JPA에서는 **쿼리 힌트(hint)** 를 사용하여 잠금 대기 시간을 `javax.persistence.lock.timeout` 속성으로 지정할 수 있다.

```java
Map<String, Object> hints = new HashMap<>();
// 잠금 대기 시간을 2000ms (2초)로 지정한다.
hints.put("javax.persistence.lock.timeout", 2000);

Order order = entityManager.find(
    Order.class,
    orderNo,
    LockModeType.PESSIMISTIC_WRITE,
    hints
);
```

- 스프링 데이터 JPA에서는 **`@QueryHints` 애너테이션**을 사용하여 쿼리 힌트를 더 간편하게 지정할 수 있다.
- 다만, 이 기능은 **사용하는 DBMS가 잠금 대기 시간 설정을 지원해야만 동작**한다.
