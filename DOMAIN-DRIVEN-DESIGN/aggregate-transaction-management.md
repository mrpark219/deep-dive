# 애그리거트 트랜잭션 관리

## 1. 애그리거트와 트랜잭션

- 만약 **두 명의 사용자가 동시에 같은 애그리거트를 수정**한다면, 데이터의 **일관성이 깨지는 문제**가 발생할 수 있다.
- 이는 각 사용자가 서로 다른 트랜잭션에서 동일한 애그리거트를 조회하여, 마지막에 커밋된 트랜잭션의 수정 사항이 이전에 커밋된 **수정 사항을 덮어쓰기** 때문이다.
- 이러한 동시성 문제를 해결하려면, 일반적인 DBMS 트랜잭션과 더불어 애그리거트를 위한 **추가적인 잠금(Lock) 메커니즘**이 필요하다.
- 주로 사용되는 잠금 방식에는 **선점 잠금(Pessimistic Lock: 비관적 잠금)** 과 **비선점 잠금(Optimistic Lock: 낙관적 잠금)** 두 가지가 있다.

## 2. 선점 잠금

- **선점 잠금(Pessimistic Lock)** 은 먼저 애그리거트를 구한 스레드가 트랜잭션을 마칠 때까지, 다른 스레드가 **해당 애그리거트를 수정하지 못하도록 막는** 방식이다.
- 예를 들어, 스레드 1이 특정 애그리거트에 선점 잠금을 걸면, 스레드 2는 스레드 1이 트랜잭션을 커밋하여 **잠금을 해제할 때까지 대기(blocking) 상태**가 된다.
- 스레드 1의 트랜잭션이 끝나고 잠금이 해제된 뒤에야, 스레드 2는 비로소 해당 애그리거트에 접근할 수 있다. 이를 통해 **데이터 충돌 문제를 원천적으로 방지**한다.
- 선점 잠금은 보통 DBMS가 제공하는 **행 단위 잠금(row-level lock)** 기능을 이용해 구현되며, 대부분의 DBMS는 `SELECT ... FOR UPDATE`와 같은 구문을 통해 이를 지원한다.
- JPA에서는 `EntityManager.find()` 메서드를 호출할 때, `LockModeType.PESSIMISTIC_WRITE`를 인자로 전달하여 선점 잠금을 사용할 수 있다.
- 스프링 데이터 JPA에서는 리포지터리의 쿼리 메서드에 **`@Lock` 애너테이션**을 추가하여 더 간편하게 잠금 모드를 지정할 수 있다.

### 2.1. 선점 잠금과 교착 상태

- 선점 잠금을 사용할 때는, 여러 트랜잭션의 **잠금 순서가 꼬이면서 발생하는 교착 상태(Deadlock)**가 일어나지 않도록 주의해야 한다.
- 예를 들어, 아래와 같은 순서로 잠금을 시도하면 두 스레드 모두 영원히 대기하며 교착 상태에 빠지게 된다.
  1.  스레드 1: A 애그리거트에 대한 선점 잠금 구함
  2.  스레드 2: B 애그리거트에 대한 선점 잠금 구함
  3.  스레드 1: B 애그리거트에 대한 선점 잠금 시도 (스레드 2가 해제할 때까지 대기)
  4.  스레드 2: A 애그리거트에 대한 선점 잠금 시도 (스레드 1이 해제할 때까지 대기)
- 교착 상태는 **사용자 수가 많을수록 발생 가능성이 높아지며**, 한번 발생하면 시스템 전체의 성능에 심각한 영향을 줄 수 있다.
- 이런 문제를 방지하는 한 가지 방법은, 잠금을 구할 때 **최대 대기 시간(Timeout)을 지정**하는 것이다. 지정한 시간 내에 잠금을 얻지 못하면, 무한정 기다리는 대신 예외(Exception)를 발생시켜 교착 상태를 해소한다.
- JPA에서는 **쿼리 힌트(hint)** 를 사용하여 잠금 대기 시간을 `javax.persistence.lock.timeout` 속성으로 지정할 수 있다.

```java
Map<String, Object> hints = new HashMap<>();
// 잠금 대기 시간을 2000ms (2초)로 지정한다.
hints.put("javax.persistence.lock.timeout", 2000);

Order order = entityManager.find(
    Order.class,
    orderNo,
    LockModeType.PESSIMISTIC_WRITE,
    hints
);
```

- 스프링 데이터 JPA에서는 **`@QueryHints` 애너테이션**을 사용하여 쿼리 힌트를 더 간편하게 지정할 수 있다.
- 다만, 이 기능은 **사용하는 DBMS가 잠금 대기 시간 설정을 지원해야만 동작**한다.

## 3. 비선점 잠금

- 선점 잠금은 **하나의 트랜잭션 안에서만 유효하다**는 한계가 있다. 만약 사용자가 데이터를 조회하고, 오랜 시간(예: 10분)이 지난 뒤 수정 요청을 보낸다면, 그 사이에 다른 사용자가 데이터를 수정했더라도 이전 데이터를 기반으로 덮어쓰는 **'오프라인 잠금(Offline Lock)'** 문제가 발생할 수 있다.
- **비선점 잠금(Optimistic Lock)** 은 바로 이런 문제를 해결하기 위한 방식이다. 동시에 접근하는 것을 막지는 않지만, 변경한 데이터를 실제 DB에 반영하는 **커밋 시점에 변경 가능 여부를 확인**한다.
- 비선점 잠금을 구현하려면, 애그리거트에 **버전(version)으로 사용할 숫자 타입 프로퍼티를 추가**하고, 애그리거트를 수정할 때마다 이 버전 값을 1씩 증가시킨다.
- 이때, `UPDATE` 쿼리는 현재 애그리거트의 버전과 DB의 버전이 동일한 경우에만 데이터를 수정하도록 **조건부로 실행**된다.

```sql
UPDATE agg_table SET version = version + 1, col_x = ?, col_y = ?
WHERE agg_id = ? AND version = 현재_애그리거트의_버전값
```

- 예를 들어, 두 사용자가 버전 5인 데이터를 동시에 조회한 후, 한 사용자가 먼저 커밋하여 버전이 6으로 변경되면, 나중에 커밋하려는 다른 사용자는 **버전 불일치로 인해 데이터 수정에 실패**하게 된다.
- JPA는 **`@Version` 애너테이션**을 통해 비선점 잠금 기능을 매우 쉽게 지원한다. 버전으로 사용할 필드에 이 애너테이션만 붙이면, JPA가 `UPDATE` 쿼리 실행 시 `@Version` 필드를 `WHERE` 조건에 자동으로 포함시켜 처리해준다.

```java
@Entity
@Table(name = "orders")
@Access(AccessType.FIELD)
public class Order {

    @EmbeddedId
    private OrderNo number;

    @Version
    private long version;

    // ...
}
```

- 따라서 **응용 서비스는 버전 값을 직접 다룰 필요가 전혀 없다**. 단순히 도메인 기능만 실행하면, JPA가 트랜잭션 종료 시점에 알아서 처리해준다.
- 만약 트랜잭션 충돌이 발생하여 `UPDATE`된 행의 개수가 0이라면, JPA는 트랜잭션 커밋 시점에 `OptimisticLockException`과 같은 예외를 발생시킨다.
- 표현 영역은 이 **예외를 감지하여 '다른 사용자에 의해 데이터가 변경되었습니다.'와 같은 알림을 사용자에게 보여주고, 재시도**를 유도할 수 있다.

### 3.1 강제 버전 증가

- 애그리거트 내에서 루트 엔티티가 아닌 **자식 엔티티의 값만 변경**될 경우, JPA는 **루트 엔티티의 버전 값을 자동으로 증가시키지 않는다**.
- 하지만 애그리거트의 관점에서는, 구성 요소 중 일부만 바뀌어도 **논리적으로는 애그리거트 전체가 변경된 것**이다. 따라서 비선점 잠금이 올바르게 동작하려면, 이 경우에도 **루트의 버전 값이 함께 증가**해야 한다.
- JPA는 이러한 문제를 해결하기 위해, 엔티티의 **상태 변경 여부와 상관없이 트랜잭션 종료 시 강제로 버전을 증가**시키는 잠금 모드를 지원한다.
- `EntityManager.find()` 메서드를 사용하거나 리포지터리의 조회 메서드를 사용할 때, **`LockModeType.OPTIMISTIC_FORCE_INCREMENT`** 잠금 모드를 사용하면 된다.

```java
entityManager.find(Order.class, id, LockModeType.OPTIMISTIC_FORCE_INCREMENT);
```

- 이 잠금 모드를 사용하면, 애그리거트 내의 자식 엔티티나 밸류만 변경되더라도 **루트 엔티티의 버전을 안전하게 증가**시켜 비선점 잠금 기능을 올바르게 적용할 수 있다.
- 스프링 데이터 JPA에서는 **`@Lock` 애너테이션**을 통해 이 잠금 모드를 지정할 수 있다.
