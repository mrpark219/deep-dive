# CQRS

## 1. 단일 모델의 단점

- 주문 내역 조회처럼, **하나의 조회 화면을 위해 여러 애그리거트의 데이터를 조합**해야 하는 경우가 많다. 이때 조회 속도는 매우 중요한데, 이 요구사항을 도메인 모델만으로 구현하기에는 여러 어려움이 따른다.
- 예를 들어, 애그리거트 간에 **식별자(ID) 참조 방식**을 사용하면, JPA가 제공하는 **쿼리 최적화(Fetch Join) 기능을 사용하기 어렵다**. 이로 인해 N+1 문제 등이 발생하여 조회 성능에 문제가 생길 수 있다.
- 반대로 **직접 참조 방식**을 사용하더라도, 조회 화면의 특성에 따라 **즉시 로딩(Eager Loading)과 지연 로딩(Lazy Loading) 사이에서 계속 고민**해야 하는 문제가 있다.
- 이러한 문제들은 **시스템의 상태를 변경할 때와 조회할 때 모두 동일한 도메인 모델을 사용**하기 때문에 발생한다.
- ORM 기술은 도메인의 상태 변경 기능을 구현하는 데는 매우 적합하지만, **여러 애그리거트의 데이터를 조합하여 화면에 보여주는 기능을 구현하기에는 복잡**한 경우가 많다.
- 이러한 구현의 복잡도를 낮추는 가장 좋은 방법은, **상태 변경을 위한 모델**과 **조회를 위한 모델을 분리**하는 것이다.

## 2. CQRS

- 시스템의 기능은 **상태를 변경하는 기능(Command)** 과 **상태를 조회하는 기능(Query)** 으로 나눌 수 있다.
- 상태 변경은 주로 단일 애그리거트를 대상으로 하지만, 조회는 여러 애그리거트의 데이터를 조합해야 하는 경우가 많다.
- **CQRS(Command Query Responsibility Segregation)** 는 이처럼 성격이 다른 두 기능을 **서로 다른 모델을 사용해 구현**하는 패턴이다.
- 상태 변경을 위한 **명령 모델**은 도메인의 비즈니스 로직 수행에 초점을 맞추고, **조회 모델**은 화면에 데이터를 보여주는 데 초점을 맞춰 각각 설계된다.
- CQRS를 적용하면 각 모델에 맞는 구현 기술을 유연하게 선택할 수 있다. 예를 들어, 명령 모델은 JPA로, 조회 모델은 마이바티스나 JDBC 템플릿으로 구현할 수 있다.
- 만약 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용한다면, **이벤트(Event)를 이용해 두 저장소 간의 데이터를 동기화**할 수 있다.

### 2.1. 웹과 CQRS

- 일반적인 웹 서비스는 상태를 변경하는 요청보다 **조회 요청이 훨씬 많기 때문에, 조회 성능을 높이는 것이 중요**하다.
- 쿼리 최적화, 캐싱, 조회 전용 DB 사용 등 조회 성능을 높이기 위한 노력들은, 결과적으로 **명령 모델과 조회 모델을 분리하는 CQRS 패턴을 자연스럽게 적용**하는 것과 같은 효과를 낸다.
- 대규모 트래픽이 발생하는 서비스는 이미 알게 모르게 CQRS를 적용하고 있는 경우가 많다. 따라서 조회 속도를 위해 별도의 처리를 하고 있다면, **명시적으로 명령 모델과 조회 모델을 구분**하여 관리하는 것이 좋다.

### 2.2. CQRS 장단점

- CQRS 패턴은 다음과 같은 장단점을 가진다.
- **장점 1: 명령 모델의 단순화**
  - 조회 관련 로직이 명령 모델에서 완전히 분리되므로, 개발자는 **복잡한 도메인 로직 구현에만 집중**할 수 있다.
- **장점 2: 조회 성능 향상**
  - 조회에 특화된 쿼리, 캐시, 조회 전용 저장소 등 **다양한 최적화 기술을 자유롭게 적용**할 수 있다.
- **단점 1: 구현 코드 증가**
  - 단일 모델을 사용할 때보다 구현해야 할 코드의 양이 많아진다. 도메인이 단순하거나 트래픽이 적은 서비스라면 **CQRS 도입의 실익을 따져봐야 한다**.
- **단점 2: 구현 기술의 복잡성 증가**
  - 각 모델에 다른 기술이나 데이터 저장소를 사용하게 되면, 관리해야 할 기술 스택이 늘어나고 데이터 동기화를 위한 메시징 시스템 등이 추가로 필요할 수 있다.
