# 리포지터리와 모델 구현

## 1. JPA를 이용한 리포지터리 구현

- 도메인 모델과 리포지터리를 구현할 때 많은 개발자들이 선호하는 기술은 **JPA**이다.
- RDBMS를 데이터 저장소로 사용할 때, 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 불일치를 해결해주는 **ORM(Object-Relational Mapping)** 기술이 매우 유용하기 때문이다.

### 1.1. 모듈 위치

- **리포지터리 인터페이스**는 애그리거트와 함께 **도메인 영역**에 속하고, 이를 구현한 클래스는 **인프라스트럭처 영역**에 속하는 것이 이상적이다.
- 팀 표준에 따라 구현체를 `domain.impl`과 같은 패키지에 두는 경우도 있지만, 이는 좋은 설계 원칙을 따르기보다는 분리의 편의를 위한 **타협안에 가깝다**.
- 가능하다면 구현 클래스를 인프라스트럭처 영역에 명확히 위치시켜, **도메인이 인프라스트럭처에 대한 의존을 갖지 않도록** 설계해야 한다.

### 1.2. 리포지터리 기본 기능 구현

- 리포지터리가 기본적으로 제공하는 기능은 크게 두 가지이다.
  - **ID로 애그리거트 조회하기**
  - **애그리거트 저장하기**
- **조회 기능**의 이름에 정해진 규칙은 없지만, `findById()` 또는 `findBy프로퍼티이름()` 형식을 널리 사용한다.
- **저장 기능**을 담당하는 `save()` 메서드는 전달받은 애그리거트를 저장소에 영속화한다.
- JPA를 사용하면, 애그리거트를 수정한 결과를 반영하기 위해 별도의 `update` 메서드를 만들 필요가 없다.
- 트랜잭션이 커밋될 때, JPA는 트랜잭션 범위 내에서 **변경된 객체를 감지하여 자동으로 UPDATE 쿼리를 실행**해주기 때문이다. 이를 **더티 체킹(Dirty Checking)** 이라고 한다.

## 2. 스프링 데이터 JPA를 이용한 리포지터리 구현

- 스프링 프레임워크와 JPA를 함께 사용할 때는 **스프링 데이터 JPA(Spring Data JPA)** 를 사용하면 매우 편리하다.
- 스프링 데이터 JPA는 **정해진 규칙에 따라 인터페이스만 정의하면, 그 구현체를 동적으로 생성하여 스프링 빈으로 등록**해준다.
- 따라서 개발자가 **직접 리포지터리 구현 클래스를 만들지 않아도 되는 장점**이 있다.
- 스프링 데이터 JPA가 자동으로 구현체를 만들어주는 규칙은 다음과 같다.
  - `org.springframework.data.repository.Repository<T, ID>` 인터페이스를 상속한다.
  - 여기서 `T`는 애그리거트 루트 엔티티의 타입을, `ID`는 해당 엔티티의 식별자 타입을 지정한다.

## 3. 매핑 구현

### 3.1. 엔티티와 밸류 기본 매핑 구현

- 애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.
  - 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정을 한다.
  - 하나의 테이블에 엔티티와 밸류 타입 데이터가 함께 저장될 경우, 밸류 타입은 `@Embeddable`로, 해당 프로퍼티는 `@Embedded`로 매핑 설정을 한다.
- 루트 엔티티와 루트 엔티티에 속한 밸류는 한 테이블에 매핑할 때가 많다.
- 만약 `@Embeddable` 타입에 정의된 컬럼명과 실제 테이블의 컬럼명이 다르다면, `@AttributeOverride` 애너테이션을 이용해 매핑할 컬럼명을 변경할 수 있다.

### 3.2. 기본 생성자

- 도메인 모델 관점에서, 특히 불변(Immutable) 밸류 타입은 생성 시점에 모든 값을 전달받으므로 **기본 생성자가 필요하지 않다**.
- 하지만 JPA는 DB에서 데이터를 읽어와 객체를 생성할 때 내부적으로 기본 생성자를 사용한다. 따라서 **`@Entity`나 `@Embeddable`로 매핑된 클래스는 반드시 기본 생성자를 가져야 한다**.
- 이 기본 생성자는 오직 JPA를 위한 것이다. 다른 코드에서 실수로 이 생성자를 호출하여 불완전한 객체를 만드는 것을 방지하기 위해, **접근 제어자를 `protected`로 선언**하는 것이 바람직하다.

### 3.3. 필드 접근 방식 사용

- JPA는 **필드**와 **메서드**의 두 가지 방식으로 매핑을 처리할 수 있다. 메서드 방식을 사용하려면 `get/set` 메서드가 필요하다.
- 하지만 엔티티에 의미 없이 공개 `get/set` 메서드를 추가하는 것은 좋지 않다. 특히 **`set` 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 객체의 캡슐화를 깨는 원인이 될 수 있다**.
- 엔티티가 객체로서 제 역할을 하려면 `set` 메서드로 단순히 값을 변경하는 대신, **의도가 명확히 드러나는 기능을 제공**해야 한다.
- 불변(Immutable) 밸류 타입은 원칙적으로 `set` 메서드가 필요 없음에도, JPA의 구현 방식 때문에 공개 `set` 메서드를 추가하는 것은 좋지 않다.
- 따라서 기능 중심의 엔티티를 구현하도록 유도하려면, JPA 매핑 처리를 **프로퍼티 방식이 아닌 필드 방식으로 선택하여 불필요한 `get/set` 메서드를 만들지 않도록** 하는 것이 좋다.

### 3.4. AttributeConverter를 이용한 밸류 매핑 처리

- `int`, `long`, `String`과 같은 기본 타입처럼, **밸류 타입 객체 전체를 DB 테이블의 한 개 컬럼에 매핑**해야 할 때가 있다.
- 특히 두 개 이상의 프로퍼티를 가진 밸류 타입을 단일 컬럼에 매핑하는 것은 `@Embeddable`로는 불가능하다.
- 이때 사용하는 것이 바로 **`AttributeConverter`**이다. `AttributeConverter`는 밸류 타입과 DB 컬럼 데이터 간의 변환을 처리하기 위해 아래 두 메서드를 구현해야 한다.

```java
    // To Database: 밸류 타입을 DB 컬럼 값으로 변환한다.
    public Y convertToDatabaseColumn(X attribute);

    // From Database: DB 컬럼 값을 밸류 타입으로 변환한다.
    public X convertToEntityAttribute(Y dbData);
```

- 여기서 타입 파라미터 **X**는 밸류 타입이고, **Y**는 DB 컬럼의 타입이다.
- `@Converter` 애너테이션의 `autoApply` 속성을 `true`로 설정하면 모든 해당 타입의 프로퍼티에 컨버터가 자동으로 적용된다.
- 만약 `autoApply` 속성을 `false`로 지정하면, 변환이 필요한 프로퍼티에 **`@Convert` 애너테이션을 사용해 직접 컨버터를 지정**해야 한다.

### 3.5. 밸류 컬렉션: 별도 테이블 매핑

- 한 엔티티가 **한 개 이상의 밸류 객체를 컬렉션으로 가져야 할 경우**, 별도의 테이블에 저장해야 한다.
- 이때, 컬렉션 테이블은 자신이 속한 엔티티의 테이블을 **외부 키(Foreign Key)로 참조**하는 구조가 된다.
- JPA에서는 밸류 컬렉션을 별도의 테이블로 매핑하기 위해 **`@ElementCollection`**과 **`@CollectionTable`** 애너테이션을 함께 사용한다.

### 3.6. 밸류 컬렉션: 한 개 컬럼에 매핑하기

- 밸류 객체의 컬렉션을 별도의 테이블이 아닌, **하나의 컬럼에 저장**해야 할 때가 있다. 예를 들어, 여러 이메일 주소를 콤마(`,`)로 구분하여 하나의 문자열로 저장하는 경우이다.
- 이때 이전에 다룬 **`AttributeConverter`를 사용하면 밸류 컬렉션을 단일 컬럼에 매핑**할 수 있다.
- 단, `AttributeConverter`를 적용하려면 `Set<Email>`과 같은 컬렉션 자체를 직접 매핑할 수는 없으므로, **컬렉션을 표현하는 새로운 밸류 타입을 추가**해야 한다.
- 예를 들어, `Set<Email>`을 감싸는 `EmailSet` 밸류 타입을 아래와 같이 정의할 수 있다.

```java
public class EmailSet {
  private Set<Email> emails = new HashSet<>();

    // JPA는 기본 생성자를 필요로 한다.
    protected EmailSet() {
    }

    public EmailSet(Set<Email> emails) {
        this.emails.addAll(emails);
    }

    public Set<Email> getEmails() {
        // 외부에서 수정하지 못하도록 Unmodifiable Set으로 반환한다.
        return Collections.unmodifiableSet(emails);
    }
  }
```

### 3.7. 밸류 타입을 이용한 식별자 매핑

- 단순한 문자열이나 숫자 대신, **식별자 자체를 의미 있는 밸류 타입으로 만들어** 도메인의 의미를 더 명확하게 할 수 있다.
- 밸류 타입을 식별자로 사용하려면, `@Id` 대신 **`@EmbeddedId` 애너테이션을 사용**하여 매핑해야 한다.
- 또한, JPA의 식별자 타입은 `Serializable` 인터페이스를 구현해야 하므로, **식별자로 사용할 밸류 타입 역시 `Serializable`을 상속**해야 한다.
- 밸류 타입을 식별자로 사용하면 **식별자에 관련된 도메인 로직을 추가**할 수 있다는 장점이 있다. 예를 들어, 주문 번호의 첫 글자로 시스템의 세대를 구분하는과 같은 기능을 식별자 객체 자체에 구현할 수 있다.
- JPA는 내부적으로 엔티티의 동일성을 비교할 때 식별자를 사용한다. 따라서 식별자로 사용하는 밸류 타입은 **`equals()`와 `hashCode()` 메서드를 올바르게 재정의**해야 한다.

### 3.8. 별도 테이블에 저장하는 밸류 매핑

- 애그리거트에서 루트 엔티티를 제외한 나머지 구성 요소는 대부분 **밸류(Value) 타입**이다. 만약 루트 외에 또 다른 엔티티가 존재한다면, 그것이 정말 엔티티인지 혹은 별개의 애그리거트는 아닌지 의심해봐야 한다.
- 단순히 **별도의 테이블에 저장된다는 이유만으로 엔티티라고 판단해서는 안 된다**. 만약 해당 객체가 **독자적인 라이프사이클**을 가진다면, 그것은 현재 애그리거트에 속한 엔티티가 아니라 **별개의 애그리거트일 가능성**이 높다.
- 밸류와 엔티티를 구분하는 핵심 기준은 **도메인 관점의 고유 식별자 존재 여부**이다.
- 이때 주의할 점은, DB 테이블의 **기본 키(Primary Key)를 도메인 모델의 식별자와 동일시해서는 안 된다**는 것이다. 특정 밸류가 별도의 테이블에 저장되고 그 테이블이 PK를 갖더라도, 그것이 도메인 관점의 고유 식별자를 의미하는 것은 아니다.
- JPA에서 밸류를 별도의 테이블에 매핑할 때는 **`@SecondaryTable`** 애너테이션을 사용한다.
  - **`name` 속성**: 밸류를 저장할 테이블의 이름을 지정한다.
  - **`pkJoinColumns` 속성**: 밸류 테이블에서 엔티티 테이블로 조인할 때 사용할 컬럼을 지정한다.
- 밸류에 포함된 각각의 속성들은 **`@AttributeOverride`** 를 이용해 `@SecondaryTable`로 지정한 테이블의 컬럼에 매핑한다.

### 3.9. 밸류 타입을 @Entity로 매핑하기

- 개념적으로는 밸류(Value) 타입이지만, **구현 기술의 한계나 팀 표준 때문에 `@Entity`로 매핑**해야 할 때가 있다.
- 대표적인 예로, JPA는 `@Embeddable` 타입에 대한 상속 매핑을 지원하지 않는다. 따라서 **상속 구조를 갖는 밸류 타입을 구현하려면, `@Embeddable` 대신 `@Entity`를 사용**하여 상속 매핑으로 처리해야 한다.
- 밸류를 `@Entity`로 매핑하므로, **식별자(ID)를 위한 필드를 추가**해야 하며, 상속 관계의 클래스들을 구분하기 위한 **타입 식별 컬럼(Discriminator Column)도 필요**하다.
- 하나의 테이블에 여러 하위 클래스를 함께 매핑하는 **단일 테이블 전략(Single Table Strategy)**을 사용하기 위해, 보통 아래와 같이 설정한다.
  - `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)` 애너테이션을 적용한다.
  - `@DiscriminatorColumn` 애너테이션으로 타입 구분용 컬럼을 지정한다.
- 비록 `@Entity`로 매핑했더라도 개념적으로는 밸류이므로, **상태를 변경하는 `set` 메서드 등은 제공하지 않아야** 한다.
- 또한, 이 방식은 **컬렉션 처리 시 심각한 성능 문제**를 일으킬 수 있다. `@OneToMany`로 매핑된 `@Entity` 컬렉션의 `clear()` 메서드를 호출하면, 하이버네이트는 컬렉션의 모든 엔티티를 하나씩 `DELETE`하는 비효율적인 방식을 사용한다.
- 반면, `@Embeddable` 타입의 컬렉션은 `clear()` 시 한 번의 `DELETE` 쿼리로 모든 요소를 삭제하여 훨씬 효율적이다.
- 따라서 성능이 중요하다면, **상속 구조를 포기하고 `@Embeddable`로 매핑된 단일 클래스로 구현**하는 것을 고려해야 한다. 이 경우, 타입에 따른 기능 분기는 `if-else` 등을 사용해 처리해야 한다.

### 3.10. ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

- [이전 내용](./aggregate.md#5-애그리거트-간-집합-연관), 애그리거트 간의 집합 연관은 성능 문제 때문에 피하는 것이 좋다.
- 그럼에도 불구하고 요구사항을 구현하는 데 집합 연관이 유리하다면, **ID 참조를 이용한 단방향 M-N 연관**을 적용해 볼 수 있다.
- ID 참조를 이용한 단방향 M-N 연관은, 앞서 다룬 **밸류 컬렉션을 별도 테이블에 매핑하는 방식과 동일하게 구현**할 수 있다.
- 차이점은 컬렉션에 밸류 객체가 아닌, **참조할 애그리거트의 ID**가 저장된다는 점이다. 이 방식은 JPA의 `@ElementCollection`을 이용하여 조인 테이블을 통해 구현된다.
- 이 방식의 장점은, 애그리거트를 직접 참조할 때 고민해야 했던 **영속성 전파(Cascade)나 로딩 전략(Eager/Lazy)에 대해 신경 쓰지 않아도 된다**는 것이다.
- 예를 들어, `@ElementCollection`을 사용하면 애그리거트가 삭제될 때 조인 테이블의 연관 데이터도 함께 삭제되어 라이프사이클 관리가 간편해진다.

## 4. 애그리거트 로딩 전략

- JPA 매핑 설정 시, **애그리거트에 속한 모든 객체가 모여야 개념적으로 완전한 하나**가 된다는 점을 기억해야 한다.
- 이 원칙에 따르면, 애그리거트 루트를 조회할 때 루트에 속한 모든 객체가 함께 로딩되어 완전한 상태가 되어야 한다.
- 이를 구현하는 가장 간단한 방법은 애그리거트 내의 모든 연관 매핑을 **즉시 로딩(Eager Loading)으로 설정**하는 것이다.
- 하지만 이 방식이 항상 좋은 것은 아니다. 특히 컬렉션을 즉시 로딩하면, 의도치 않은 **카티전 곱(Cartesian Product) 조인**이 발생하여 데이터 중복과 심각한 성능 저하를 유발할 수 있다.
- 따라서 컬렉션을 즉시 로딩으로 설정할 때는 **조회되는 데이터의 양, 실행 빈도, 트래픽 등을 신중하게 검토**해야 한다.
- **'애그리거트가 완전해야 한다'는 것은 '항상 모든 연관 객체를 즉시 로딩해야 한다'는 의미는 아니다**.
- 애그리거트가 완전해야 하는 이유는 크게 두 가지인데, 첫째는 **상태 변경 기능을 실행**할 때이고, 둘째는 **표현 영역에 상태 정보를 보여줄 때**이다.
- 이 중 두 번째 이유, 즉 **단순 조회를 위한 것이라면 CQRS 패턴처럼 조회 전용 모델을 따로 구현**하는 것이 더 효율적인 해결책이 될 수 있다.
- 결론적으로, 애그리거트 내의 모든 연관을 즉시 로딩으로 설정할 필요는 없다. **지연 로딩(Lazy Loading)을 기본으로 사용**하고, 필요한 경우에만 즉시 로딩을 선택적으로 적용하는 것이 좋다.
- 지연 로딩은 동작 방식이 단순하여 예측이 쉽다는 장점이 있지만, **N+1 조회 문제와 같은 추가적인 쿼리 발생 가능성**은 항상 염두에 두어야 한다.

## 5. 애그리거트의 영속성 전파

- 애그리거트의 '완전성' 원칙은 조회뿐만 아니라 **저장 및 삭제 시에도 동일하게 적용**되어야 한다.
  - **저장 시**: 애그리거트 루트를 저장하면, 애그리거트에 속한 **모든 객체가 함께 저장**되어야 한다.
  - **삭제 시**: 애그리거트 루트를 삭제하면, 애그리거트에 속한 **모든 객체가 함께 삭제**되어야 한다.
- JPA에서 `@Embeddable` 타입은 부모 엔티티와 생명주기를 함께하므로 별도의 설정이 필요 없다.
- 반면, 애그리거트 내의 다른 `@Entity`에 대한 연관 매핑은 **`cascade` 속성을 설정**하여, 영속성 상태의 변화가 함께 전파되도록 만들어야 한다.
- `@OneToOne`, `@OneToMany` 연관은 기본적으로 영속성이 전파되지 않으므로, 아래와 같이 `cascade` 속성을 명시적으로 설정해야 한다.

```java
@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE}, orphanRemoval = true)
@JoinColumn(name = "product_id")
private List<Image> images = new ArrayList<>();
```

## 6. 식별자 생성 기능

- 애그리거트의 식별자는 보통 다음 세 가지 방식 중 하나로 생성한다.
  - **사용자가 직접 생성**
  - **도메인 로직으로 생성**
  - **데이터베이스를 이용한 일련번호 사용**

### 6.1. 사용자가 직접 생성

- 사용자가 이메일 주소처럼 **직접 식별자를 입력하는 경우**, 생성 주체는 사용자가 되므로 별도의 식별자 생성 기능이 필요 없다.

### 6.2. 도메인 로직으로 생성

- 식별자를 만드는 **특정한 생성 규칙이 있다면, 이는 도메인 로직**에 해당하므로 도메인 영역에서 식별자 생성 기능을 구현해야 한다.
- 보통 **도메인 서비스(Domain Service)**를 별도로 만들어 식별자 생성 로직을 구현하거나, **리포지터리 인터페이스에 식별자 생성 메서드를 추가**하는 방법을 사용한다.

### 6.3. 데이터베이스를 이용한 생성

- 데이터베이스의 **자동 증가(auto-increment) 컬럼을 식별자로 사용**하려면, JPA의 **`@GeneratedValue` 애너테이션**을 이용한다.
- 이 방식은 DB에 `INSERT` 쿼리가 실행되어야 식별자가 생성된다. 즉, **리포지터리에 애그리거트를 저장하는 시점**에 식별자가 만들어진다.
- JPA는 저장 시점에 생성된 식별자를 `@Id`가 붙은 필드에 자동으로 할당해주므로, 개발자는 저장 직후부터 해당 엔티티의 식별자를 사용할 수 있다.

## 7. 도메인 구현과 DIP

- 현실적으로 JPA를 활용하여 구현한 리포지터리와 도메인 모델은 **엄격한 의미의 DIP 원칙을 위반**하고 있다.
- 도메인 엔티티는 `@Entity`, `@Table` 등 JPA 전용 애너테이션을 사용하고, 도메인 영역의 리포지터리 인터페이스는 인프라 기술인 스프링 데이터 JPA의 `Repository` 인터페이스를 상속하기 때문이다. 이는 **고수준 모듈인 도메인이 저수준 모듈인 인프라스트럭처에 의존**하는 형태이다.
- DIP를 완벽하게 지켜 순수한 도메인을 유지하려면, 도메인 모델에서 JPA 애너테이션과 같은 구현 기술 코드를 모두 제거하고, 인프라스트럭처 계층에 JPA 전용 데이터 모델과 구현체를 따로 만드는 방식을 사용해야 한다. 이 구조는 구현 기술 변경 시 **도메인이 받는 영향을 최소화**할 수 있다는 장점이 있다.
- 하지만 DIP의 주된 목적인 '구현 기술 변경에 대한 유연성'의 입장에서 생각해보면, **데이터베이스나 JPA 같은 영속성 기술은 거의 바뀌지 않는다**.
- 변경 가능성이 거의 없는 기술에 대비하기 위해 **구조를 과도하게 복잡하게 만드는 것은 비효율적**일 수 있다.
- 따라서 DIP를 완벽하게 지키는 것보다는, **개발 편의성과 실용성을 얻는 선에서 도메인 모델이 구현 기술에 어느 정도 의존**하도록 하는 것이 더 합리적인 선택일 수 있다. 이는 구조적인 유연함을 일부 유지하면서도, 불필요한 복잡도를 높이지 않는 실용적인 접근법이다.
