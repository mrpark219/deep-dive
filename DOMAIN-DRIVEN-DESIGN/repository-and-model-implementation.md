# 리포지터리와 모델 구현

## 1. JPA를 이용한 리포지터리 구현

- 도메인 모델과 리포지터리를 구현할 때 많은 개발자들이 선호하는 기술은 **JPA**이다.
- RDBMS를 데이터 저장소로 사용할 때, 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 불일치를 해결해주는 **ORM(Object-Relational Mapping)** 기술이 매우 유용하기 때문이다.

### 1.1. 모듈 위치

- **리포지터리 인터페이스**는 애그리거트와 함께 **도메인 영역**에 속하고, 이를 구현한 클래스는 **인프라스트럭처 영역**에 속하는 것이 이상적이다.
- 팀 표준에 따라 구현체를 `domain.impl`과 같은 패키지에 두는 경우도 있지만, 이는 좋은 설계 원칙을 따르기보다는 분리의 편의를 위한 **타협안에 가깝다**.
- 가능하다면 구현 클래스를 인프라스트럭처 영역에 명확히 위치시켜, **도메인이 인프라스트럭처에 대한 의존을 갖지 않도록** 설계해야 한다.

### 1.2. 리포지터리 기본 기능 구현

- 리포지터리가 기본적으로 제공하는 기능은 크게 두 가지이다.
  - **ID로 애그리거트 조회하기**
  - **애그리거트 저장하기**
- **조회 기능**의 이름에 정해진 규칙은 없지만, `findById()` 또는 `findBy프로퍼티이름()` 형식을 널리 사용한다.
- **저장 기능**을 담당하는 `save()` 메서드는 전달받은 애그리거트를 저장소에 영속화한다.
- JPA를 사용하면, 애그리거트를 수정한 결과를 반영하기 위해 별도의 `update` 메서드를 만들 필요가 없다.
- 트랜잭션이 커밋될 때, JPA는 트랜잭션 범위 내에서 **변경된 객체를 감지하여 자동으로 UPDATE 쿼리를 실행**해주기 때문이다. 이를 **더티 체킹(Dirty Checking)** 이라고 한다.

## 2. 스프링 데이터 JPA를 이용한 리포지터리 구현

- 스프링 프레임워크와 JPA를 함께 사용할 때는 **스프링 데이터 JPA(Spring Data JPA)** 를 사용하면 매우 편리하다.
- 스프링 데이터 JPA는 **정해진 규칙에 따라 인터페이스만 정의하면, 그 구현체를 동적으로 생성하여 스프링 빈으로 등록**해준다.
- 따라서 개발자가 **직접 리포지터리 구현 클래스를 만들지 않아도 되는 장점**이 있다.
- 스프링 데이터 JPA가 자동으로 구현체를 만들어주는 규칙은 다음과 같다.
  - `org.springframework.data.repository.Repository<T, ID>` 인터페이스를 상속한다.
  - 여기서 `T`는 애그리거트 루트 엔티티의 타입을, `ID`는 해당 엔티티의 식별자 타입을 지정한다.

## 3. 매핑 구현

### 3.1. 엔티티와 밸류 기본 매핑 구현

- 애그리거트와 JPA 매핑을 위한 기본 규칙은 다음과 같다.
  - 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정을 한다.
  - 하나의 테이블에 엔티티와 밸류 타입 데이터가 함께 저장될 경우, 밸류 타입은 `@Embeddable`로, 해당 프로퍼티는 `@Embedded`로 매핑 설정을 한다.
- 루트 엔티티와 루트 엔티티에 속한 밸류는 한 테이블에 매핑할 때가 많다.
- 만약 `@Embeddable` 타입에 정의된 칼럼명과 실제 테이블의 칼럼명이 다르다면, `@AttributeOverride` 애너테이션을 이용해 매핑할 칼럼명을 변경할 수 있다.

### 3.2. 기본 생성자

- 도메인 모델 관점에서, 특히 불변(Immutable) 밸류 타입은 생성 시점에 모든 값을 전달받으므로 **기본 생성자가 필요하지 않다**.
- 하지만 JPA는 DB에서 데이터를 읽어와 객체를 생성할 때 내부적으로 기본 생성자를 사용한다. 따라서 **`@Entity`나 `@Embeddable`로 매핑된 클래스는 반드시 기본 생성자를 가져야 한다**.
- 이 기본 생성자는 오직 JPA를 위한 것이다. 다른 코드에서 실수로 이 생성자를 호출하여 불완전한 객체를 만드는 것을 방지하기 위해, **접근 제어자를 `protected`로 선언**하는 것이 바람직하다.

### 3.3. 필드 접근 방식 사용

- JPA는 **필드**와 **메서드**의 두 가지 방식으로 매핑을 처리할 수 있다. 메서드 방식을 사용하려면 `get/set` 메서드가 필요하다.
- 하지만 엔티티에 의미 없이 공개 `get/set` 메서드를 추가하는 것은 좋지 않다. 특히 **`set` 메서드는 내부 데이터를 외부에서 변경할 수 있는 수단이 되기 때문에 객체의 캡슐화를 깨는 원인이 될 수 있다**.
- 엔티티가 객체로서 제 역할을 하려면 `set` 메서드로 단순히 값을 변경하는 대신, **의도가 명확히 드러나는 기능을 제공**해야 한다.
- 불변(Immutable) 밸류 타입은 원칙적으로 `set` 메서드가 필요 없음에도, JPA의 구현 방식 때문에 공개 `set` 메서드를 추가하는 것은 좋지 않다.
- 따라서 기능 중심의 엔티티를 구현하도록 유도하려면, JPA 매핑 처리를 **프로퍼티 방식이 아닌 필드 방식으로 선택하여 불필요한 `get/set` 메서드를 만들지 않도록** 하는 것이 좋다.
