# 데이터베이스는 세부사항이다

- 아키텍처 관점에서 볼 때 데이터베이스는 **엔티티(Entity)가 아니다**.
  - 즉, 데이터베이스는 철저한 **세부사항**이라서 아키텍처의 핵심 구성요소 수준으로 끌어올릴 수 없다.
  - 데이터베이스는 데이터 모델이 아니라 일개 **소프트웨어(유틸리티)** 일 뿐이다.

## 1. 관계형 데이터베이스

- 관계형 데이터베이스의 기술이 얼마나 뛰어나든, 유용하든 결국 그저 **기술일 뿐**이고, 이는 관계형 데이터베이스가 **세부사항**임을 뜻한다.
- 관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리하지만, 데이터를 테이블에 행(Row) 단위로 저장한다는 사실은 아키텍처적으로 볼 때 **전혀 중요하지 않다**.
- 애플리케이션의 유스케이스는 이러한 저장 방식을 **알아서도, 관여해서도 안 된다**.
- 데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 **유틸리티 함수(데이터 접근 계층)만 알아야 한다**.
- 많은 데이터 접근 프레임워크가 테이블과 행 구조를 띤 객체(Entity가 아닌 단순 데이터 컨테이너) 형태로 시스템 여기저기에 돌아다니게 허용하는데, 이는 **아키텍처적으로 매우 잘못된 설계**다.

## 2. 데이터베이스 시스템은 왜 이렇게 널리 사용되는가

- 데이터베이스 시스템이 시스템과 소프트웨어 기업을 장악할 수 있었던 근본적인 이유는 바로 **디스크(Disk)** 때문이다.
- 지난 반세기 동안 회전식 자기 디스크는 데이터 저장소의 중심에 있었다.
- 하지만 디스크 기술은 **너무 느리다**는 치명적인 단점이 있다.
  - 디스크에서 데이터는 원형 **트랙(Track)** 에 저장된다.
  - 트랙은 **섹터(Sector)** 로 분할되고, 각 섹터는 사용하기 편한 크기의 바이트(대체로 4K)를 저장했다.
  - 각 플래터(Platter)는 대략 수백 개의 트랙으로 구성되었고, 디스크는 십여 개의 플래터로 구성되었다.
- 디스크에서 특정 바이트를 읽으려면, 먼저 헤드(Head)를 적절한 트랙으로 옮기고, 디스크가 돌면서 헤드 위치에 적절한 섹터가 올 때까지 기다린 후, 해당 섹터에서 4K 모두를 **RAM으로 읽어 들여야** 한다.
  - 그런 후 해당 RAM 버퍼의 색인을 찾아서 필요한 바이트를 가져왔다.
- 이 모든 작업에는 **밀리초(ms)** 단위의 시간이 걸렸다.
  - 사람에게는 빠르다고 느낄 수 있지만, 대다수의 프로세서에서 한 명령어를 처리하는 주기보다 **백만 배나 오래 걸리는 시간**이다.
  - 데이터를 저장하는 곳이 디스크가 아니었다면(즉, 전부 RAM이었다면) 밀리초가 아니라 나노초 수준으로 데이터에 접근할 수 있었을 것이다.
- 이처럼 디스크의 어마어마한 시간 지연 때문에 **색인(Index), 캐시(Cache), 쿼리 계획 최적화**가 필요해졌다.
  - 그리고 데이터를 표현하는 일종의 표준적인 방식도 필요했는데, 이러한 색인, 캐시, 쿼리 계획에서 작업 중인 대상이 어떤 데이터인지 알 수 있어야 했기 때문이다.
  - 따라서 데이터 접근 및 관리 시스템이 필요했고, 이는 **파일 시스템**과 **관계형 데이터베이스 관리 시스템(RDBMS)** 이라는 2가지 유형으로 분리되었다.

### 파일 시스템 vs 데이터베이스 시스템

- **파일 시스템은 문서 기반이다.**
  - 문서 전체를 자연스럽고 편리하게 저장하는 방법을 제공한다.
  - 일련의 문서를 '이름'을 기준으로 저장하거나 조회할 때는 잘 동작하지만, '내용'을 기준으로 검색할 때는 그리 크게 도움 되지 않는다.
- **데이터베이스 시스템은 내용 기반이다.**
  - 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다.
  - 레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 **연관(Join)** 짓는 데 매우 탁월하다.
  - 하지만 안타깝게도 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합하다.
- **결론:** 두 시스템 모두 결국 궁극적인 목적은, 데이터를 빠르게 조작할 수 있도록 **관련 있는 데이터를 디스크에서 RAM으로 빠르게 가져오기 위함**이다.

## 3. 디스크가 없다면 어떻게 될까?

- 한때는 자기 디스크가 성행했지만, 이제는 점차 소멸 중이다.
- 디스크는 점점 **RAM** 으로 대체되고 있다.
- 만약 세상의 모든 디스크가 사라지고 모든 데이터가 RAM에 올라간다면?
  - 데이터들은 연결 리스트(Linked List), 트리(Tree), 해시 테이블(Hash Table), 스택, 큐 등 애플리케이션에 적합한 수많은 **데이터 구조**로 체계화할 것이며, 데이터에 접근할 때 **포인터나 참조**를 사용할 것이다. (즉, 테이블 구조가 전혀 필요 없어진다.)

## 4. 세부사항

- **데이터베이스가 세부사항이라고 말하는 이유**는 바로 여기에 있다.
- 데이터베이스는 그저 메커니즘에 불과하며, 디스크 표면과 RAM 사이에서 데이터를 **이리저리 옮길 때 사용하는 도구**일 뿐이다.
- 따라서 데이터베이스는 비트를 담는 거대한 그릇이며, 데이터를 장기적으로 저장하는 공간에 지나지 않는다.

## 5. 하지만 성능은?

- **성능**은 물론 아키텍처와 관련된 중요한 관심사다.
- 하지만 데이터 저장소의 측면에서 성능은 완전히 캡슐화하여 **업무 규칙과는 분리할 수 있는 관심사**다.
- 데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만, 이는 철저히 **저수준의 관심사**다.
  - 이 관심사는 저수준의 **데이터 접근 메커니즘 단(Data Access Layer)** 에서 충분히 다룰 수 있다.
- 결론적으로 특정 데이터베이스의 성능이나 쿼리 최적화 기술 등은 시스템의 **전반적인 (고수준) 아키텍처**와는 관련이 없다.
