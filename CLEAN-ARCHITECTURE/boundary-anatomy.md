# 경계 해부학

## 1. 경계 횡단하기

- 런타임에 **경계를 횡단한다**는 말은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 **데이터를 전달**하는 일에 불과하다.
- 적절한 위치에서 경계를 횡단하게 하려면 **소스 코드 의존성 관리**를 해야 한다.
  - 소스 코드 모듈 하나가 변경되면 이에 의존하는 다른 소스 코드 모듈도 변경하거나 다시 컴파일해서 새로 배포해야 할지도 모른다.
- **경계**는 이러한 **변경이 전파**되는 것을 막는 **방화벽**을 구축하고 관리하는 수단으로서 존재한다.

## 2. 두려운 단일체

- 아키텍처 경계 중에서 가장 단순하며 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태다.
- 이 형태에서는 함수와 데이터가 **단일 프로세서**에서 **같은 주소 공간**을 공유하며 나름의 규칙에 따라 분리되어 있을 뿐이다.
  - 이를 **소스 수준 분리 모드**라고 했다.
- 배포 관점에서 보면 이는 소위 **단일체(Monolith)** 라고 불리는 **단일 실행 파일**에 지나지 않는다.
  - 이때 단일체는 경계가 드러나지 않는다. 컴포넌트 수준으로 분리되지 않기 때문이다.
  - 그렇다고 해서 단일체에서 경계가 실제로 존재하지 않거나, 경계 자체가 **무의미하다는 뜻은 아니다**.
  - 최종적으로는 정적으로 링크된 단일 실행 파일을 만들더라도, 그 안에 포함된 다양한 컴포넌트를 **독립적**으로 개발하고 바이너리로 만드는 것은 대단히 **가치 있는 일**이다.
- 이러한 아키텍처는 거의 모든 경우에 특정한 **동적 다형성(Dynamic Polymorphism)** 에 의존하여 내부 의존성을 **관리한다**.
  - 이 때문에 **객체 지향 개발**이 아주 중요한 패러다임이 될 수 있었다.
  - 객체 지향이 없었다면, 또는 다형성에 해당하는 메커니즘이 없었다면 아키텍트는 결합도를 적절히 분리하기 위해 함수를 가리키는 **포인터**라는 위험한 옛 관행에 **기대야만** 했을 것이다.
  - 포인터는 매우 위험하기 때문에 컴포넌트로 분리하지 못했을 것이다.
- 정적 링크된 **모노리틱 구조**의 실행 파일이라도 이처럼 규칙적인 방식으로 구조를 분리하면 프로젝트를 **개발, 테스트, 배포**하는 작업에 큰 도움이 된다.
  - 팀들은 서로 영역을 침범하지 않고 작업할 수 있고, **고수준 컴포넌트**는 **저수준 세부사항**으로부터 **독립적**으로 유지된다.

### 2.1. 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출

- **런타임 의존성**과 **컴파일 타임 의존성**은 모두 **같은 방향**, 즉 **저수준 클라이언트**에서 **고수준 컴포넌트**를 향한다.
- 이때 파라미터가 필요하다면 **고수준 서비스**에 정의를 해야 한다.

### 2.2. 고수준 클라이언트가 저수준 서비스를 호출 (의존성 역전)

- **동적 다형성**을 사용하여 **제어 흐름(Control Flow)** 과는 **반대 방향**으로 **의존성**을 역전시킬 수 있다.
- 이렇게 하면 **런타임 의존성**은 **컴파일 타임 의존성**과는 반대가 된다.
- **고수준 Client**는 **Service 인터페이스**를 통해 **저수준인 ServiceImpl**을 호출한다.
  - 이때 **소스 코드 의존성**은 **고수준 컴포넌트**(인터페이스가 위치한 곳)를 향한다.
  - 즉, 제어 흐름은 `High -> Low`로 흐르지만, 의존성은 `Low -> High`로 향하게 되어 **고수준 정책**을 보호할 수 있다.

## 3. 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드러날 수도 있는데, 그중 가장 단순한 형태는 **동적 링크 라이브러리**다.
  - `.NET DLL`, `Java .jar` 파일, `Ruby Gem` 등이 예시다.
- 컴포넌트를 이 형태로 배포하면 따로 컴파일하지 않고 **곧바로** 사용할 수 있다.
  - 대신 컴포넌트는 바이너리와 같이 **배포 가능한 형태**로 전달된다.
  - 이를 **배포 수준 결합 분리 모드**라고 했다.
- 이는 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 **단일체(Monolith)** 와 동일하게 **같은 주소 공간**에 위치한다.

## 4. 스레드

- **단일체**와 **배포형 컴포넌트**는 모두 **스레드**를 활용할 수 있다.
- **스레드**는 아키텍처 경계도 아니며, 배포 단위도 **아니다**.
  - 이보다 스레드는 **실행 계획**과 **순서**를 체계화하는 방법에 가깝다.

## 5. 로컬 프로세스

- 훨씬 강한 **물리적 형태**를 띠는 아키텍처 경계로는 **로컬 프로세스**가 있다.
- 로컬 프로세스는 주로 명령행이나 그와 유사한 **시스템 호출**을 통해 생성된다.
- 로컬 프로세스들은 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 프로세서들에서 실행되지만, 각각이 **독립된 주소 공간**에서 실행된다.
  - 일반적으로 **메모리 보호**를 통해 프로세스들이 메모리를 **공유하지 못하게** 한다.
- 대부분 로컬 프로세스는 **소켓**, **메일 박스**, **메시지 큐**와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신한다.
- 각 로컬 프로세스는 정적으로 링크된 **단일체**이거나 동적으로 링크된 여러 개의 **컴포넌트**로 구성될 수 있다.
- **로컬 프로세스**를 일종의 **최상위 컴포넌트**로 생각하고, 로컬 프로세스 컴포넌트 간 의존성을 **동적 다형성**을 통해 관리하는 저수준 컴포넌트로 구성된다.
- **로컬 프로세스 간 분리 전략**은 단일체나 바이너리 컴포넌트의 경우와 **동일하다**.
  - **고수준 프로세스**의 소스 코드가 **저수준 프로세스**의 이름, **물리 주소**, **레지스트리 조회 키**를 절대로 **포함해서는 안 된다**.
  - **저수준 프로세스**가 고수준 프로세스의 **플러그인**이 되도록 **만드는** 것이 필요하다.

## 6. 서비스

- 물리적인 형태를 띠는 **가장 강력한 경계**는 바로 **서비스**다.
- 서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 **시스템 호출**을 통해 구동된다.
- 서비스는 자신의 **물리적인 위치**에 구애받지 않는다.
  - 서로 통신하는 두 **서비스는** 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수도 있고, 아닐 수도 있다.
- 서비스들은 모든 통신이 **네트워크**를 통해 이뤄진다고 가정한다.
  - 즉, 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 **느리다**.
  - 따라서 가능하다면 **빈번하게 통신** 하는 일을 피해야 한다.
  - 이 수준의 통신에서는 **지연(Latency)** 에 따른 문제를 고수준에서 처리할 수 **있어야 한다**.
