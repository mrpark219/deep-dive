# LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)

## 1. 리스코프 치환 원칙

> S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.

## 2. 상속을 사용하도록 가이드하기

- **Billing**이라는 애플리케이션에서 `License` 클래스의 `calcFee()`라는 메서드를 호출하고 있다.
- `License` 클래스를 상속하는 `PersonalLicense`와 `BusinessLicense` 하위 타입이 존재한다고 할 때, 이 설계는 **LSP를 준수**한다.
  - Billing 애플리케이션의 행위가 `License` 하위 타입 중 무엇을 사용하는지에 전혀 **의존**하지 않기 때문이다.
  - 즉, 하위 타입은 서로 **치환**할 수 있다.

## 3. 정사각형/직사각형 문제

- LSP를 위반하는 전형적인 문제로는 **정사각형/직사각형(Square/Rectangle)** 문제가 있다.
- `Square`는 `Rectangle`의 하위 타입으로는 **적합하지 않다**.
  - `Rectangle`의 높이와 너비는 서로 **독립적**으로 변경될 수 있는 반면, `Square`의 높이와 너비는 반드시 **함께 변경**되기 때문이다.
- 이런 형태의 LSP 위반을 막기 위한 유일한 방법은 `if` 문 등을 이용해서 `Rectangle`이 실제로는 `Square`인지 확인하는 메커니즘을 **User**에 추가하는 것이다.
  - 하지만 이럴 경우 User의 행위가 사용하는 **타입**에 의존하게 되므로 결국 타입을 서로 **치환**할 수 없다.

## 4. 결론

- LSP는 **아키텍처 수준**까지 확장할 수 있고, 반드시 **확장해야만** 한다.
- **치환 가능성**을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 **별도 메커니즘(예외 처리)** 을 추가해야 할 수 있기 때문이다.
