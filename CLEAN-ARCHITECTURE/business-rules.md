# 업무 규칙

## 1. 업무 규칙 (Business Rules)

- 애플리케이션을 **업무 규칙**과 **플러그인**으로 구분하려면 업무 규칙이 실제로 무엇인지를 잘 이해해야만 한다.
- 업무 규칙은 다음과 같이 정의할 수 있다.
  - **사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차**이다.
  - 컴퓨터 상으로 구현했는지와 상관없이, 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다.
  - 사람이 **수동으로 실행하더라도 그 본질은 변하지 않는다**.
- 이러한 규칙을 **핵심 업무 규칙(Critical Business Rules)** 이라고 부른다.
  - 이 규칙은 사업 자체에 **핵심적**이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 **그대로 존재하기 때문**이다.
  - 핵심 업무 규칙은 보통 **데이터**를 요구한다.
  - 이러한 데이터를 **핵심 업무 데이터(Critical Business Data)** 라고 부른다.
  - 이러한 데이터는 시스템으로 **자동화되지** 않은 경우에도 존재하는 데이터이다.
- **핵심 규칙**과 **핵심 데이터**는 본질적으로 결합되어 있기 **때문에** 객체로 만들 좋은 후보가 된다.
  - 이러한 유형의 객체를 **엔티티(Entity)** 라고 한다.

## 2. 엔티티 (Entities)

- **엔티티**는 컴퓨터 시스템 내부의 객체로서, **핵심 업무 데이터**를 기반으로 동작하는 **핵심 업무 규칙**을 구체화한 것이다.
  - 엔티티 객체는 핵심 업무 데이터를 직접 **포함**하거나, 데이터에 매우 쉽게 **접근**할 수 있다.
  - 엔티티의 인터페이스는 이 데이터를 다루는 **함수(규칙)** 들로 구성된다.
- 이러한 클래스를 생성할 때, **핵심적인 업무 개념**을 구현하는 **소프트웨어**는 한데 모으고, 구축 중인 시스템의 **나머지 모든 고려사항(UI, DB 등)** 과는 철저히 **분리**시킨다.
- 이 클래스는 **업무의 대표자**로서 **독립적**으로 존재한다.
  - 데이터베이스나 사용자 인터페이스에 대한 고려사항들로 인해 **오염되어서는 안 된다**.
  - 시스템의 표현 형식, 데이터 저장 방식, 컴퓨터 배치 방식과도 **무관하다**.
- **엔티티**는 순전히 **업무**에 대한 것이며, 이외의 것은 없다.
- 엔티티를 꼭 **객체지향 클래스**로 만들어야 하는 것은 아니며, **소프트웨어 모듈** 형태로 만들면 된다.

## 3. 유스케이스 (Use Cases)

- 모든 업무 규칙이 엔티티처럼 **순수한 것**은 아니다.
- **자동화된 시스템**이 동작하는 방법을 정의하고 **제약함으로써** 수익을 얻거나 비용을 줄이는 업무 규칙도 존재한다.
- 이러한 규칙은 **자동화된 시스템**의 요소로 존재해야만 **의미가 있으므로** **수동 환경**에서는 사용될 수 없다.
- **유스케이스**는 자동화된 시스템이 **사용되는 방법**을 설명한다.
  - 사용자가 제공해야 하는 **입력**, 사용자에게 보여줄 **출력**, 그리고 해당 출력을 생성하기 위한 **처리 단계**를 기술한다.
  - 엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 **애플리케이션에 특화된 업무 규칙**을 설명한다.
  - 유스케이스는 엔티티 내부의 **핵심 업무 규칙**을 **어떻게**, 그리고 **언제** 호출할지를 명시하는 규칙을 담는다.
- 유스케이스는 **사용자 인터페이스(UI)** 를 기술하지 **않는다**.
  - 인터페이스로 들어오는 데이터와 인터페이스에서 되돌려주는 데이터를 **형식 없이** 명시한다는 점만 뺀다면 말이다.
  - 유스케이스는 시스템이 사용자에게 **어떻게 보이는지**를 설명하지 **않는다**.
  - 이보다는 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 **함수**를 제공한다.
  - 또한 유스케이스는 **입력 데이터**, **출력 데이터**, 유스케이스가 **상호작용**하는 엔티티에 대한 **참조 데이터** 등의 데이터 요소를 포함한다.
- **엔티티**는 자신을 제어하는 **유스케이스**에 대해 **아무것도 알지 못한다**.
  - 이는 **의존성 역전 원칙(DIP)** 을 준수하는 또 다른 예다.
  - 엔티티와 같은 **고수준 개념**은 유스케이스와 같은 **저수준 개념**에 대해 아무것도 알지 못한다.
  - **유스케이스**는 단일 애플리케이션에 **특화**되어 있으며, 따라서 해당 시스템의 **입력과 출력**에 가깝게 위치한다.
  - **엔티티**는 수많은 다양한 애플리케이션에서 사용될 수 있도록 **일반화된 것**이므로, 각 시스템의 입력이나 **출력**에서 더 멀리 떨어져 있다.
  - 엔티티는 유스케이스에 **의존하지 않지만**, 유스케이스는 엔티티에 **의존한다**.

## 4. 요청 및 응답 모델 (Request and Response Models)

- 유스케이스는 **입력 데이터**를 받아서 **출력 데이터**를 생성한다.
- 제대로 구성된 유스케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 **주고받는 방식**(웹, 소켓 등)에 대해서는 전혀 **눈치챌 수 없어야 한다**.
- 유스케이스는 단순한 **요청 데이터 구조**를 입력으로 받아들이고, 단순한 **응답 데이터 구조**를 출력으로 반환한다.
- 요청 및 응답 모델이 **독립적이지 않다면**, 그 모델에 **의존하는** 유스케이스도 결국 해당 모델에 **수반하는 의존성**에 간접적으로 **결합**되어 버린다.
- **엔티티 객체**를 가리키는 참조를 요청 및 응답 데이터 구조에 포함하려는 **유혹**이 있다.
  - 이 둘은 굉장히 많은 데이터를 **공유**하기 때문이다.
  - 하지만 이들의 **목적**이 완전히 다르므로 **분리해야 한다**.
  - 시간이 지나면 두 객체는 **완전히 다른 이유**로 변경될 것이고, 따라서 두 객체를 어떤 식으로든 **함께 묶는 행위**는 **공통 폐쇄 원칙(CCP)** 과 **단일 책임 원칙(SRP)** 을 위배하게 된다.
  - 이를 분리하지 않으면 코드에는 수많은 **떠돌이 데이터(Tramp Data)** 가 만들어지고, 수많은 **조건문**이 추가되어 버린다.
