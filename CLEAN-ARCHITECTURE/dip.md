# DIP: 의존성 역전 원칙 (Dependency Inversion Principle)

## 1. 의존성 역전 원칙

> **유연성이 극대화된 시스템**
> 소스 코드 의존성이 **추상(Abstraction)** 에 의존하며 **구체(Concretion)** 에는 의존하지 않는 시스템이다.

- 자바 같은 **정적 타입 언어**에서는 `use`, `import`, `include` 구문은 오직 **인터페이스**나 **추상 클래스** 같은 추상적인 선언만을 참조해야 한다는 뜻이다.
  - 절대로 **구체적인 대상**에는 의존해서는 안 된다.
- 루비나 파이썬 같은 **동적 타입 언어**에도 동일한 규칙이 적용된다.
  - 소스 코드 의존 관계에서 **구체 모듈**은 참조해서는 안 된다.
  - 하지만 이들 언어의 경우 구체 모듈이 무엇인지를 정의하기가 다소 어렵다.
  - 호출할 함수가 **구현된** 모듈이라면 참조하지 않기가 특히 어렵다.
- 이 아이디어를 현실에서 적용하기에는 상당히 **어렵다**.
  - 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 **의존적**이기 때문이다.
  - 예를 들어 자바의 `String` 구체 클래스 같은 경우, 이를 애써 **추상 클래스로 만들려는** 시도는 현실성이 없다.
  - `String` 클래스는 매우 **안정적**이기 때문에 `String` 클래스가 변경되는 일은 거의 없으며, 있더라도 엄격하게 통제된다.
  - 따라서 **프로그래머**와 아키텍트는 `String` 클래스에서 변덕스러운 변경이 자주 발생하리라고 염려할 필요가 없다.
  - 이러한 이유로 DIP를 논할 때 운영체제나 플랫폼같이 **안정성이 보장된 환경**에 대해서는 무시하는 편이다.
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 **변동성이 큰(Volatile) 구체적인 요소**이다.
  - 그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 **변경될 수밖에 없는 모듈**들이다.

## 2. 안정된 추상화

- **추상 인터페이스**에 변경이 생기면 이를 구체화한 **구현체**들도 따라서 수정해야 한다.
- 반대로 **구체적인 구현체**에 변경이 생기더라도 그 구현체가 구현하는 **인터페이스**는 항상, 좀 더 정확히 말하면 대다수의 경우 변경될 필요가 없다.
  - 따라서 인터페이스는 **구현체보다** 변동성이 낮다.
  - 뛰어난 아키텍트는 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력해야 하며, 이는 소프트웨어 설계의 **기본**이다.
  - 즉, **안정적인 소프트웨어 아키텍처**란 변동성이 큰 구현체에 의존하는 일은 지양하고, **안정된 추상 아키텍처**를 선호하는 아키텍처라는 뜻이다.

### 2.1. 변동성이 큰 구체 클래스를 참조하지 마라

- 대신 **인터페이스**를 참조하라.
- 이 규칙은 정적 타입, 동적 타입 모든 언어에서 적용된다.
- 일반적으로 **추상 팩토리(Abstract Factory)** 를 사용하도록 강제한다.

### 2.2. 변동성이 큰 구체 클래스로부터 파생하지 마라

- 이전 규칙의 **따름 정리**이다.
- 정적 타입 언어에서 **상속**은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.
- 따라서 상속은 아주 **신중하게** 사용해야 한다.

### 2.3. 구체 함수를 오버라이드 하지 마라

- 대체로 **구체 함수**는 **소스 코드 의존성**을 필요로 한다.
- 따라서 구체 함수를 오버라이드하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 **상속**하게 된다.
- 이러한 의존성을 제거하려면, 차라리 **추상 함수**로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.

### 2.4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 마라

- 사실 이 실천법은 **DIP 원칙**을 다른 이름으로 풀어쓴 것이다.

## 3. 팩토리 (Factory)

- 위 규칙들을 준수하려면 **변동성이 큰 구체적인 객체**는 특별히 주의하여 생성해야 한다.
  - `Service s = new ServiceImpl();` 이 코드는 구체 클래스인 `ServiceImpl`에 의존하기 때문에 **DIP 위반**이다.
- 따라서 자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 **추상 팩토리(Abstract Factory)**를 사용하곤 한다.

```java
// [추상 컴포넌트]: 고수준 업무 규칙 (변하지 않는 부분)
interface Service {
    void execute();
}

interface ServiceFactory {
    Service makeService();
}

// [구체 컴포넌트]: 저수준 세부사항 (변동성이 큰 부분)
class ServiceImpl implements Service {
    @Override
    public void execute() {
        System.out.println("실제 업무 로직 수행");
    }
}

class ServiceFactoryImpl implements ServiceFactory {
    @Override
    public Service makeService() {
        // 구체적인 클래스 생성은 오직 이곳(구체 컴포넌트 영역)에서만 발생
        return new ServiceImpl();
    }
}

// [애플리케이션 로직]
public class Application {
    private final ServiceFactory factory;

    public Application(ServiceFactory factory) {
        // Application은 오직 인터페이스(ServiceFactory)에만 의존함
        this.factory = factory;
    }

    public void run() {
        Service s = factory.makeService();
        s.execute();
    }
}
```

- 위 코드에서 **제어 흐름**은 `Application` -> `ServiceFactoryImpl` -> `ServiceImpl` 순서로 흐른다.
  - **소스 코드의 의존성**은 `Application`, `ServiceImpl`, `ServiceFactoryImpl` 모두 추상 인터페이스인 `Service`와 `ServiceFactory`를 향한다.
- **추상 컴포넌트**는 애플리케이션의 모든 **고수준 업무 규칙**을 포함하고, **구체 컴포넌트**는 업무 규칙을 다루기 위해 필요한 모든 **세부사항**을 포함한다.
  - **제어 흐름**은 소스 코드 의존성과는 **정반대 방향**으로 흐른다.
  - 다시 말해 **소스 코드 의존성**은 제어 흐름과는 반대 방향으로 **역전**된다.
  - 이러한 이유로 **의존성 역전(Dependency Inversion)** 이라고 부른다.

## 4. 구체 컴포넌트

- DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수의 **구체 컴포넌트** 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 **분리**할 수 있다.
- 대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다.
- 흔히 이 컴포넌트를 **Main**이라고 부르는데, `main` 함수를 포함하기 때문이다.

## 5. 결론

- DIP를 **적용**하면 결국 **변하는 것**으로부터 **변하지 않는 것**을 보호하는 것이다.
- 이를 통해 **유연성**을 확보하고, **결합도**를 낮출 수 있다.
- **또한**, **추상 팩토리**와 **Main 컴포넌트**를 통해 시스템을 잘 변하지 않는 **추상 영역**과 잘 변하는 **구체 영역**으로 아키텍처의 **경계**를 나눌 수 있다.
