# 컴포넌트

## 1. 컴포넌트

- **컴포넌트**는 **배포 단위**이다.
- 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 **가장 작은 단위**이다.
  - 자바의 경우 `.jar` 파일, 루비의 경우 `.gem` 파일이다.
- **컴파일형 언어**에서 컴포넌트는 **바이너리 파일**의 결합체이다.
- **인터프리터형 언어**의 경우 **소스 파일**의 결합체이다.
- 여러 컴포넌트를 서로 **링크**하여 실행 가능한 **단일 파일**로 생성할 수 있다.
  - 또는 여러 컴포넌트를 서로 묶어서 `.war` 파일과 같은 **단일 아카이브**로 만들 수도 있다.
- 또는 컴포넌트 각각을 `.jar`나 `.dll` 같이 동적으로 로드할 수 있는 **플러그인**이나 `.exe` 파일로 만들어서 **독립적으로 배포**할 수도 있다.
- 컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 **독립적으로 배포 가능한**, 따라서 **독립적으로 개발 가능한** 능력을 갖춰야 한다.

## 2. 컴포넌트의 역사

- 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 **직접 제어**했다.
- 프로그램의 시작부에는 프로그램이 로드될 주소를 선언하는 **오리진(Origin) 구문**이 나와야 했다.
  - 즉, 프로그래밍 초창기에는 프로그램을 로드할 **메모리의 위치**를 정하는 일이 프로그래머가 가장 먼저 **결정해야** 하는 사항 중 하나였다.
  - 또한, **재배치**가 불가능했다.
- 이러한 구시대에는 라이브러리 함수에 접근하기 위해서는 프로그래머가 라이브러리 함수의 **소스 코드**를 애플리케이션 코드에 직접 포함시켜 **단일 프로그램**으로 컴파일했다.
  - 라이브러리는 바이너리가 아니라 **소스 코드 형태**로 유지되었다.
- 이 시대에는 장치가 느리고 메모리 용량이 작았기 때문에 소스 코드 전체를 메모리에 **상주**시킬 수 없었다.
  - 결국 컴파일러는 느린 장치를 이용해서 소스 코드를 **여러 차례** 읽어야 했다.
- 컴파일 시간을 단축하기 위해 프로그래머는 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 **분리**했다.
  - 함수 라이브러리를 **개별적**으로 컴파일하고, 컴파일된 바이너리를 메모리의 **특정 위치**에 로드했다.
  - 함수 라이브러리에 대한 **심벌 테이블**을 생성한 후, 이를 이용해 애플리케이션 코드를 컴파일했다.
- 메모리의 주소로 지정을 하다 보니 애플리케이션 사이즈가 커졌을 때, 애플리케이션을 **2개의 주소 세그먼트**로 분리하여 함수 라이브러리 공간을 사이에 두고 오가며 동작하게 배치를 해야 하는 경우가 **발생했다**.

## 3. 재배치성 (Relocatability)

- 위와 같은 문제를 해결하기 위해서는 **재배치가 가능한 바이너리**가 필요했다.
  - **지능적인 로더**를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이었다.
  - 이때 로더는 **재배치 코드**가 자리할 위치 정보를 전달받았다.
  - 그리고 재배치 코드에는 로드한 데이터에서 어느 부분을 수정해야 정해진 주소에 로드할 수 있는지를 알려주는 **플래그**가 **삽입되었다**.
  - 대개 이러한 플래그는 바이너리에서 참조하는 메모리의 **시작 주소**였다.
- 이제 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 **지시**할 수 있게 되었다.
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 **메타데이터 형태**로 생성하도록 수정되었다.
- 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 **외부 참조(External Reference)** 로 생성했다.
- 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 **외부 정의(External Definition)** 로 생성했다.
  - 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 **링크**시킬 수 있게 된다.
- 이렇게 **링킹 로더(Linking Loader)** 가 탄생했다.

## 4. 링커 (Linker)

- **링킹 로더**의 등장으로 프로그래머는 프로그램을 **개별적**으로 컴파일하고 로드할 수 있는 단위로 **분할**할 수 있게 되었다.
  - 하지만 프로그램이 커지게 되면서 링킹 로더가 너무 **느려지게** 되었다.
  - 함수 라이브러리는 **자기 테이프**와 같은 느린 장치에 저장되었다.
- 이를 극복하기 위해 **로드**와 **링크**가 두 단계로 **분리**되었다.
  - 프로그래머는 느린 부분, 즉 **링크 과정**을 맡았는데 **링커(Linker)** 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다.
  - 링커는 링크가 완료된 **재배치 코드**를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 **빨라졌다**.
  - 비록 느린 링커를 사용해서 실행 파일을 만들었지만, 한 번 만들어둔 실행 파일은 언제라도 빠르게 **로드**할 수 있게 되었다.

## 5. 오늘날

- 오늘날에는 디스크의 속도와 메모리의 용량 등 컴퓨터의 성능이 **비약적으로 발전**하게 되었고, 따라서 **링크 시간**이 엄청나게 줄었다.
- 컴퓨터와 장치가 빨라져서 또다시 **로드와 링크**를 **동시에** 할 수 **있게 되면서**, 다수의 `.jar` 파일 또는 다수의 **공유 라이브러리**를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 **실행**할 수 있게 되었다.
- 이렇게 **컴포넌트 플러그인 아키텍처**가 탄생했다.

## 6. 결론

- 런타임에 **플러그인 형태**로 결합할 수 있는 **동적 링크 파일**이 소프트웨어 **컴포넌트**에 해당한다.
- 여기까지 약 **50년**의 시간이 걸렸다.
- 과거에는 초인적인 노력을 통해 컴포넌트 플러그인 아키텍처를 적용할 수 있었지만, 지금은 쉽게 **적용할** 수 있게 되었다.
