# 클린 아키텍처

## 1. 클린 아키텍처

![http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](./images/the-clean-architecture/2026-02-19-07-10-26.png)

- **헥사고날 아키텍처(Hexagonal Architecture, 포트와 어댑터)**, DCI, BCE 등 많은 시스템 아키텍처가 있다.
  - 이들의 공통적인 목표는 **관심사의 분리(Separation of Concerns)** 이다.
  - 이들 모두 소프트웨어를 **계층으로 분리**함으로써 관심사의 분리라는 목표를 달성하였다.
  - 각 아키텍처는 최소한 **업무 규칙**을 위한 계층 하나와 **사용자**와 **시스템 인터페이스**를 위한 또 다른 계층 하나를 반드시 포함한다.
- 클린 아키텍처는 아래와 같은 **5가지 특징**을 가진다.
  1.  **프레임워크 독립성**: 아키텍처는 다양한 기능의 라이브러리를 제공하는 소프트웨어, 즉 **프레임워크의 존재 여부**에 의존하지 않는다. 이를 통해 프레임워크를 **도구**로 사용할 수 있으며, 프레임워크의 제약사항 안으로 시스템을 욱여넣도록 **강제하지 않는다**.
  2.  **테스트 용이성**: **업무 규칙**은 UI, 데이터베이스, 웹 서버 또는 여타 외부 요소가 없이도 **테스트**할 수 있다.
  3.  **UI 독립성**: 시스템의 나머지 부분을 변경하지 **않고도** UI를 쉽게 변경할 수 있다. 예를 들어 업무 규칙을 변경하지 않은 채 **웹 UI**를 **콘솔 UI**로 대체할 수 있다.
  4.  **데이터베이스 독립성**: **업무 규칙**은 데이터베이스와 **결합되지 않는다**.
  5.  **모든 외부 에이전시에 대한 독립성**: 실제로 **업무 규칙**은 외부 세계와의 **인터페이스**에 대해 전혀 알지 못한다.

## 2. 의존성 규칙 (The Dependency Rule)

- 위 그림에서 각각의 동심원은 소프트웨어에서 서로 다른 **영역**을 표현한다.
- 보통 **안**으로 들어갈수록 **고수준**의 소프트웨어가 된다.
- **바깥쪽 원**은 **메커니즘**이고, **안쪽 원**은 **정책**이다.
- 이러한 아키텍처가 동작하도록 하는 가장 **주요한 규칙**은 **의존성 규칙**이다.
  - **소스 코드 의존성**은 반드시 **안쪽**으로, **고수준의 정책**을 향해야 한다.

### 2.1. 엔티티 (Entities)

- **엔티티**는 **전사적인 핵심 업무 규칙**을 캡슐화한다.
- 엔티티는 메서드를 가지는 **객체**이거나, 일련의 **데이터 구조와 함수의 집합**일 수도 있다.
- 기업의 다양한 애플리케이션에서 엔티티를 **재사용**할 수 있다면, 그 형태는 중요하지 않다.
- 전사적이지 않은 단순한 **단일 애플리케이션**을 작성하고 있다면 엔티티는 해당 애플리케이션의 **업무 객체**가 된다.
  - 이 경우 엔티티는 가장 **일반적**이며 **고수준인 규칙**을 캡슐화한다.
- 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 **엔티티 계층**에는 절대로 영향을 주어서는 **안 된다**.

### 2.2. 유스케이스 (Use Cases)

- **유스케이스** 계층의 소프트웨어는 **애플리케이션에 특화된 업무 규칙**을 포함한다.
- 또한 유스케이스 계층의 소프트웨어는 시스템의 **모든 유스케이스**를 캡슐화하고 **구현한다**.
- 유스케이스는 엔티티로 들어오고 나가는 **데이터 흐름**을 조정하며, 엔티티가 자신의 **핵심 업무 규칙**을 사용해서 유스케이스의 목적을 이룰 수 있도록 이끈다.
- 이 계층에서 발생한 변경이 **엔티티**에 영향을 줘서는 **안 된다**.
  - 또한, 데이터베이스, UI 등의 **외부 요소**에서 발생한 변경이 이 계층에 영향을 줘서도 **안 된다**.
- 하지만 **운영 관점**에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 따라서 이 계층의 소프트웨어에도 영향을 줄 것이다.
  - 유스케이스의 **세부 사항**이 변하면 이 계층의 코드 일부는 분명히 영향을 받는다.

### 2.3. 인터페이스 어댑터 (Interface Adapters)

- **인터페이스 어댑터** 계층은 일련의 **어댑터**들로 구성된다.
- 어댑터는 데이터를 **유스케이스와 엔티티**에 가장 편리한 형식에서, 데이터베이스나 웹 같은 **외부 에이전시**에게 가장 편리한 방식으로 **변환**한다.
  - **프레젠터(Presenter), 뷰(View), 컨트롤러(Controller)** 는 모두 인터페이스 어댑터 계층에 속한다.
  - **모델(Model)** 은 그저 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아간다.
- 이 계층은 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서, **영속성**용으로 사용 중인 임의의 **프레임워크**가 이용하기 가장 편리한 형식으로 변환한다.
- 이 원 안에 속한 어떤 코드도 **데이터베이스**에 대해 조금도 알아서는 **안 된다**.
  - SQL 기반의 데이터베이스를 사용한다면 **모든 SQL**은 이 계층을 벗어나서는 안 된다.
- 또한, 이 계층에서 데이터를 외부 서비스와 같은 **외부적인 형식**에서 유스케이스나 엔티티에서 사용되는 **내부적인 형식**으로 변환하는 또 다른 어댑터가 필요하다.

### 2.4. 프레임워크와 드라이버 (Frameworks and Drivers)

- **가장 바깥쪽 계층**은 일반적으로 데이터베이스나 웹 프레임워크 같은 **프레임워크**나 **도구**들로 구성된다.
- 일반적으로 이 계층에서는 안쪽 원과 통신하기 위한 **접합 코드** 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다.
- **모든 세부사항**이 위치하는 곳이다.

### 2.5. 원은 네 개여야만 하나?

- 원의 개수가 중요한 것이 아니라 **어떠한 경우에도 의존성 규칙이 적용된다**는 것이 중요하다.
- **소스 코드 의존성**은 항상 **안쪽**을 향한다.
  - 안쪽으로 이동할수록 **추상화**와 **정책의 수준**이 높아진다.
  - 가장 바깥쪽 원은 **저수준**의 구체적인 세부사항으로 구성된다.
  - 그리고 안쪽으로 이동할수록 소프트웨어는 점점 **추상화**되고 **더 높은 수준**의 정책들을 캡슐화한다.
  - 따라서 **가장 안쪽 원**은 가장 **범용적**이며 **높은 수준**을 가진다.

### 2.6. 경계 횡단하기

- 위 그림에서 우측 하단에는 원의 **경계를 횡단하는 방법**을 보여준다.
- **제어 흐름**은 컨트롤러에서 시작해서, 유스케이스를 지난 후, 프레젠터에서 실행되면서 마무리된다.
- **소스 코드 의존성**은 유스케이스를 향해 **안쪽**을 가리킨다.
- 이처럼 **제어 흐름**과 **의존성의 방향**이 명백히 **반대**여야 하는 경우, 대체로 **의존성 역전 원칙(DIP)** 을 사용하여 해결한다.
- 자바 같은 언어에서는 **인터페이스**와 **상속 관계**를 적절하게 배치함으로써, 제어 흐름이 경계를 가로지르는 바로 그 **지점에서** 소스 코드 의존성을 제어 흐름과는 **반대**가 되게 만들 수 있다.
- 예를 들어 유스케이스에서 **프레젠터**를 호출해야 한다고 가정해 보자.
  - 이때 **직접 호출**해서는 안 되는데, 직접 호출해 버리면 **의존성 규칙**을 위배하기 때문이다(내부 -> 외부).
  - 따라서 유스케이스가 **내부 원의 인터페이스**를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 **구현**하도록 만들어야 한다.

### 2.7. 경계를 횡단하는 데이터는 어떤 모습인가

- 경계를 가로지르는 데이터는 흔히 **간단한 데이터 구조**로 이루어져 있다.
- 기본적인 구조체나 간단한 **데이터 전송 객체(DTO)** 등 원하는 대로 고를 수 있다.
- **격리되어 있는** 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실이다.
- **엔티티 객체**나 **데이터베이스의 행(Row)** 을 전달하는 일은 원치 않는다.
- 데이터 구조가 어떤 의존성을 가져 **의존성 규칙을 위배**하게 되는 일은 바라지 않는다.
  - 내부 원에서 외부 원의 무언가를 알아야 하기 때문이다.
  - 따라서 경계를 가로질러 데이터를 전달할 때, **데이터는** 항상 **내부 원**에서 사용하기에 **가장 편리한 형태**를 가져야 한다.
