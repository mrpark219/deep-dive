# 프레전터와 험블 객체

## 1. 험블 객체 패턴 (Humble Object Pattern)

- **험블 객체 패턴**은 디자인 패턴으로, **테스트하기 어려운 행위**와 **테스트하기 쉬운 행위**를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- 행위들을 두 개의 모듈 또는 클래스로 나눈다.
  - 이들 모듈 중 하나가 **험블(Humble)** 이다.
  - 가장 기본적인 본질은 남기고, **테스트하기 어려운 행위**를 모두 험블 객체로 옮긴다.
  - 나머지 모듈에는 험블 객체에 속하지 않은, **테스트하기 쉬운 행위**를 모두 옮긴다.
- 예를 들어 **GUI**의 경우 단위 테스트가 어려운데, 화면을 보면서 각 요소가 필요한 위치에 적절히 표시되었는지 검사하는 테스트는 작성하기 매우 어렵기 때문이다.
- 하지만 GUI에서 수행하는 행위의 대다수는 **쉽게 테스트**할 수 있다.
- 험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 **프레젠터(Presenter)** 와 **뷰(View)** 라는 서로 다른 클래스로 만들 수 있다.

## 2. 프레젠터와 뷰

- **뷰(View)** 는 **험블 객체**이고, 테스트하기 어렵다.
  - 이 객체에 포함된 코드는 가능한 한 **간단하게** 유지한다.
  - 뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 **처리하지는 않는다**.
- **프레젠터(Presenter)** 는 **테스트하기 쉬운 객체**다.
  - 프레젠터의 역할은 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 **포맷**으로 만드는 것이다.
  - 이를 통해 뷰는 데이터를 화면으로 전달하는 **간단한 일**만 처리하도록 만든다.
- 예를 들어 애플리케이션에서 어떤 필드에 **날짜**를 표시하고자 한다면,
  1.  애플리케이션은 프레젠터에 `Data` 객체를 전달한다.
  2.  그러면 프레젠터는 해당 데이터를 **적절한 포맷**의 문자열로 만들고, 이 문자열을 **뷰 모델(View Model)** 이라고 부르는 간단한 데이터 구조에 **담는다**.
  3.  그러면 뷰는 뷰 모델에서 이 데이터를 찾는다.

## 3. 테스트와 아키텍처

- **테스트 용이성**은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다.
- **험블 객체 패턴**이 좋은 예인데, 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 **아키텍처 경계**가 정의되기 때문이다.
- **프레젠터와 뷰** 사이의 경계는 이러한 경계 중 하나이며, 수많은 경계가 존재한다.

## 4. 데이터베이스 게이트웨이

- **유스케이스 인터랙터**와 **데이터베이스** 사이에는 **데이터베이스 게이트웨이**가 위치한다.
- 이 게이트웨이는 **다형적 인터페이스**로, 애플리케이션이 데이터베이스에 수행하는 CRUD와 관련된 모든 메서드를 포함한다.
- 유스케이스 계층은 **SQL을 허용하지 않는다**.
  - 따라서 유스케이스 계층은 필요한 메서드를 제공하는 **게이트웨이 인터페이스**를 호출한다.
- 그리고 인터페이스의 **구현체**는 **데이터베이스 계층**에 위치한다.
  - **이 구현체는 험블 객체다.**
  - 구현체에서 직접 SQL을 사용하거나 데이터베이스에 대한 임의의 인터페이스를 통해 게이트웨이의 메서드에서 필요한 데이터에 접근한다.
- 이와 달리 **인터랙터**는 애플리케이션에 특화된 **업무 규칙**을 캡슐화하기 때문에 험블 객체가 **아니다**.
  - 따라서 **테스트하기 쉬운데**, 게이트웨이는 **스텁(Stub)** 이나 **테스트 더블**로 적당히 교체할 수 있기 때문이다.

## 5. 데이터 매퍼 (Data Mappers)

- 사실 **객체 관계 매퍼(ORM)** 같은 것은 존재하지 않는다.
  - **객체**는 데이터 구조가 아니기 때문이다.
  - 최소한 객체를 사용하는 사람 관점에서 객체는 데이터 구조가 아니다.
  - 데이터는 모두 `private`으로 선언되므로 객체의 사용자는 데이터를 볼 수 없다. 사용자는 객체에서 `public` 메서드만 볼 수 있다.
- 따라서 사용자 관점에서 볼 때 객체는 단순히 **오퍼레이션의 집합**이다.
- 객체와 달리 **데이터 구조**는 함축된 행위를 가지지 않는 `public` **데이터 변수**의 집합이다.
- ORM보다는 차라리 **데이터 매퍼**라고 부르는 편이 나아 보인다.
  - 관계형 데이터 테이블로부터 가져온 데이터를 **데이터 구조**에 맞게 담아주기 때문이다.
- 이러한 ORM 시스템은 어디에 위치해야 하는가? 물론 **데이터베이스 계층**이다.
- ORM은 **게이트웨이 인터페이스**와 **데이터베이스** 사이에서 일종의 또 다른 **험블 객체 경계**를 형성한다.

## 6. 서비스 리스너 (Service Listeners)

- 애플리케이션이 **다른 서비스**와 반드시 통신해야 한다면, 또는 애플리케이션에서 일련의 서비스를 제공해야 한다면, 우리는 여기에서 서비스 경계를 생성하는 **험블 객체 패턴**을 확인할 수 있다.
- 애플리케이션은 데이터를 간단한 **데이터 구조** 형태로 로드한다.
  - 이후 이 데이터 구조를 경계를 가로질러 **특정 모듈**로 전달한다.
  - 그러면 **해당 모듈**은 데이터를 **적절한 포맷**으로 만들어서 외부 서비스로 전송한다.
- 반대로 **외부**로부터 데이터를 수신하는 **서비스**의 경우,
  - **서비스 리스너**가 **서비스 인터페이스**로부터 데이터를 수신하고, 데이터를 애플리케이션에서 사용할 수 있게 간단한 **데이터 구조**로 포맷을 변경한다.
