# 객체 지향 프로그래밍 (Object-Oriented Programming)

## 1. 캡슐화 (Encapsulation)

> **남에게 보여줄 필요 없는 건 숨겨라**

- 데이터와 함수를 쉽고 **효과적**으로 캡슐화하는 방법을 객체 지향 언어가 제공한다.
- 이를 통해 데이터와 함수가 **응집력** 있게 구성된 집단을 서로 구분 짓는 **선**을 그을 수 있다.
- 구분선 바깥에서 데이터는 **은닉**되고, 일부 함수만이 외부에 **노출**된다.
  - 이 개념들이 실제 OO 언어에서는 각각 클래스의 **private** 멤버 데이터와 **public** 멤버 함수로 표현된다.
- 과거 **C언어**를 사용하던 시절에는 `.h` 헤더 파일과 `.c` 소스 파일을 구분함으로써 **완벽한 캡슐화**를 제공하였다.
  - 외부에서 코드를 사용할 때는 `.h` 파일에 명시된 것만 알 수 있었고, 해당 파일에는 데이터의 구조 즉 **멤버 변수**를 알 수 없었다.
  - 하지만 OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 **캡슐화**된 데이터를 **우회**해서 사용하지 않을 거라는 **믿음**을 기반으로 한다.
    - Java나 C++ 같은 OO 언어는 클래스 내부에 `private` 변수가 선언된 것이 눈에 보이고, 단지 컴파일러가 사용하지 못하게 막아줄 뿐이다.

## 2. 상속 (Inheritance)

> **굳이 똑같은 걸 또 만들지 마라**

- OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, **상속**만큼은 OO 언어가 확실히 제공했다.
- 상속은 단순히 변수와 함수를 하나의 **유효 범위(Scope)** 로 묶어 관리하고, 이를 필요에 따라 **재정의(Override)** 하는 메커니즘이다.
- OO 언어 이전에도 **상속**이 존재했다.
  - C언어에서는 자식 구조체의 메모리 시작 부분에 부모 구조체의 멤버들을 **수동**으로 똑같이 배치하는 작업이 필요했다.
  - 자식을 부모처럼 다루기 위해 포인터 타입을 강제로 바꾸는 **명시적 업캐스팅**을 매번 수행해야 했으며, 이는 메모리 오염이나 **런타임 에러** 같은 실수의 위험이 컸다.
- 상속의 진정한 가치는 자식이 **부모인 척**할 수 있게 만드는 것이며, 이를 통해 프로그램의 **유연성**을 확보하는 것이다.
  - 과거에는 개발자가 직접 메모리를 조작하며 **고군분투**했다면, 이제는 언어의 기능을 통해 훨씬 편리하고 안전하게 **부모의 가면**을 씌울 수 있게 되었다.
  - 이 가면 덕분에 호출하는 **쪽**에서는 실제 객체가 무엇인지 몰라도 **부모의 인터페이스**만 보고 소통할 수 있다.

## 3. 다형성 (Polymorphism)

> **내부 구현은 달라도 겉모습(인터페이스)은 통일해라**

- OO 언어가 있기 전에도 **다형성**은 존재했다.
- C언어에서 **함수 포인터(Function Pointer)** 를 응용한 것이 바로 다형성의 시초이다.
  - 보통 변수에는 숫자나 문자가 담기지만, C언어는 변수에 **함수가 저장된 메모리 주소**를 담을 수 있었다.
  - 예: `운전()`이라는 포인터 변수에 `소나타_운전_함수`의 주소를 넣으면 소나타가 움직이고, `트럭_운전_함수`의 주소를 넣으면 트럭이 움직인다.
  - 즉, 호출하는 쪽에서는 똑같이 `운전()`을 호출하지만, 그 포인터가 가리키는 대상에 따라 **실행 결과**가 달라진다. 이것이 다형성의 본질이다.
- 하지만 함수 포인터를 직접 사용하는 방식은 매우 **위험**하다.
  - 프로그래머가 이 연결 작업을 **수동**으로 해야 하기 때문이다.
  - 만약 실수로 함수의 주소를 잘못 적거나 초기화를 깜빡하면, 프로그램은 엉뚱한 메모리를 참조하여 **비정상 종료(Crash)** 된다. 찾기도 힘든 버그가 된다.
- OO 언어는 다형성을 제공하지는 못했지만, 좀 더 **안전**하고 더욱 **편리**하게 사용할 수 **있게** 해준다.

## 4. 다형성이 가진 힘

- 과거에는 프로그램에 새로운 기능을 추가하려면 **전체** 프로그램을 뜯어고치고 다시 만들어야 했다.
  - **USB**를 예로 들면, 컴퓨터 본체(고수준 정책)에 마우스를 꽂든, 키보드를 꽂든(저수준 세부사항) 컴퓨터는 상관하지 않고, **USB 규격(인터페이스)** 만 맞으면 된다.
  - 여기서 마우스, 키보드가 바로 **플러그인**이다.
  - OO의 다형성 덕분에, 본체 소스코드를 전혀 수정하지 않고도 새로운 장치(플러그인)를 언제든 갈아 끼울 수 있다.
- **플러그인 아키텍처**는 입출력 장치 **독립성**을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 **구현**되었다.
- 그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 **가리키는 포인터**를 사용하면 **위험**을 수반하기 때문이다.
- 그러나 OO의 등장으로 언제 어디서든 **플러그인 아키텍처**를 구현할 수 있게 되었다.

## 5. 의존성 역전 (Dependency Inversion)

- 보통의 프로그램은 `Main(고수준) -> 호출 -> 데이터베이스 모듈`의 구조이다. 즉, **제어 흐름**이 Main에서 DB로 가며 **소스 코드 의존성** 또한 Main이 DB를 알아야 한다.
  - 이 경우 DB가 변경될 경우 Main의 소스 코드도 변경해야 한다.
- OO를 통해 의존성 역전을 하게 되면 중간에 **인터페이스**를 둔다.
  - `Main -> 호출 -> 인터페이스 <- 데이터베이스 모듈`
    - Main은 **데이터 저장소**라는 인터페이스만 바라보고 호출한다.
    - 실제 DB 모듈은 그 인터페이스를 **상속(구현)** 한다.
    - **제어 흐름**: Main이 DB를 사용한다(그대로이다).
    - **소스 코드 의존성**: DB 모듈이 인터페이스(Main) 쪽을 바라보고 있다.
    - 화살표의 방향이 **반대(역전)** 가 되었다.
- 다형성을 안전하고 편안하게 적용할 수 있는 **메커니즘**이 없었을 때 전형적인 호출 트리의 경우 **소스 코드의 의존성** 방향은 반드시 **제어 흐름(Flow of Control)** 을 따를 수 밖에 없었다.
- OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 **소스 코드 의존성**을 어디에서든 **역전**할 수 있다는 것이다.
- 소스 코드 의존성은 소스 코드 사이에 **인터페이스**를 추가함으로써 방향을 역전시킬 수 있다.
  - 즉, 소스 코드 의존성이 제어 흐름의 방향과 일치되도록 **제한**하지 않는다.

## 6. 결론

- **OO**란 **다형성**을 이용하여 전체 시스템의 모든 **소스 코드 의존성**에 대한 **절대적인 제어 권한**을 획득할 수 있는 능력이다.
- OO를 사용하면 아키텍트는 **플러그인 아키텍처**를 구성할 수 있다.
  - 이를 통해 **고수준의 정책**을 포함하는 모듈은 **저수준의 세부사항**을 포함하는 모듈에 대해 **독립성**을 보장할 수 있다.
- 저수준의 세부사항은 중요도가 낮은 **플러그인 모듈**로 만들 수 있고, 고수준의 정책을 포함하는 **모듈**과는 **독립적**으로 개발하고 배포할 수 있다.
