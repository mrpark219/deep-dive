# 아키텍처란?

## 1. 아키텍처

> **아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.**

- **소프트웨어 아키텍트**는 최고의 프로그래머이며, 앞으로도 **계속** 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이 **생산성**을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다.
  - 소프트웨어 아키텍트는 다른 프로그래머만큼 코드를 많이 작성하지 않을 수도 있지만, **프로그래밍 작업**에는 지속적으로 참여한다.
  - 프로그래밍 작업을 계속하는 이유는 발생하는 문제를 **경험**해 보지 않는다면 다른 프로그래머를 지원하는 작업을 제대로 할 수 없기 때문이다.
- 소프트웨어 시스템의 **아키텍처**란 시스템을 구축했던 사람들이 만들어낸 시스템의 **형태**이다.
- 그 모양은 시스템을 **컴포넌트**로 분할하는 방법, 분할된 컴포넌트를 **배치**하는 방법, 컴포넌트가 서로 **의사소통**하는 방식에 따라 정해진다.
- 그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 **쉽게** 개발, 배포, 운영, 유지보수 되도록 만들어진다.
  - 이러한 일을 용이하게 만들기 위해서는 가능한 **많은 선택지**를, 가능한 한 **오래** 남겨두는 전략을 따라야 한다.
- 아키텍처의 주된 목적은 시스템의 **생명주기**를 **지원하는** 것이다.
  - 좋은 아키텍처는 시스템을 쉽게 **이해**하고, 쉽게 **개발**하며, 쉽게 **유지보수**하고, 또 쉽게 **배포**하게 해준다.

## 2. 개발

- 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.
- 따라서 시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 **뒷받침**해야 한다.
- 팀의 **인원수** 및 **구조**에 따라 아키텍처 관련 결정도 차이가 **난다**.

## 3. 배포

- 소프트웨어 시스템이 사용될 수 있으려면 반드시 **배포**할 수 있어야 한다.
- 배포 비용이 높을수록 시스템의 **유용성**은 떨어진다.
  - 따라서 소프트웨어 아키텍처는 시스템을 **단 한 번에** 쉽게 배포할 수 있도록 **만드는** 데 그 목표를 두어야 한다.
- 보통 초기 개발 단계에서는 배포 전략을 고려하지 않기 **때문에** 개발은 쉽지만 배포는 어려운 **아키텍처**가 만들어질 가능성이 높다.
- 이를 위해 초기부터 배포에 대한 생각을 하는 것이 좋다.

## 4. 운영

- 아키텍처가 시스템 **운영**에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜 극적이다.
- 운영에서 겪는 **대다수**의 어려움은 소프트웨어 아키텍처에는 극적인 영향을 주지 않고도 단순히 **하드웨어**를 더 투입해서 해결할 수 있다.
- 좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 **요구**도 알려준다.
  - 시스템 아키텍처가 개발자에게 시스템의 **운영 방식**을 잘 드러내 준다.
  - 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 **일급(First-class) 엔티티**로 격상시키고, 이들 요소가 개발자에게 주요 목표로 **인식되도록** 해야 **한다**.
  - 이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 **도움이 된다**.

## 5. 유지보수

- 유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 **비용이 가장 많이 든다**.
- 새로운 기능은 끝도 없이 발생하고, 뒤따라서 발생하는 결함은 피할 수 없으며 결함을 수정하는 데도 엄청난 인적 자원이 소모된다.
- 유지보수의 가장 큰 비용은 **탐사(Spelunking)** 와 이로 인한 **위험부담**에 있다.
- 탐사란 기존 소프트웨어에 **새로운 기능을 추가하거나 결함을 수정할 때**, 소프트웨어를 파헤쳐서 **어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는 게 최적일지를 결정**할 때 드는 비용이다.
- 이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로 인한 위험 부담 비용이 추가된다.
- 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다.
  - 시스템을 **컴포넌트**로 분리하고, **안정된 인터페이스**를 두어 격리하는 식이다.

## 6. 선택사항 열어두기

- 소프트웨어는 두 종류의 가치, 즉 **행위적 가치**와 **구조적 가치**를 지닌다.
- 이중 **구조적 가치**가 더 중요한데, 소프트웨어를 부드럽게 만드는 것은 바로 이 구조적 가치이기 때문이다.
- 소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 **변경**하는 방법이 필요했기 때문이고, 이러한 **유연성**은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 **의존한다**.
- 소프트웨어를 부드럽게 유지하는 방법은 **선택사항**을 가능한 한 많이, 그리고 가능한 한 오랫동안 **열어두는 것**이다.
  - 이때 열어두어야 할 선택사항은 중요치 않은 **세부사항**이다.
- 모든 소프트웨어는 **정책**과 **세부사항**으로 분해할 수 있다.
  - **정책**은 모든 업무 규칙과 업무 절차를 **구체화**한다.
  - **세부사항**은 사람, 외부 시스템, 프로그래머가 정책과 소통할 **때** 필요한 요소지만, 정책이 가진 행위에는 **조금도** 영향을 미치지 않는다.
    - 입출력 장치, 데이터베이스, 웹 시스템 등이 있다.
- **아키텍트**의 목표는 시스템에서 **정책**을 가장 핵심적인 요소로 식별하고, 동시에 **세부사항**은 정책에 **무관하게** 만들 수 있는 형태의 시스템을 구축하는 것이다.
  - 이를 통해 세부사항을 결정하는 일은 **미루거나 연기**할 수 있게 된다.
- 예를 들어 개발 초기에는 **데이터베이스 시스템**을 선택할 필요가 없다. 고수준의 정책은 어떤 데이터베이스를 사용하는지 **신경 써서는 안 된다**.
- 이러한 결정을 더 오래 참을 수 있다면 더 많은 정보를 가지고 **제대로 된 결정**을 내릴 수 있다.
- 좋은 아키텍트는 **결정되지 않은 사항**의 수를 **최대화**한다.

## 7. 장치 독립성

- 과거에는 코드를 **입출력 장치**와 결합하여 사용했었다. 이러한 코드는 **장치 종속적**이다.
- 장치 종속적인 코드는 장치가 변경되면 같이 **변경**되어야 했다.
- 오늘날의 **운영체제**는 입출력 장치를 **소프트웨어 함수**로 **추상화**했고, 이를 통해 동일한 프로그램을 아무런 **변경 없이도** 사용할 수 있게 되었다.
- **개방-폐쇄 원칙(OCP)** 이 탄생한 순간이였다.
