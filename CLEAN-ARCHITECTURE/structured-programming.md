# 구조적 프로그래밍

## 1. 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 **증명 가능**한 더 작은 단위로 **재귀적**으로 분해할 수 있게 되었고, 이는 결국 모듈을 **기능적**으로 분해할 수 있음을 뜻한다.
- 거대한 문제 기술서를 받더라도 문제를 **고수준의 기능**들로 분해할 수 있다.
  - 이들 각 기능은 다시 **저수준의 함수**들로 분해할 수 있고, 이러한 분해 과정을 끝없이 **반복**할 수 있다.
- 게다가 이렇게 분해한 기능들은 구조적 프로그래밍의 **제한된 제어 구조**를 이용하여 표현할 수 있다.

## 2. 테스트

- 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 **없음**을 보여줄 수는 없다"고 말한 적이 있다.
- 다시 말해 프로그램이 **잘못되었음**을 테스트를 통해 증명할 수 있지만, 프로그램이 **맞다고 증명**할 수는 없다는 것이다.
- 소프트웨어는 **과학**과 같다.
  - 최선을 다하더라도 **올바르지 않음**을 증명하는 데 **실패**함으로써 올바름을 보여주기 때문이다(반증 가능성).
- 구조적 프로그래밍은 프로그램을 **증명 가능한 세부 기능 집합**으로 재귀적으로 분해할 것을 강요한다.
  - 그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 **거짓**인지를 증명하려고 시도한다.

## 3. 결론

- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 **반증 가능한 단위**를 만들어낼 수 있는 이 능력 때문이다.
- 아키텍처 관점에서는 **기능적 분해**를 최고의 실천법 중 하나로 여기는 이유이기도 하다.
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 **과학**과 같고, 따라서 **반증 가능성**에 의해 주도된다.
- **소프트웨어 아키텍트**는 모듈, 컴포넌트, 서비스가 쉽게 **반증 가능하도록(테스트하기 쉽도록)** 만들기 위해 분주히 노력해야 한다.
- 이를 위해 구조적 프로그래밍과 유사한 **제한적인 규칙**들을 받아들여 활용해야 한다.
