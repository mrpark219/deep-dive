# 경계: 선 긋기 (Boundaries: Drawing Lines)

## 1. 경계 (Boundaries)

- 소프트웨어 아키텍처는 **선을 긋는 기술**이며, 이러한 선을 **경계(Boundary)** 라고 부른다.
- 경계는 소프트웨어 요소를 서로 **분리**하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 **알지 못하도록** 막는다.
- 경계는 프로젝트의 **초기**에(코드 작성 전) 생길 수도 있고, **매우 나중에** 그어질 수도 있다.
  - 초기에 그어지는 선들은 가능한 한 오랫동안 **결정을 연기**시키기 위해, 핵심적인 **업무 로직**이 오염되지 않도록 보호한다.
- 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 **인적 자원**을 **최소화**하는 것이다.
  - **결합(Coupling)** 은 인적 자원의 효율을 떨어뜨리는 결정적인 요소다.
  - 특히 **너무 일찍 내려진 결정**이 문제인데, 이는 시스템의 업무 요구사항(유스케이스)과 아무런 관련 없는 결정들이다.
  - **프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리** 등이 여기에 포함된다.

## 2. 안 좋은 사례 (Bad Practice)

- 초기부터 시스템이 커질 것을 염려하여 **오버 엔지니어링**을 하는 경우 큰 문제가 발생한다.
- 특히, **MSA(마이크로서비스 아키텍처)** 나 **서비스 지향 아키텍처**의 확장성에만 눈이 멀어, 서비스 초기부터 아키텍처를 복잡하게 결정하고 시작하면 **안 된다**.
- 이러한 실수로 인해 인적 시간(개발 리소스)에 따른 **막대한 비용**이 낭비된다.

## 3. 좋은 사례 (Good Practice)

- **업무 규칙(Business Rules)** 을 확실하게 잡아둔 상태에서 **영속성(DB)**에 대한 고민을 할 때,
  - 영속성을 사용할 수 있도록 **인터페이스(Interface)** 를 먼저 생성한다.
  - 비즈니스 로직은 해당 **인터페이스**를 쓴다고만 작성해 두고, 실제 구현(파일, DB 등)은 나중에 필요에 따라 결정하고 연결한다.
- 즉, **업무 규칙**과 **데이터베이스** 사이에 **경계선**을 그었다.
- 이 경계선을 통해 업무 규칙은 데이터 접근 메서드 외에는 데이터베이스에 관해서 **어떤 것도 알지 못하게** 되었다.
- 경계선을 긋는 행위는 결정을 **늦추고 연기**하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 **절약**해 주었다.

## 4. 어떻게 선을 그을까? 그리고 언제 그을까?

- **관련이 있는 것**과 **없는 것** 사이에 선을 긋는다.

### 4.1. 데이터베이스와 업무 규칙의 관계

- 많은 사람이 데이터베이스는 업무 규칙과 서로 **떼어놓을 수 없는 관계**라고 배운다.
- 심지어 업무 규칙이 구체화된 것이 바로 **데이터베이스**라고 확신하는 사람도 있다.
- 하지만, 이는 **잘못된 생각**이다.
- **데이터베이스**는 업무 규칙이 간접적으로 사용할 수 있는 **도구(세부사항)** 일 뿐이다.
  - 업무 규칙은 **스키마**, **쿼리 언어**, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 **어떤 것도 알아서는 안 된다**.
  - 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 **함수 집합(인터페이스)** 이 있다는 사실이 전부다.
- 이 **함수 집합**을 통해서 우리는 데이터베이스를 **인터페이스 뒤로** 숨길 수 있다.
- 즉, **데이터베이스**는 **업무 규칙**에 대해 알고 있지만(의존하지만), **업무 규칙**은 **데이터베이스를 모른다**.

### 4.2. 입력과 출력 (GUI)

- 개발자와 고객은 종종 시스템이 무엇인지에 대해 **혼란스러워한다**.
  - GUI를 보고선 **GUI가 시스템**이라고 **생각하곤** 한다.
  - 하지만 GUI처럼 출력하는 **입출력 시스템**은 중요하지 않다.
- 우리는 시스템의 행위를 입출력이 지닌 행위적 측면에서 생각하는 경향이 있다.
  - 입출력 인터페이스 **뒤에는** 인터페이스를 조작하는 **모델**이 존재한다는 사실을 잊어버린다.
  - 더 중요한 사실은 **모델**은 **인터페이스**를 전혀 필요로 하지 않는다는 점이다.
- 따라서 데이터베이스와 마찬가지로 **GUI**는 **업무 규칙**을 알고 있지만, **업무 규칙**은 **GUI를 모른다**.

## 5. 플러그인 아키텍처 (Plugin Architecture)

- 위에서 논의한 데이터베이스와 GUI에 대한 결정들은 일종의 **패턴**을 형성한다.
  - 이 패턴은 시스템에서 **서드 파티 플러그인**을 사용할 수 있게 한 바로 그 패턴과 동일하다.
- 소프트웨어 개발 기술의 역사는 **플러그인**을 손쉽게 생성하여, **확장 가능**하며 **유지보수**가 쉬운 시스템 아키텍처를 확립하는 방법에 대한 이야기다.
- **핵심적인 업무 규칙**은 선택적이거나 다양한 형태로 **구현될** 수 있는 나머지 컴포넌트(세부사항)로부터 분리되어 있고, 또한 **독립적**이다.
  - 즉, **업무 규칙**이 시스템의 본질이고, GUI나 DB는 이 시스템에 꽂혔다 뺐다 할 수 있는 **플러그인**일 뿐이다.

## 6. 플러그인에 대한 논의

- 우리는 특정 모듈이 나머지 모듈에 **영향**을 주지 않기를 바란다.
  - 누군가 **웹 페이지의 포맷**이나 **데이터베이스 스키마**를 **변경**하더라도 **업무 규칙**은 깨지지 않기를 원한다.
  - 시스템의 한 부분이 변경되더라도 관련 없는 나머지 부분이 망가지길 원치 않는다.
- 시스템을 **플러그인 아키텍처**로 배치함으로써 변경이 전파될 수 없는 **방화벽(Firewall)** 을 생성할 수 있다.
- **경계**는 **변경의 축**이 있는 **지점**에 그어진다.
  - 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 **다른 속도**로, 그리고 **다른 이유**로 변경된다.
- **업무 규칙**은 의존성 주입 프레임워크와는 다른 시점에, 그리고 다른 이유로 변경되므로 둘 사이에도 반드시 **경계**가 필요하다.
  - 이 역시도 **단일 책임 원칙(SRP)** 에 해당한다.
  - SRP는 어디에 **경계**를 그어야 할지를 알려준다.

## 7. 결론

- **소프트웨어 아키텍처**에서 경계선을 그리려면 먼저 시스템을 **컴포넌트 단위**로 분할해야 한다.
  1.  일부 컴포넌트는 **핵심 업무 규칙**에 해당한다.
  2.  나머지 컴포넌트는 **플러그인**으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다(DB, GUI 등).
- 그런 다음 컴포넌트 사이의 **화살표(의존성)** 가 특정 방향, 즉 **핵심 업무**를 **향하도록** 이들 컴포넌트의 소스를 배치한다.
- 이는 **의존성 역전 원칙(DIP)** 과 **안정된 추상화 원칙(SAP)** 을 응용한 것이다.
- **의존성 화살표**는 **저수준 세부사항**에서 **고수준의 추상화**를 향하도록 배치된다.
