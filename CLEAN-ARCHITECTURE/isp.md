# ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)

## 1. 인터페이스 분리 원칙

> 클라이언트가 자신이 사용하지 않는 메서드에 의존하도록 강제하지 않아야 한다.

- 인터페이스가 너무 뚱뚱하다면 내가 쓰지도 않는 기능이 변했을 떄 나까지 영향을 받게 되는 경우가 생기는데 이처럼 **불필요한 결합을 끊는 것**이 ISP의 목적이다.

## 2. ISP와 언어

- **정적 타입 언어**는 사용자가 `import`, `use` 또는 `include`와 같은 **타입 선언문**을 사용하도록 강제한다.
  - 이처럼 소스 코드에 포함된 선언문으로 인해 **소스 코드 의존성**이 발생하고, 이로 인해 **재컴파일** 또는 **재배포**가 강제되는 상황이 무조건 초래된다.
- 반면 루비나 파이썬과 같은 **동적 타입 언어**에서는 소스 코드에 이러한 선언문이 존재하지 **않는다**.
  - 대신 **런타임**에 추론이 발생한다.
  - 따라서 소스 코드 의존성이 **아예** 없으며, 결국 재컴파일과 재배포가 필요 없다.
- 이 때문에 **동적 타입 언어를 사용하면** 정적 타입 언어를 사용할 때보다 **유연**하며 **결합도가 낮은** 시스템을 만들 수 있다.

## 3. ISP와 아키텍처

- 일반적으로 필요 이상으로 많은 걸 **포함**하는 모듈에 **의존**하는 것은 해로운 일이다.
  - 소스 코드 의존성의 경우 이는 분명한 사실인데, 불필요한 **재컴파일**과 **재배포**를 강제하기 때문이다.
- 하지만 더 고수준인 **아키텍처 수준**에서도 **마찬가지** 상황이 발생한다.
  - 예를 들어 **S 시스템** 구축에 참여하고 있는 아키텍트가 있다고 가정한다.
  - 아키텍트는 **F**라는 프레임워크를 시스템에 도입하기를 원한다. 그리고 F 프레임워크 개발자는 특정한 **D 데이터베이스**를 반드시 사용하도록 만들었다고 가정한다.
  - 이때 **S**는 **F**에 의존하며 **F**는 다시 **D**에 의존한다.
  - F에서는 불필요한 기능, 따라서 S와는 전혀 관계없는 기능이 **D**에 포함된다고 가정한다.
    - 그 기능 **때문에** D 내부가 변경되면 F를 재배포해야 할 수 있다. 따라서 S까지 재배포해야 할지 모른다.
    - D 내부의 기능 중 F와 S에서 불필요한 그 기능 **때문에** 문제가 발생해도 F와 S에 영향을 준다.

## 4. 결론

- **불필요한 짐**을 실은 무언가에 의존하면 **예상치도 못한 문제**에 빠진다는 사실이다.
