# SRP: 단일 책임 원칙 (Single Responsibility Principle)

## 1. 단일 책임 원칙

> **하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.**

- 이때 모듈의 가장 단순한 정의는 **소스 파일**이다.
  - 일부 언어나 개발 환경에서는 코드를 소스 파일에 저장하지 않는다.
  - 이러한 경우 모듈은 단순히 함수와 데이터 구조로 구성된 **응집된 집합**이다.
- 이때 **액터(Actor)**는 해당 변경을 요청하는 **한 명 이상의 사람들**을 가리킨다.

## 2. 우발적 중복

- 급여 애플리케이션에서 `Employee` 클래스가 있고, 이 클래스는 `calculatePay()`, `reportHours()`, `save()` 메서드를 가진다고 가정한다.
- 이 클래스는 **SRP를 위반**하는데, 이들 세 가지 메서드가 서로 매우 다른 **액터**를 책임지기 때문이다.
  - `calculatePay()`는 회계팀이 기능을 정의하며, CFO 보고를 위해 사용한다.
  - `reportHours()`는 인사팀이 기능을 정의하며, COO 보고를 위해 사용한다.
  - `save()`는 데이터베이스 관리자(DBA)가 기능을 정의하며, CTO 보고를 위해 사용한다.
- 이 세 가지 메서드가 한 클래스에 있을 때, `calculatePay()`와 `reportHours()`가 같은 **private 메서드**를 사용한다고 가정해 본다.
  - `calculatePay()` 메서드를 수정하기 위해 공유된 private 메서드를 수정하면, 의도치 않게 `reportHours()`에도 영향을 주게 된다.
- 이러한 문제는 서로 다른 액터가 의존하는 코드를 **너무 가까이** 배치했기 때문에 발생한다.
- SRP는 서로 다른 액터가 의존하는 코드를 서로 **분리**하라고 말한다.

## 3. 병합

- 소스 파일에 다양하고 많은 메서드를 포함하면 **병합(Merge)** 이 자주 발생하리라고 짐작하기는 어려운 일이 아니다.
  - 특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 더 높다.
- 이 문제를 해결하기 좋은 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 **분리**하는 것이다.
  - 각 메서드를 각기 다른 클래스로 **이동**하는 방법이 있다.
  - 위 `Employee` 예시를 이어나가면, 아무런 메서드가 없는 간단한 데이터 구조인 `EmployeeData` 클래스를 만들어 각 세 개의 클래스가 공유하도록 한다.
  - 각 클래스는 자신의 메서드에 반드시 필요한 **소스 코드**만을 포함한다.
  - 단, 이 경우 개발자가 세 가지 클래스를 **인스턴스화**하고 **추적**해야 한다는 게 단점이다.
- 이럴 때 사용할 수 있는 기법이 **퍼사드(Facade) 패턴**이다.
  - 퍼사드 클래스는 코드가 거의 없다.
  - 이 클래스는 세 클래스의 객체를 생성하고, **요청된 메서드**를 가지는 객체로 **위임**하는 일을 책임진다.

## 4. 결론

- 단일 책임 원칙은 **메서드**와 **클래스** 수준의 원칙이다.
- 하지만 이보다 더 **상위**의 두 수준에서도 다른 형태로 다시 등장한다.
  - **컴포넌트 수준**에서는 **공통 폐쇄 원칙(Common Closure Principle)** 이 된다.
  - **아키텍처 수준**에서는 아키텍처 경계의 생성을 책임지는 **변경의 축(Axis of Change)** 이 된다.
