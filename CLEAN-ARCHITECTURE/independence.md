# 독립성

- 좋은 아키텍처는 다음을 지원해야 한다.
  - 시스템의 유스케이스
  - 시스템의 운영
  - 시스템의 개발
  - 시스템의 배포

## 1. 유스케이스

- 시스템의 아키텍처는 시스템의 **의도**를 지원해야 한다.
- 아키텍트의 최우선 관심사는 **유스케이스**이며, 아키텍처에서도 유스케이스가 최우선이다.
- 아키텍처는 시스템의 **행위**에 그다지 큰 영향을 주지 않는다.
  - 하지만 영향력이 전부는 아니다.
  - 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중 가장 중요한 사항은 행위를 **명확히** 하고 외부로 **드러내며**, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

## 2. 운영

- 시스템의 운영 관점에서 볼 때 아키텍처는 더 **실질적**이며 덜 피상적인 역할을 맡는다.
- 시스템이 초당 몇 명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 **처리량**과 **응답 시간**을 보장해야 한다.
- 만약 시스템이 **단일체(Monolith)** 로 작성되어 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기가 어렵다.
- 그에 비해 아키텍처가 각 컴포넌트를 적절히 **격리**하여 유지하고 컴포넌트 간 통신 방식을 **특정 형태**로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 **기술 스펙트럼** 사이를 **전환하는** 일이 훨씬 쉬워진다.

## 3. 개발

- 아키텍처는 **개발 환경**을 지원하는 데 있어 핵심적인 역할을 수행한다. 이때 **콘웨이의 법칙(Conway's Law)** 이 작용한다.
- 콘웨이의 법칙은 시스템을 설계하는 조직이라면 어디든지 그 조직의 **의사소통 구조**와 동일한 구조의 설계를 만들어낼 것이라는 법칙이다.
- 많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 **독립적**으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 다른 팀들이 서로를 **방해하지** 않도록 해야 한다.

## 4. 배포

- 아키텍처는 **배포 용이성**을 결정하는 데 중요한 역할을 한다.
- 이때 목표는 **즉각적인 배포**이다.
- 좋은 **아키텍처라면** 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 이러한 아키텍처를 만들기 위해서는 시스템을 **컴포넌트 단위**로 적절하게 분할하고 **격리**시켜야 한다.
- 여기에는 **마스터 컴포넌트**도 포함된다.
  - 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다.

## 5. 선택사항 열어두기

- 좋은 아키텍처는 여러 관심사(개발, 배포, 운영 등) 사이에서 **균형**을 맞춰야 한다.
  - 하지만 현실에서는 모든 요구사항이 끊임없이 **변하기** 때문에 완벽한 균형을 잡기는 매우 어렵다.
- 이러한 불확실성 속에서 아키텍처가 할 수 있는 최선은 **선택사항을 열어두는 것**이다.
  - 시스템을 잘 **격리된 컴포넌트**로 나누어 놓으면, 미래에 변경이 필요할 때 **어떤 방향으로든** 쉽게 대응할 수 있다.
  - 즉, 세부적인 결정(DB, 프레임워크 등)을 가능한 한 **오랫동안 미룰 수 있게** 해준다.

## 6. 계층 결합 분리

- 아키텍트는 모든 세부 유스케이스를 알 수는 없지만, 시스템의 **기본적인 의도**(예: 쇼핑몰인지, 재고 관리 시스템인지)는 분명히 알고 있다.
- 따라서 **변경의 이유**가 다른 것들은 철저히 **분리**해야 한다.
  - 이를 위해 **단일 책임 원칙(SRP)** 과 **공통 폐쇄 원칙(CCP)** 을 적용한다.
  - **같이 변하는 것**들은 묶고, **따로 변하는 것**들은 분리한다는 원칙이다.
- 가장 대표적인 예가 **UI(사용자 인터페이스)** 와 **업무 규칙(비즈니스 로직)** 의 분리이다.
  - UI가 바뀌더라도 업무 규칙은 영향받지 않아야 하며, 서로 **독립적**으로 변경될 수 있어야 한다.

## 7. 유스케이스 결합 분리(유스케이스)

- **유스케이스** 자체는 서로 다른 이유로 변경될 수 있다.
  - 따라서 유스케이스는 시스템을 분할하는 매우 **자연스러운 기준**이 된다.
- 시스템은 기본적으로 UI, 업무 규칙, 데이터베이스 같은 **수평적 계층**으로 나뉜다.
- 하지만 각 유스케이스는 이 수평 계층을 **수직**으로 가로지르며 기능을 수행한다.
  - 즉, 시스템을 수평 계층으로 나누면서, 동시에 해당 계층을 가로지르는 **얇은 수직적인 유스케이스(Vertical Slice)** 로 분할해야 한다.
  - 이렇게 하면 유스케이스들이 각 계층에서 서로 **겹치지 않게** 할 수 있다.
- 서로 다른 이유로 변경되는 요소들의 결합을 분리하면, 기존 요소에 **지장을 주지 않고도** 새로운 유스케이스를 계속해서 추가할 수 있다.
- 유스케이스를 뒷받침하는 UI와 데이터베이스를 서로 묶어서 **격리**한다면, 새로운 유스케이스를 추가하더라도 기존 유스케이스에 **영향을 주는 일**은 거의 없을 것이다.

## 8. 결합 분리 모드(운영)

- 결합을 분리하는 것은 단순히 개발만 편하게 하는 것이 아니라, **운영 관점**에서도 큰 도움이 된다.
- **유스케이스**를 잘 분리해 두면, 각 기능의 특성에 맞춰 **서버 자원**을 효율적으로 쓸 수 있다.
  - 예를 들어, **높은 처리량**이 필요한 유스케이스와 그렇지 않은 유스케이스가 분리되어 있다면, 부하가 많은 쪽만 서버를 늘려서(Scale-out) 해결할 수 있다.
  - 또한, **UI**와 **데이터베이스**가 업무 규칙과 분리되어 있다면, 이들을 각각 **다른 서버**에서 실행하여 성능을 최적화할 수 있다.
- 하지만 운영 측면에서 이점을 살리기 위해서는 결합을 분리할 때 적절한 **모드(Mode)** 를 선택해야 한다.
  - 만약 컴포넌트들을 물리적으로 서로 다른 서버에서 실행해야 한다면, 이들은 같은 메모리 공간에 있을 수 없다.
  - 대신 반드시 **독립된 서비스** 형태로 존재해야 하며, 네트워크를 통해 서로 **통신**해야 한다.
- 이를 **서비스 지향 아키텍처(SOA)** 또는 **마이크로서비스(Microservices)** 라고 부른다.
  - 물론, 이것은 결합을 분리하는 **여러 선택지 중 하나**일 뿐이며, 모든 시스템을 마이크로서비스로 만들 필요는 없다.

## 9. 개발 독립성(개발)

- 컴포넌트가 완전히 **분리**되면 팀 사이의 **간섭**은 줄어든다.
- 계층과 유스케이스의 결합이 분리되는 한, 시스템의 아키텍처는 그 **팀 구조**를 뒷받침해 준다.
  - 즉, 각 팀이 서로 다른 유스케이스나 계층을 맡아 독립적으로 개발할 수 있다.

## 10. 배포 독립성(배포)

- 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 **교체**할 수 있다.
- 새로운 유스케이스를 추가하는 일은 시스템의 나머지는 그대로 둔 채 새로운 `.jar` 파일이나 서비스 몇 개를 추가하는 정도로 **단순한 일**이 된다.

## 11. 중복

- 소프트웨어에서 중복은 일반적으로 **나쁜 것**이다.
- 코드가 중복되었다면 중복을 줄이거나 제거해야 **한다**.
- 하지만 중복에도 **여러 종류**가 있다.
  1.  **진짜 중복**: 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 하는 경우.
  2.  **거짓된 또는 우발적인 중복**: 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 이유로 **변경된다면** 이 두 코드는 진짜 중복이 아니다.
- 우발적인 중복이지만 하나의 코드로 합치는 경우, 나중에 코드를 다시 **분리**하느라 큰 수고를 감수해야 한다.
- 유스케이스를 수직으로 분리할 때 이러한 문제와 마주칠 테고, 이들 유스케이스를 **통합**하고 싶다는 유혹을 받게 될 것이다.
  - 하지만 **조심해야 한다**.
  - **자동 반사적**으로 중복을 제거해버리는 잘못을 저지르는 유혹을 떨쳐내고, **진짜 중복**인지 확인해야 한다.

## 12. 결합 분리 모드(다시)

- 계층과 유스케이스를 분리하는 방법은 **다양**하다.
- 소스 코드 수준에서 분리할 수도 있으며, 바이너리 코드(배포) 수준에서도, 그리고 실행 단위(서비스) 수준에서도 분리할 수 있다.
- 좋은 아키텍처는 시스템이 **모노리틱 구조**로 태어나서 단일 파일로 배포되더라도 이후에는 **독립적으로 배포 가능한 단위**들의 집합으로 성장하고, 또 **독립적인 서비스**나 **마이크로서비스** 수준까지 성장할 수 있도록 만들어져야 한다.
- 또한 좋은 아키텍처라면 나중에 상황이 바뀌었을 때 이 진행 방향을 **거꾸로 돌려** 원래 형태인 **모노리틱 구조**로 되돌릴 수 있어야 한다.
- 시스템의 결합 분리 모드는 시간이 지나면서 **바뀌기 쉬우며**, 이러한 변경을 예측하여 큰 무리 없이 변경이 가능하도록 만들어야 한다.

### 12.1. 소스 수준 분리 모드

- **소스 코드 모듈** 사이의 의존성을 제어할 수 있다.
- 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 **재컴파일**하지 않도록 만들 수 있다.
- 이 모드에서는 모든 컴포넌트가 **같은 주소 공간**에서 실행되고, 서로 통신할 때는 **간단한 함수 호출**을 사용한다.
  - 컴퓨터 메모리에는 하나의 실행 파일만이 로드된다.
  - 이를 **모노리틱 구조**라고 한다.

### 12.2. 배포 수준 분리 모드

- `.jar`, `DLL`, `공유 라이브러리`와 같이 **배포 가능한 단위**들 사이의 의존성을 제어할 수 있다.
- 이를 통해 한 모듈의 소스 코드가 변하더라도 모든 모듈을 빌드하거나 **재배포**하지 않도록 할 수 있다.
- 많은 컴포넌트가 여전히 **같은 주소 공간**에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다.
- 결합이 분리된 컴포넌트가 **독립적으로 배포**할 수 있는 단위로 분할되어 있다.

### 12.3. 서비스 수준 분리 모드

- 의존하는 수준을 **데이터 구조 단위**까지 낮출 수 있고, 순전히 **네트워크 패킷**을 통해서만 통신하도록 만들 수 있다.
- 이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 **독립적**이게 된다.
  - (예: 마이크로서비스 아키텍처)
