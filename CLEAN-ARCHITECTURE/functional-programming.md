# 함수형 프로그래밍 (Functional Programming)

## 1. 함수형 프로그래밍의 핵심

- 이 패러다임에서 핵심이 되는 것은 **람다(Lambda) 계산법**이다.
- 함수형 프로그래밍 방식이 아니라면 **가변 변수(Mutable Variable)**를 사용하는데, 가변 변수는 프로그램 실행 중에 **상태**가 변할 수 있다.
- 반면 **함수형 프로그래밍**에서는 이러한 가변 변수가 전혀 없다.
  - 변수가 한 번 초기화되면 **절대로** 변하지 않는다(**불변성**).

## 2. 불변성과 아키텍처

- 아키텍처를 고려할 때 **불변성**이 필요한 이유는 **경합 조건(Race Condition)**, **교착 상태(Deadlock)**, **동시 업데이트(Concurrent Update)** 문제가 모두 **가변 변수**로 인해 발생하기 때문이다.
  - 만약 어떤 변수도 갱신되지 않는다면 **경합 조건**이나 **동시 업데이트** 문제가 일어나지 않는다.
  - **락(Lock)** 이 가변적이지 않다면 **교착 상태**도 일어나지 않는다.
  - **동시성 애플리케이션**에서 발생하는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.
- 따라서 아키텍트라면 **동시성 문제**에 지대한 관심을 가져야만 한다.

## 3. 가변성의 분리

- 애플리케이션 또는 애플리케이션 내부의 서비스를 **가변 컴포넌트**와 **불변 컴포넌트**로 분리하여 이를 해결할 수 있다.
  - **불변 컴포넌트**에서는 순수하게 **함수형 방식**으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
  - 따라서, 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 **소통**한다.
  - 상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 **트랜잭션 메모리(Transactional Memory)** 와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 **보호**한다.
- **트랜잭션 메모리**는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다.
  - 간단한 예로 [`Atom` 동작 방식(CAS 등)](../MULTITHREADING-AND-CONCURRENCY/cas-synchronization-and-atomic-operations.md#3-cas-compare-and-swap)이 있다.
  - Atom 기능은 간단한 애플리케이션에서는 적합하지만, 여러 변수가 **상호 의존**하는 상황에서는 동시 업데이트와 교착 상태 문제로부터 완벽히 보호해 주지 못한다.
  - 따라서 애플리케이션을 제대로 구조화하려면 변수를 **변경하는 컴포넌트**와 **변경하지 않는 컴포넌트**를 확실히 **분리**해야 한다는 것이다.
- 가능한 **많은** 처리를 **불변 컴포넌트**로 옮겨야 하고, **가변 컴포넌트**에서는 가능한 많은 코드를 **빼내야** 한다.

## 4. 이벤트 소싱

- 저장 공관과 처리 능력의 한계가 계속해서 늘어나고 있기 때문에 필요한 가변 사태는 더 적어진다.
- 은행 애플리케이션을 예로 들었을 때 입금 트랜잭션과 출금 트랜잭션이 실행되면 잔고를 변경해야 했다.
  - 하지만 이제 계좌 잔고를 변경하는 대신에 트랜잭션 자체를 저장한다고 생각해볼 수 있다.
  - 누군가 잔고 조회를 요청하면 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다. 이 전략에서는 가변 변수가 하나도 필요 없다.
  - 이 전략이 영원히 실현 가능하려면 무한한 저장 공간과 처리 능력이 필요하다.
- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
- 물론 여기서 타협점을 찾을 수 있다.
  - 매일 자정에 상태를 저장한 후, 그 이후 상태 정보가 필요해지면 자정의 상태로부터 출발하여 그 이후 트랜잭션만 계산하면 된다.
- 이벤트 소싱을 사용할 떄 저장공간은 CRUD가 아니라 CR만 일어나게 된다. 따라서 동시 업데이트 문제가 발생되지 않는다.
- 저장 공간과 처리 능력만 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.

## 4. 이벤트 소싱 (Event Sourcing)

- **저장 공간**과 **처리 능력**의 한계가 계속해서 늘어나고 있기 때문에 필요한 **가변 상태**는 더 적어진다.
- 은행 애플리케이션을 예로 들었을 때, 과거에는 입금 트랜잭션과 출금 트랜잭션이 실행되면 **잔고(상태)** 를 변경해야 했다.
  - 하지만 이제 계좌 잔고를 변경하는 대신에 **트랜잭션 자체**를 저장한다고 생각해 볼 수 있다.
  - 누군가 잔고 조회를 요청하면 계좌 개설 시점부터 발생한 **모든 트랜잭션**을 단순히 더한다. 이 전략에서는 **가변 변수**가 하나도 필요 없다.
  - 이 전략이 영원히 실현 가능하려면 **무한한 저장 공간**과 **처리 능력**이 필요하다.
- **이벤트 소싱**은 상태가 아닌 **트랜잭션(이벤트)** 을 저장하자는 전략이다.
  - 상태가 필요해지면 단순히 상태의 **시작점**부터 모든 트랜잭션을 처리한다.
- 물론 여기서 **타협점**을 찾을 수 있다.
  - 매일 자정에 **상태(스냅샷)** 를 저장한 후, 그 이후 상태 정보가 필요해지면 자정의 상태로부터 출발하여 그 이후 트랜잭션만 계산하면 된다.
- 이벤트 소싱을 사용할 때 데이터 저장소에서는 **CRUD**가 아니라 **CR(Create, Read)** 만 일어나게 된다.
  - 변경(Update)이나 삭제(Delete)가 발생하지 않으므로 **동시 업데이트** 문제가 발생하지 않는다.
- 저장 공간과 처리 능력만 충분하면 애플리케이션이 **완전한 불변성**을 갖도록 만들 수 있고, 따라서 **완전한 함수형**으로 만들 수 있다.
