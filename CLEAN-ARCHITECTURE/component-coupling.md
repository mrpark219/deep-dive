# 컴포넌트 결합

## 1. ADP: 의존성 비순환 원칙 (Acyclic Dependencies Principle)

> **컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안 된다.**

- 인원수가 많은 개발팀에서 근무한다고 했을 때, 하루 종일 작업해서 마무리한 코드가 다음날에 **동작하지 않게** 되는 경우가 있다.
- 이를 **숙취 증후군(The Morning After Syndrome)** 이라고 부른다.
- 숙취 증후군은 많은 **개발자**가 동일한 소스 파일을 수정하는 환경에서 발생한다.
  - 이 문제의 해결책으로는 **주 단위 빌드(Weekly Build)** 와 **의존성 비순환 원칙(ADP)** 이 있다.

### 1.1. 주 단위 빌드 (Weekly Build)

- **중간 규모**의 프로젝트에서 흔하게 사용된다.
- 주 단위 빌드는 모든 개발자가 일주일의 **첫 4일(월요일~목요일)** 까지 서로를 신경 쓰지 않고 개발한다.
  - 개발자는 모두 코드를 개인적으로 복사하여 작업하며, 전체적인 기준에서 작업을 어떻게 통합할지는 걱정하지 않는다.
  - 그런 후 **금요일**이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 이 접근법은 5일 중 4일 동안 개발자를 **고립된 세계**에서 살 수 있게 보장해 주지만, 금요일에 통합과 관련된 막대한 **대가(업보)** 를 치르게 한다.
- 프로젝트가 커지면 프로젝트 통합을 금요일 하루 만에 끝낼 수 없게 되고, 개발보다 **통합**에 더 큰 시간을 들이게 된다.
  - 이와 같은 흐름은 효율성을 유지하기 **위해** 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 **위험**은 커진다.
  - 통합과 테스트를 수행하기 점점 어려워지고, 팀은 **빠른 피드백**이 주는 장점을 잃는다.

### 1.2. 순환 의존성 제거하기

- 이 문제의 해결책은 개발 환경을 **릴리스 가능한 컴포넌트 단위**로 분리하는 것이다.
  - 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 **작업 단위**가 된다.
- 개발자는 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 **릴리스**하여 다른 개발자가 사용할 수 있도록 한다.
  - 담당 개발자는 이 컴포넌트에 **릴리스 번호**를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다.
- 컴포넌트가 새로 릴리스 되면 다른 팀에서는 새 릴리스를 적용할지 여부를 **판단**한다.
- 따라서 어떤 팀도 다른 팀에 의해 **좌우되지** 않는다.
  - 특정 컴포넌트가 변경되더라도 다른 팀에 즉각 영향을 주지는 않는다.
  - 각 팀은 특정 컴포넌트가 새롭게 릴리스 되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 **스스로** 결정할 수 있다.
  - 뿐만 아니라 통합은 작고 **점진적**으로 이뤄진다.
- 이 작업 절차가 성공적으로 동작하려면 컴포넌트 사이의 **의존성 구조**를 반드시 관리해야 한다.
  - 의존성 구조에 **순환**이 있어서는 안 된다. 의존성 구조에 순환이 생기면 **숙취 증후군**을 피할 수 없다.
- 따라서 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면서 최초의 **컴포넌트**로 되돌아갈 수 없도록 **비순환 방향 그래프(DAG)** 로 컴포넌트 구조를 만들어야 한다.
- 해당 그래프를 완성하게 되면 한 컴포넌트의 새로운 릴리스를 배포할 때 영향을 받게 되는 컴포넌트를 쉽게 찾을 수 있다.
  - 의존성 화살표를 **거꾸로** 따라가면 **된다**.

### 1.3. 순환이 컴포넌트 의존성 그래프에 미치는 영향

- **순환 의존성**이 발생한다면 컴포넌트들이 하나의 **거대한 컴포넌트**가 되어버린다.
- 이 말은 어떤 컴포넌트를 개발하더라도 **숙취 증후군**이 발생할 **수밖에 없다**.
- 순환이 생기면 컴포넌트를 **분리**하기가 상당히 어려워진다.
  - 단위 테스트를 하고 싶어도 순환 의존성에 걸린 모든 컴포넌트를 함께 빌드하고 테스트해야 한다.

### 1.4. 순환 끊기

- 컴포넌트 사이의 순환을 끊고 의존성을 다시 **DAG**로 원상 복구하는 일은 언제라도 가능하다.

1.  **의존성 역전 원칙(DIP)** 을 적용한다.
    - 인터페이스를 활용하여 의존성 방향을 역전시킨다.
2.  **새로운 컴포넌트**를 만든다.
    - 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

### 1.5. 흐트러짐 (Jitters)

- **두 번째** 해결책(새로운 컴포넌트 생성)에서 시사하는 바는 **요구사항**이 변경되면 **컴포넌트 구조**도 변경될 수 있다는 사실이다.
- 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 **성장**한다.
  - 따라서 의존성 구조에 순환이 발생하는지 항상 **관찰**해야 한다.

## 2. 하향식(Top-Down) 설계

- 컴포넌트 구조는 **하향식**으로 설계될 수 **없다**.
- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 **시스템**이 성장하고 변경될 때 **함께** 진화한다.
- **컴포넌트 의존성 다이어그램**은 애플리케이션의 **기능**을 기술하는 일과는 관련이 없다.
- 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 **빌드 가능성**과 **유지보수성**을 보여주는 **지도**와 같다.
- 이러한 이유 때문에 컴포넌트 구조는 프로젝트 **초기**에 설계할 수 없다.
  - 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 **필요 없기 때문**이다.

## 3. SDP: 안정된 의존성 원칙 (Stable Dependencies Principle)

> **안정성의 방향으로(더 안정된 쪽에) 의존하라.**

- 설계는 결코 **안정적**일 수 없다. 설계를 유지하다 보면 **변경**은 불가피하다.
- **변경이 쉽지 않은 컴포넌트**가 **변동이 예상되는 컴포넌트**에 의존하게 만들어서는 절대로 **안 된다**.
  - 한 번 의존하게 되면 변동성이 큰 컴포넌트도 결국 **변경이 어려워진다**.
- **안정된 의존성 원칙**을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 **의존하지 않도록** 만들 수 있다.

### 3.1. 안정성 (Stability)

- 안정성은 변경을 만들기 위해 필요한 **작업량**과 관련된다.
  - 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 많은 요인이 존재하며, 그 예로는 컴포넌트의 크기, 복잡도, 간결함 등을 들 수 있다.
  - 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 가장 확실한 요인은 **수많은 다른 컴포넌트**가 해당 컴포넌트에 **의존**하게 만드는 것이다.
- 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 **안정적**이라고 볼 수 있는데, **사소한 변경**이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.
- 예를 들어 세 컴포넌트가 **X 컴포넌트**에 의존하고 있다면 X 컴포넌트는 변경하지 말아야 할 이유가 **세 가지**나 된다.
  - 이 경우 X는 세 컴포넌트를 **책임진다(Responsible)** 라고 말한다.
- 반대로 X는 어디에도 의존하지 않는 경우, X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.
  - 이 경우 X는 **독립적이다(Independent)** 라고 말한다.

### 3.2. 안정성 지표

- 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 **안정성**을 가지는지 계산할 수 있다.
- **Fan-in**: 안으로 들어오는 의존성. 이 지표는 컴포넌트 **내부**의 클래스에 의존하는 컴포넌트 **외부**의 클래스 개수를 나타낸다.
- **Fan-out**: 바깥으로 나가는 의존성. 이 지표는 컴포넌트 **외부**의 클래스에 의존하는 컴포넌트 **내부**의 클래스 개수를 나타낸다.
- **I(불안정성)**: $I = Fan\_out \div (Fan\_in + Fan\_out)$
  - 이 지표는 **0과 1** 범위의 값을 갖는다.
  - $I = 0$이면 최고로 **안정된** 컴포넌트라는 뜻이다.
  - $I = 1$이면 최고로 **불안정한** 컴포넌트라는 뜻이다.

#### I = 1 (최고로 불안정함)

- 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 **의존한다**는 뜻이다.
- 컴포넌트가 가질 수 있는 최고로 **불안정한 상태**이다.
- 이 컴포넌트는 **책임성이 없으며(Irresponsible)** **의존적(Dependent)** 이다.
- 변경하지 말아야 할 이유가 없고, 해당 컴포넌트를 **변경해야 할 이유**가 있다는 뜻이다.

#### I = 0 (최고로 안정됨)

- 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 **의존하지 않는다**는 뜻이다.
- 다른 컴포넌트를 **책임지며(Responsible)** **독립적(Independent)** 이다.
- 컴포넌트가 가질 수 있는 최고로 **안정된 상태**이다.

### 3.3. 모든 컴포넌트가 안정적이어야 하는 것은 아니다

- 모든 컴포넌트가 최고로 안정적인 시스템이라면 **변경이 불가능**하다. 이는 바람직한 상황이 아니다.
- 컴포넌트 구조를 설계할 때는 **불안정한 컴포넌트**와 **안정된 컴포넌트** 둘 다 존재하는 상태여야 한다.
- 또한 이를 다이어그램으로 나타낼 때는 **불안정한 컴포넌트**를 **위**에 두는 관습이 있다.
  - 이럴 경우 **위로 향하는 화살표**가 있으면 **SDP를 위반**하고 있다는 사실을 쉽게 파악할 수 있다.
- 만약 이러한 SDP를 위반하는 문제가 발생한다면 **순환 끊기**처럼 **의존성 역전(DIP)** 혹은 **새로운 컴포넌트 만들기**를 통해 해결할 수 있다.
