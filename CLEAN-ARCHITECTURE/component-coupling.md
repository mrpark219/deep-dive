# 컴포넌트 결합

## 1. ADP: 의존성 비순환 원칙 (Acyclic Dependencies Principle)

> **컴포넌트 의존성 그래프에 순환(Cycle)이 있어서는 안 된다.**

- 인원수가 많은 개발팀에서 근무한다고 했을 때, 하루 종일 작업해서 마무리한 코드가 다음날에 **동작하지 않게** 되는 경우가 있다.
- 이를 **숙취 증후군(The Morning After Syndrome)** 이라고 부른다.
- 숙취 증후군은 많은 **개발자**가 동일한 소스 파일을 수정하는 환경에서 발생한다.
  - 이 문제의 해결책으로는 **주 단위 빌드(Weekly Build)** 와 **의존성 비순환 원칙(ADP)** 이 있다.

### 1.1. 주 단위 빌드 (Weekly Build)

- **중간 규모**의 프로젝트에서 흔하게 사용된다.
- 주 단위 빌드는 모든 개발자가 일주일의 **첫 4일(월요일~목요일)** 까지 서로를 신경 쓰지 않고 개발한다.
  - 개발자는 모두 코드를 개인적으로 복사하여 작업하며, 전체적인 기준에서 작업을 어떻게 통합할지는 걱정하지 않는다.
  - 그런 후 **금요일**이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 이 접근법은 5일 중 4일 동안 개발자를 **고립된 세계**에서 살 수 있게 보장해 주지만, 금요일에 통합과 관련된 막대한 **대가(업보)** 를 치르게 한다.
- 프로젝트가 커지면 프로젝트 통합을 금요일 하루 만에 끝낼 수 없게 되고, 개발보다 **통합**에 더 큰 시간을 들이게 된다.
  - 이와 같은 흐름은 효율성을 유지하기 **위해** 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 **위험**은 커진다.
  - 통합과 테스트를 수행하기 점점 어려워지고, 팀은 **빠른 피드백**이 주는 장점을 잃는다.

### 1.2. 순환 의존성 제거하기

- 이 문제의 해결책은 개발 환경을 **릴리스 가능한 컴포넌트 단위**로 분리하는 것이다.
  - 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 **작업 단위**가 된다.
- 개발자는 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 **릴리스**하여 다른 개발자가 사용할 수 있도록 한다.
  - 담당 개발자는 이 컴포넌트에 **릴리스 번호**를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다.
- 컴포넌트가 새로 릴리스 되면 다른 팀에서는 새 릴리스를 적용할지 여부를 **판단**한다.
- 따라서 어떤 팀도 다른 팀에 의해 **좌우되지** 않는다.
  - 특정 컴포넌트가 변경되더라도 다른 팀에 즉각 영향을 주지는 않는다.
  - 각 팀은 특정 컴포넌트가 새롭게 릴리스 되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 **스스로** 결정할 수 있다.
  - 뿐만 아니라 통합은 작고 **점진적**으로 이뤄진다.
- 이 작업 절차가 성공적으로 동작하려면 컴포넌트 사이의 **의존성 구조**를 반드시 관리해야 한다.
  - 의존성 구조에 **순환**이 있어서는 안 된다. 의존성 구조에 순환이 생기면 **숙취 증후군**을 피할 수 없다.
- 따라서 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면서 최초의 **컴포넌트**로 되돌아갈 수 없도록 **비순환 방향 그래프(DAG)** 로 컴포넌트 구조를 만들어야 한다.
- 해당 그래프를 완성하게 되면 한 컴포넌트의 새로운 릴리스를 배포할 때 영향을 받게 되는 컴포넌트를 쉽게 찾을 수 있다.
  - 의존성 화살표를 **거꾸로** 따라가면 **된다**.

### 1.3. 순환이 컴포넌트 의존성 그래프에 미치는 영향

- **순환 의존성**이 발생한다면 컴포넌트들이 하나의 **거대한 컴포넌트**가 되어버린다.
- 이 말은 어떤 컴포넌트를 개발하더라도 **숙취 증후군**이 발생할 **수밖에 없다**.
- 순환이 생기면 컴포넌트를 **분리**하기가 상당히 어려워진다.
  - 단위 테스트를 하고 싶어도 순환 의존성에 걸린 모든 컴포넌트를 함께 빌드하고 테스트해야 한다.

### 1.4. 순환 끊기

- 컴포넌트 사이의 순환을 끊고 의존성을 다시 **DAG**로 원상 복구하는 일은 언제라도 가능하다.

1.  **의존성 역전 원칙(DIP)** 을 적용한다.
    - 인터페이스를 활용하여 의존성 방향을 역전시킨다.
2.  **새로운 컴포넌트**를 만든다.
    - 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

### 1.5. 흐트러짐 (Jitters)

- **두 번째** 해결책(새로운 컴포넌트 생성)에서 시사하는 바는 **요구사항**이 변경되면 **컴포넌트 구조**도 변경될 수 있다는 사실이다.
- 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 **성장**한다.
  - 따라서 의존성 구조에 순환이 발생하는지 항상 **관찰**해야 한다.

## 2. 하향식(Top-Down) 설계

- 컴포넌트 구조는 **하향식**으로 설계될 수 **없다**.
- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 **시스템**이 성장하고 변경될 때 **함께** 진화한다.
- **컴포넌트 의존성 다이어그램**은 애플리케이션의 **기능**을 기술하는 일과는 관련이 없다.
- 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 **빌드 가능성**과 **유지보수성**을 보여주는 **지도**와 같다.
- 이러한 이유 때문에 컴포넌트 구조는 프로젝트 **초기**에 설계할 수 없다.
  - 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 **필요 없기 때문**이다.
