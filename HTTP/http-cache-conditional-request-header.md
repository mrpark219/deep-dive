# HTTP 헤더 - 캐시와 조건부 요청

## 1. 캐시 기본 동작

### 1.1 캐시가 없을 때

- 데이터가 변경되지 않아도 **네트워크를 통해 데이터를 지속적으로 다운로드**해야 한다.
- **네트워크 사용량 증가**로 인해 성능 저하가 발생하며, 서버 운영 비용이 증가한다.
- **브라우저 로딩 속도가 느려지며**, 사용자 경험이 저하된다.

### 1.2 캐시 적용

- **캐시 덕분에 일정 시간 동안 네트워크 요청 없이 데이터 재사용 가능**하다.
- **비싼 네트워크 사용량을 줄일 수 있다.**
- **브라우저 로딩 속도가 빨라지고, 사용자 경험이 개선된다.**

### 1.3 캐시 시간 초과

- `Cache-Control: max-age=60(초)` 와 같이 설정할 수 있다.
- 캐시 유효 시간이 초과되면, 서버로부터 데이터를 다시 가져와 **캐시를 갱신**한다.
- 이때 다시 **네트워크 다운로드가 발생**한다.

## 2. 검증 헤더와 조건부 요청 1

### 2.1 캐시 시간 초과 후 동작

- 캐시 유효 시간이 지나면, **서버에서 데이터가 변경되지 않았다면 기존 캐시를 재사용**할 수 있다.
- **클라이언트의 캐시 데이터와 서버 데이터가 동일한지 확인할 방법이 필요**하다.

### 2.2 검증 헤더 추가

- `Last-Modified: 2025년 3월 17일 22:20:00` 과 같은 정보를 활용한다.
- **캐시가 만료되었을 때**, 브라우저는 `If-Modified-Since` 헤더에 최종 수정일을 포함하여 요청을 보낸다.
- 서버는 데이터를 수정했는지 확인하고, **수정되지 않았다면 `304 Not Modified` 응답을 반환**한다.
- **304 응답은 본문 없이 헤더 정보만 갱신하여 기존 캐시를 재사용**할 수 있도록 한다.

## 3. 검증 헤더와 조건부 요청 2

### 3.1 검증 헤더

- **캐시 데이터와 서버 데이터를 비교하여 동일 여부를 검증하는 역할**을 한다.
- 대표적인 검증 헤더:
  - `Last-Modified`
  - `ETag`

### 3.2 조건부 요청 헤더

- 검증 헤더를 기반으로 서버가 조건을 확인하여 응답을 결정한다.
- 대표적인 조건부 요청 헤더:
  - `If-Modified-Since`: `Last-Modified` 값을 사용
  - `If-None-Match`: `ETag` 값을 사용
- **데이터가 변경되었으면 `200 OK` 응답을 보내고, 변경되지 않았으면 `304 Not Modified` 응답을 반환한다**.

### 3.3 Last-Modified, If-Modified-Since 단점

- **초 단위 미만으로 캐시 조정이 불가능**하다.
- **날짜 기반 비교이므로, 실제 데이터가 같아도 수정 날짜가 다르면 새로 다운로드한다**.
- **서버에서 더 정교한 캐시 관리가 필요할 경우 한계가 있다**.

### 3.4 ETag(Entity Tag), If-None-Match

- **ETag는 데이터의 고유한 버전을 부여하여 캐시 검증을 수행**한다.
- **데이터가 변경되면 새로운 ETag 값을 부여하여 클라이언트가 변경 여부를 감지**할 수 있도록 한다.
- **ETag 값이 같으면 캐시를 유지하고, 다르면 새로 요청하는 방식**을 따른다.
- **서버에서 캐시 제어 로직을 자유롭게 관리할 수 있으며, 클라이언트는 단순히 서버에 ETag를 제공하면 된다.**

## 4. 캐시와 조건부 요청 헤더

### 4.1 캐시 제어 헤더

- `Cache-Control`: 캐시 제어
- `Pragma`: 캐시 제어(하위 호환)
- `Expires`: 캐시 유효 기간(하위 호환)

### 4.2 Cache-Control

- 캐시를 제어하는 다양한 지시어를 제공한다.
- `Cache-Control: max-age=60` → 캐시 유효 시간을 초 단위로 지정한다.
- `Cache-Control: no-cache` → 캐시를 저장하되, **항상 중간 캐시 서버가 아닌 원 서버에 검증 요청을 보낸 후 사용**한다.
- `Cache-Control: no-store` → **캐시를 아예 저장하지 않고, 항상 네트워크 요청을 수행**한다.

### 4.3 Pragma

- HTTP 1.0에서 사용되던 캐시 제어 방식이며, **하위 호환을 위해 `Pragma: no-cache`를 사용할 수 있다.**

### 4.4 Expires

- 캐시 만료 시간을 **정확한 날짜로 지정**하는 방식이다.
- 예시: `Expires: Mon, 12 Feb 2024 22:51:00 GMT`
- HTTP 1.0에서 사용되었으나, 현재는 더 유연한 `Cache-Control: max-age`가 권장된다.

### 4.5 검증 헤더(Validator)

- **캐시 데이터가 최신 상태인지 검증하는 역할**을 한다.
- `ETag`, `Last-Modified` 헤더를 사용한다.

### 4.6 조건부 요청 헤더

- `If-Match`, `If-None-Match`: `ETag` 값을 기반으로 검증 요청을 수행한다.
- `If-Modified-Since`, `If-Unmodified-Since`: `Last-Modified` 값을 기반으로 검증 요청을 수행한다.

## 5. 프록시 캐시

### 5.1 프록시 캐시 개념

- 프록시는 **원(origin) 서버를 대리하여 통신하며, 캐시 기능을 제공하는 중계 서버**이다.
- 대표적인 예:
  - **CDN(Content Delivery Network)**: 콘텐츠를 빠르게 제공하는 네트워크
  - **CloudFront(AWS)**: 프록시 캐시 서버 기능 제공

### 5.2 Cache-Control 프록시 설정

- `Cache-Control: public` → 응답이 **공용 캐시에 저장 가능**함을 의미한다.
- `Cache-Control: private` → **해당 사용자만을 위한 캐시**로 저장해야 함을 의미한다. (기본값)
- `Cache-Control: s-maxage=120` → **프록시 캐시에만 적용되는 max-age 설정**을 지정한다.
- `Age: 60` → 응답이 **프록시 캐시에 저장된 후 경과된 시간(초)** 을 나타낸다.

## 6. 캐시 무효화

### 6.1 확실한 캐시 무효화 방법

- 캐시를 반드시 무효화해야 할 경우, 다음과 같은 설정을 사용한다.
  - `Cache-Control: no-cache, no-store, must-revalidate`
    - `no-cache` → **캐시를 저장할 수 있지만, 반드시 원 서버에 검증 후 사용**해야 한다.
    - `no-store` → **캐시를 아예 저장하지 않고, 항상 네트워크 요청을 수행**해야 한다.
    - `must-revalidate` → **캐시가 만료된 경우, 반드시 원 서버에 검증 요청을 보내야 한다.** 만약 서버 접근이 불가능하면 **504 Gateway Timeout 오류**를 발생시킨다.
  - `Pragma: no-cache`
    - HTTP 1.0에서 사용되던 방식으로, **하위 호환성을 위해 포함할 수 있다.**

### 6.2 no-cache와 must-revalidate 차이점

- `no-cache`를 사용할 경우, 원 서버에 접근할 수 없을 때 **캐시 데이터를 사용할 수도 있고, 오류를 반환할 수도 있다.**
  - 즉, 캐시 서버 설정에 따라 동작 방식이 달라질 수 있다.
- `must-revalidate`를 사용할 경우, 원 서버에 접근할 수 없으면 **반드시 오류(504 Gateway Timeout)를 반환한다.**
  - **매우 중요한 데이터의 경우 `must-revalidate`를 사용하는 것이 안전하다.**
