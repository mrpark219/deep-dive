# 오류 처리

## 1. 오류 코드보다 예외를 사용하라

- 과거에는 예외를 지원하지 않는 언어가 많았기 때문에, 오류 플래그를 설정하거나 오류 코드를 반환하는 방식이 일반적이었다.
- 하지만 이런 방식은 코드 가독성과 유지보수성을 해치며, 프로그램의 정상 흐름과 예외 흐름을 뒤섞는다.

## 2. Try-Catch-Finally 문부터 작성하라

- 예외는 프로그램 내 **트랜잭션 범위**처럼 동작한다.
- `try` 블록은 실행 도중 언제든지 중단될 수 있고, 이후 `catch` 블록이 호출되어 프로그램 상태를 정리한다.
- TDD를 할 때도 예외를 유도하는 테스트 케이스를 먼저 작성하고, 예외 흐름을 처리하는 `try` 범위를 먼저 구현하는 접근을 권장한다.

## 3. 미확인(unchecked) 예외를 사용하라

- **확인된 예외(checked exception)** 는 OCP(개방 폐쇄 원칙)를 위반한다.
- 확인된 예외를 던질 경우, 해당 예외는 호출 스택을 따라 모든 함수 선언부에 명시되어야 한다.
- 이는 하위 단계 변경이 상위 코드까지 영향을 주는 **연쇄적인 수정**을 야기한다.
- 따라서 대부분의 경우에는 **미확인 예외(unchecked exception)** 를 사용하는 편이 유리하다.

## 4. 예외에 의미를 제공하라

- 예외를 던질 때는 **충분한 맥락 정보**를 제공해야 한다.
- 예외 메시지를 활용해 **문제가 발생한 원인과 위치**를 명확히 파악할 수 있어야 한다.
- 예: `"주문 생성 실패: 상품 재고 부족"`과 같이 **원인 + 행위** 조합으로 명확하게 기술한다.

## 5. 호출자를 고려해 예외 클래스를 정의하라

- 예외는 **어디서 발생했는지**보다, **호출자가 어떻게 처리해야 하는지**를 기준으로 분류하는 것이 좋다.
- 예외를 **외부 API로부터 직접 노출하지 않고**, 감싸는 클래스 또는 예외로 추상화하면 **의존성을 줄이고 테스트가 쉬워진다.**
- 감싸기(Wrapping) 전략은 교체 비용을 줄이는 데에도 효과적이다.

## 6. 정상 흐름을 정의하라

- 예외 상황을 **정상 흐름으로 흡수**할 수 있다면 특수 사례(Special Case) 객체를 만들어 사용한다.
- 예외 대신 동작을 대체하거나 무시할 수 있는 객체를 반환하는 방식으로 코드를 단순하게 만들 수 있다.

## 7. null을 반환하지 마라

- `null`을 반환하면 호출자가 매번 `null`을 확인해야 하며, 이는 코드 품질을 떨어뜨린다.
- 대신 **예외를 던지거나 특수 사례 객체(Special Case Object)** 를 반환한다.
- 외부 API가 `null`을 반환한다면, 이를 감싸는 어댑터 클래스에서 예외나 기본 객체로 변환하도록 처리한다.

## 8. null을 전달하지 마라

- `null`을 메서드에 인수로 전달하는 것은 반환하는 것보다 더 위험하다.
- 대부분의 메서드는 `null`을 유효한 값으로 기대하지 않기 때문에, 예외를 발생시키는 원인이 된다.
- 유효한 인수를 기대하는 메서드에는 `null`이 절대 전달되지 않도록 사전에 방지해야 한다.

## 9. 마무리

- **깨끗한 코드는 읽기 쉬울 뿐 아니라 안정성도 높아야 한다.**
- 오류 처리는 **핵심 로직과 분리해 독립적으로 다뤄야 하며**, 이를 통해 **더 견고하고 유지보수하기 쉬운 코드**를 만들 수 있다.
