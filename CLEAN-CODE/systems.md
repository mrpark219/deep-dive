# 시스템

## 1. 도시를 세운다면?

- 도시는 적절한 **추상화와 모듈화** 덕분에 돌아가는 구조이다.
- 전체를 이해하지 못해도 각 구성요소가 효율적으로 동작하도록 되어 있다.
- 소프트웨어 시스템도 마찬가지로 추상화와 모듈화가 기반이 되어야 한다.
- 시스템이 복잡해지는 이유는 관심사를 제대로 분리하지 못했기 때문이다.
- **깨끗한 코드**는 낮은 수준에서도 관심사를 **명확히 분리**할 수 있도록 도와주는 도구이다.

## 2. 시스템 제작과 시스템 사용을 분리하라

- **시스템 제작(construction)** 과 **사용(use)** 은 서로 다른 성격을 가진다.
- 소프트웨어 시스템은 애플리케이션 객체를 생성하고 의존성을 설정하는 준비 과정과 그 이후의 실행 로직을 분리해야 한다.
- 이러한 분리는 모든 애플리케이션이 반드시 해결해야 할 **핵심 관심사(concern)** 이다.
- 관심사 분리는 가장 오래된 **중요한 설계 기법** 중 하나이다.

```java
public Service getService() {
    if (service == null) {
        service = new MyServiceImpl();
    }

    return service;
}
```

- 위는 **초기화 지연(Lazy Initialization)** 또는 **계산 지연(Lazy Evaluation)** 기법의 예시이다.
- 한두 번 사용하는 것은 문제가 없지만, 많은 애플리케이션이 이 기법을 반복적으로 사용하면서 전반적인 설정 코드가 시스템 곳곳에 흩어져 있는 문제가 발생한다.
- 이런 방식은 **모듈성과 일관성**을 해치며 **중복 문제**를 유발하기 쉽다.
- 객체 생성과 의존성 연결을 일반 실행 로직과 **분리**해야 한다.
- 전반적인 의존성을 일관된 방식으로 설정해야 한다.

### 2.1 장점

- 필요할 때까지 객체를 생성하지 않기 때문에 **불필요한 부하를 줄일 수 있다**.
- 애플리케이션 시작 속도를 **향상시킬 수 있다**.
- **null 포인터를 반환하지 않는다**.

### 2.2 단점

- `getService()`는 `MyServiceImpl`에 **명시적으로 의존한다**.
- 런타임에 사용하지 않더라도 의존성이 해결되지 않으면 **컴파일되지 않는다**.
- 무거운 객체일 경우 테스트에서 **대체가 어렵다**.
- 객체 생성 로직이 일반 실행 로직에 **혼재되어 있어 책임이 두 가지이다**.
- `MyServiceImpl`이 모든 상황에 적합한지 **확신할 수 없다**.

### 2.3 Main 분리

- 생성 관련 코드는 **모두 main이나 설정 모듈로 이동시켜야 한다**.
- 나머지 시스템은 모든 객체가 생성되고 의존성도 연결된 상태라고 **가정하고 동작해야 한다**.
- 애플리케이션은 객체 생성 과정을 **몰라도 된다**.

### 2.4 팩토리 패턴

- 객체를 언제 생성할지는 애플리케이션이 결정하되 **생성 방법은 감춰야 한다**.
- 예를 들어 주문 처리 시스템에서 `LineItem`을 생성할 때는 **ABSTRACT FACTORY 패턴을 사용해야 한다**.
- 생성 방식이 변경되더라도 애플리케이션에는 **영향을 주지 않는다**.

### 2.5 의존성 주입

- 의존성 주입은 **제어 역전(Inversion of Control, IoC)** 의 한 형태이다.
- 클래스는 의존 객체를 스스로 생성하지 않고 **외부에서 주입받는다**.
- 이로써 클래스는 **수동적인 구조**가 되며, 단일 책임 원칙을 지키게 된다.
- DI는 **설정자(setter)**, **생성자 인수**, **설정 파일** 등을 통해 의존성을 주입하는 방식이다.
- DI 컨테이너는 필요한 객체를 생성한 후 주입 방식에 따라 **의존성을 설정해준다**.
- 실제 생성할 객체는 설정 파일이나 생성 모듈 코드에 **명시되어야 한다**.
- 스프링 프레임워크는 **대표적인 자바 DI 컨테이너**이다.
- DI 컨테이너는 대부분 **계산 지연, 팩토리, 프록시 등 최적화 기법**도 함께 제공한다.
