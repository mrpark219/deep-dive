# 시스템

## 1. 도시를 세운다면?

- 도시는 적절한 **추상화와 모듈화** 덕분에 돌아가는 구조이다.
- 전체를 이해하지 못해도 각 구성요소가 효율적으로 동작하도록 되어 있다.
- 소프트웨어 시스템도 마찬가지로 추상화와 모듈화가 기반이 되어야 한다.
- 시스템이 복잡해지는 이유는 관심사를 제대로 분리하지 못했기 때문이다.
- **깨끗한 코드**는 낮은 수준에서도 관심사를 **명확히 분리**할 수 있도록 도와주는 도구이다.

## 2. 시스템 제작과 시스템 사용을 분리하라

- **시스템 제작(construction)** 과 **사용(use)** 은 서로 다른 성격을 가진다.
- 소프트웨어 시스템은 애플리케이션 객체를 생성하고 의존성을 설정하는 준비 과정과 그 이후의 실행 로직을 분리해야 한다.
- 이러한 분리는 모든 애플리케이션이 반드시 해결해야 할 **핵심 관심사(concern)** 이다.
- 관심사 분리는 가장 오래된 **중요한 설계 기법** 중 하나이다.

```java
public Service getService() {
    if (service == null) {
        service = new MyServiceImpl();
    }

    return service;
}
```

- 위는 **초기화 지연(Lazy Initialization)** 또는 **계산 지연(Lazy Evaluation)** 기법의 예시이다.
- 한두 번 사용하는 것은 문제가 없지만, 많은 애플리케이션이 이 기법을 반복적으로 사용하면서 전반적인 설정 코드가 시스템 곳곳에 흩어져 있는 문제가 발생한다.
- 이런 방식은 **모듈성과 일관성**을 해치며 **중복 문제**를 유발하기 쉽다.
- 객체 생성과 의존성 연결을 일반 실행 로직과 **분리**해야 한다.
- 전반적인 의존성을 일관된 방식으로 설정해야 한다.

### 2.1 장점

- 필요할 때까지 객체를 생성하지 않기 때문에 **불필요한 부하를 줄일 수 있다**.
- 애플리케이션 시작 속도를 **향상시킬 수 있다**.
- **null 포인터를 반환하지 않는다**.

### 2.2 단점

- `getService()`는 `MyServiceImpl`에 **명시적으로 의존한다**.
- 런타임에 사용하지 않더라도 의존성이 해결되지 않으면 **컴파일되지 않는다**.
- 무거운 객체일 경우 테스트에서 **대체가 어렵다**.
- 객체 생성 로직이 일반 실행 로직에 **혼재되어 있어 책임이 두 가지이다**.
- `MyServiceImpl`이 모든 상황에 적합한지 **확신할 수 없다**.

### 2.3 Main 분리

- 생성 관련 코드는 **모두 main이나 설정 모듈로 이동시켜야 한다**.
- 나머지 시스템은 모든 객체가 생성되고 의존성도 연결된 상태라고 **가정하고 동작해야 한다**.
- 애플리케이션은 객체 생성 과정을 **몰라도 된다**.

### 2.4 팩토리 패턴

- 객체를 언제 생성할지는 애플리케이션이 결정하되 **생성 방법은 감춰야 한다**.
- 예를 들어 주문 처리 시스템에서 `LineItem`을 생성할 때는 **ABSTRACT FACTORY 패턴을 사용해야 한다**.
- 생성 방식이 변경되더라도 애플리케이션에는 **영향을 주지 않는다**.

### 2.5 의존성 주입

- 의존성 주입은 **제어 역전(Inversion of Control, IoC)** 의 한 형태이다.
- 클래스는 의존 객체를 스스로 생성하지 않고 **외부에서 주입받는다**.
- 이로써 클래스는 **수동적인 구조**가 되며, 단일 책임 원칙을 지키게 된다.
- DI는 **설정자(setter)**, **생성자 인수**, **설정 파일** 등을 통해 의존성을 주입하는 방식이다.
- DI 컨테이너는 필요한 객체를 생성한 후 주입 방식에 따라 **의존성을 설정해준다**.
- 실제 생성할 객체는 설정 파일이나 생성 모듈 코드에 **명시되어야 한다**.
- 스프링 프레임워크는 **대표적인 자바 DI 컨테이너**이다.
- DI 컨테이너는 대부분 **계산 지연, 팩토리, 프록시 등 최적화 기법**도 함께 제공한다.

## 3. 확장

- **처음부터 완벽한 시스템을 만들 수 있다는 믿음은 환상이다**.
- 우리는 현재 주어진 **사용자 스토리에 맞춰 시스템을 구현**하고,  
  새로운 요구사항이 생기면 **점진적으로 조정하고 확장해야 한다**.
- 이러한 접근은 **애자일 방식의 핵심 원칙**이며, 테스트 주도 개발(TDD), 리팩터링, 깨끗한 코드는 **코드 수준에서의 유연한 변경을 가능하게 한다**.
- 다만 시스템 수준에서는 **아키텍처 자체가 복잡하기 때문에 단순하게 키워나가기 어렵다**.
- 하지만 **관심사를 명확히 분리하고 모듈화한다면**, 소프트웨어 시스템은 점진적으로 성장할 수 있다.
- 반면 EJB2 같은 과거의 시스템에서는 **비즈니스 로직이 컨테이너에 강하게 결합되었다**.
- 개발자는 특정 컨테이너에서 파생된 클래스를 사용하고, 컨테이너가 요구하는 **복잡한 생명주기 메서드를 직접 구현해야 했다**.

### 3.1 횡단 관심사(Cross-Cutting Concerns)

- EJB2 아키텍처는 **관심사 분리 측면에서 일부 효과를 보였다**.
- 특히 **영속성, 보안, 트랜잭션 처리와 같은 횡단 관심사**를 애플리케이션 전반에 일관되게 적용하려고 시도했다.
- 하지만 이러한 관심사들은 **여전히 여러 객체에 흩어져 구현되는 경우가 많았다**.
- 이 문제를 해결하려는 접근 방식 중 하나가 **관점 지향 프로그래밍(AOP)** 이다.
- AOP는 **특정 관심사를 하나의 관점(aspect)으로 묶어 시스템 동작의 일부 지점을 일관성 있게 수정**할 수 있도록 한다.
- 결과적으로 **핵심 비즈니스 로직과 부가 관심사(로깅, 트랜잭션 등)를 깔끔하게 분리할 수 있다**.

## 4. 자바 프록시

- 단순한 상황에서 적합한 방식이다.
- 주로 **개별 객체나 클래스의 메서드 호출을 감싸는 경우에 사용**된다.
- **JDK의 동적 프록시는 인터페이스만 지원한다**.
- 클래스를 프록시하려면 바이트 코드 조작 라이브러리가 필요하다.
- 프록시는 코드 양이 많아지고 코드가 복잡해지는 단점이 있다.
- 깨끗한 코드를 작성하기 어렵고, 실행 지점을 시스템 전체에서 명시적으로 관리하기도 어렵다.

## 5. 순수 자바 AOP 프레임워크

- 대부분의 프록시 코드는 유사한 구조이므로 도구를 통해 자동화할 수 있다.
- **Spring AOP, JBoss AOP는 내부적으로 프록시를 활용한다**.
- **Spring은 비즈니스 로직을 POJO(Plain Old Java Object)로 구현하도록 유도한다**.
- **POJO는 도메인에만 집중하며, 엔터프라이즈 프레임워크에 의존하지 않는다**.
- 이로 인해 개념적으로 테스트가 쉽고 유연하다.
- 프로그래머는 설정 파일이나 API를 사용해 필요한 기반 구조를 구성한다.
- 프레임워크는 사용자에게 보이지 않게 프록시나 바이트 코드 라이브러리를 활용해 해당 기능을 구현한다.

## 6. AspectJ 관점

- AspectJ는 **관심사를 관점으로 분리하는 가장 강력한 도구**이다.
- 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.
- 순수한 자바 코드에 애너테이션을 사용해 관점을 정의할 수 있다.

## 7. 테스트 주도 시스템 아키텍처 구축

- 관점으로 관심사를 분리하는 방식은 **아키텍처 설계에 매우 강력한 접근법**이다.
- 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면, 코드 수준에서 아키텍처 관심사를 분리할 수 있다.
- 그 결과, **진정한 테스트 주도 아키텍처 구축이 가능해진다**.
- BDUF(Big Design Up Front)는 피해야 할 접근 방식이다.
- 초기 설계에 집착하면 변경을 수용하기 어려워진다.
- **소프트웨어는 단순하고 잘 분리된 아키텍처를 기반으로 빠르게 출시하고, 기반 구조는 점진적으로 확장해야 한다**.

## 8. 의사 결정을 최적화하라

- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 의사결정이 가능해진다.
- 가장 적합한 사람에게 책임을 맡기는 것이 가장 이상적이다.
- **가능한 마지막 순간까지 결정을 미루는 전략이 때때로 최선이다**.
- 정보를 최대한 확보한 후 의사결정을 내려야 한다.

## 9. 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 표준은 아이디어와 컴포넌트의 재사용성을 높여준다.
- 적절한 경험을 가진 인재를 찾기 쉬우며, 좋은 아이디어를 캡슐화하고 컴포넌트를 쉽게 연결할 수 있다.
- **표준은 명백한 가치가 있을 때만 채택해야 한다**.
- 일부 표준은 시간이 너무 오래 걸리거나, 본래 목적을 잊고 남용되기도 한다.

## 10. 시스템은 도메인 특화 언어가 필요하다

- DSL(Domain-Specific Language)은 간단한 스크립트 언어나 API 수준에서 정의한 언어를 의미한다.
- **DSL로 작성한 코드는 도메인 전문가가 작성한 문서처럼 읽힌다**.
- 좋은 DSL은 도메인 개념과 구현 코드 간의 의사소통 간극을 줄여준다.
- **DSL은 코드 관용구나 디자인 패턴보다 높은 추상화 수준을 제공한다**.
- 고차원 정책부터 저차원 세부사항까지, 모든 추상화 수준과 도메인을 POJO로 표현할 수 있다.

## 11. 마무리

- **깨끗하지 못한 아키텍처는 도메인 논리를 흐리고, 팀의 기민성과 제품 품질을 떨어뜨린다**.
- 기민성이 떨어지면 생산성이 낮아지고, TDD가 제공하는 장점도 사라진다.
- **모든 추상화 단계에서 의도는 명확히 표현되어야 한다**.
- 이를 위해 POJO를 사용하고, 관점 혹은 유사한 메커니즘을 활용해 각 구현 관심사를 분리해야 한다.
- 시스템을 설계하든, 개별 모듈을 설계하든 **실제로 돌아가는 가장 단순한 수단을 선택해야 한다**.
