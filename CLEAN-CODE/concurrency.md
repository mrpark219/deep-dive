# 동시성

- **동시성과 깔끔한 코드는 양립하기 어렵다**.
- 스레드를 하나만 실행하는 코드는 구현이 단순하다.
- 하지만 멀쩡해 보이지만 내부에 결함이 숨겨진 다중 스레드 코드를 작성하기 쉽다.
- 이러한 코드는 시스템에 부하가 걸리기 전까지는 문제 없이 동작하는 것처럼 보인다.

## 1. 동시성이 필요한 이유?

- **동시성은 결합(coupling)을 없애는 전략이다**.
- 이는 **무엇(what)** 과 **언제(when)** 를 분리하는 방식이다.
- 스레드가 하나뿐인 프로그램에서는 무엇과 언제가 서로 밀접하게 연관되어 있다.
- 따라서 호출 스택만 확인해도 프로그램 상태를 쉽게 파악할 수 있다.
- 단일 스레드 프로그램은 디버깅 시 정지점(breakpoint)을 설정해 현재 상태를 추적할 수 있다.
- **무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 향상된다**.
- 구조적 측면에서 보면 프로그램은 하나의 거대한 루프가 아니라 **작은 협력 프로그램들로 구성된다**.
- 이로 인해 시스템 이해도와 문제 분리도 용이해진다.
- 일부 시스템은 **응답 시간과 작업 처리량(throughput)** 향상 요구 때문에 **직접적인 동시성 구현이 필수적이다**.

### 1.1 미신과 오해

- 반드시 동시성을 도입해야 하는 상황이 존재하지만, **동시성은 어렵고 신중해야 한다**.

#### 잘못된 믿음

- **동시성은 항상 성능을 높여준다**.
  - 동시성은 때로 성능을 높일 수 있지만, 이는 다음 조건에서만 해당한다.
    - 대기 시간이 길어 **여러 스레드가 프로세서를 공유할 수 있는 경우**
    - 여러 프로세스가 **동시에 독립적인 계산을 수행할 수 있는 경우**
    - **이러한 조건은 흔치 않다**.
- **동시성을 구현해도 설계는 바뀌지 않는다**.
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 완전히 다르다.
  - 무엇과 언제를 분리하면 시스템 구조 자체가 **크게 달라진다**.
- **웹 또는 EJB 컨테이너를 사용하면 동시성을 이해하지 않아도 된다**.
  - 실제로는 컨테이너 내부 동작 방식과, **동시 수정이나 데드락을 피하는 방법**을 반드시 이해해야 한다.

#### 타당한 사실

- **동시성은 부하를 유발한다**.
  - 성능에 영향을 줄 수 있으며, **더 많은 코드를 작성해야 한다**.
- **동시성은 복잡하다**.
  - 간단한 문제조차도 동시성을 적용하면 **복잡도가 급격히 증가한다**.
- **동시성 버그는 재현하기 어렵다**.
  - 그래서 흔히 **일회성 문제로 오인되어 무시되기 쉽다**.
- **동시성을 구현하려면 근본적인 설계 전략을 다시 생각해야 한다**.

## 2. 난관

```java
public class X {
    private int lastIdUsed;

    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

- 위 코드는 인스턴스 `X`를 생성하고 `lastIdUsed` 필드를 42로 설정한 다음, 두 스레드가 해당 인스턴스를 공유하는 상황을 가정한다.
- 이 상태에서 두 스레드가 `getNextId()`를 호출할 경우 다음과 같은 **세 가지 결과 중 하나가 발생할 수 있다.**

  1. **한 스레드는 43을 받고, 다른 스레드는 44를 받으며, `lastIdUsed`는 44가 된다.**
  2. **한 스레드는 44를 받고, 다른 스레드는 43을 받으며, `lastIdUsed`는 44가 된다.**
  3. **두 스레드가 모두 43을 받고, `lastIdUsed`는 43이 된다.**

- 세 번째 경우는 **명백한 오류**이다.
- 이는 두 스레드가 같은 변수에 **동시에 접근**하면서 발생한다.
- 자바 코드 한 줄을 **여러 스레드가 동시에 실행**할 경우, **내부적으로 수많은 실행 경로**가 존재하고, 그 중 일부는 **잘못된 결과**를 만들어낸다.

## 3. 동시성 방어 원칙

### 3.1 단일 책임 원칙(Single Responsibility Principle, SRP)

- SRP는 주어진 메서드, 클래스, 컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
- 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다.
- **동시성 관련 코드는 다른 코드와 분리해야 한다**.
- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
- **동시성 문제는 다른 코드와 다른 종류의 난관을 수반하며, 더 어렵다**.
- 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

### 3.2 따름 정리(corollary): 자료 범위를 제한하라

- **공유 객체의 동일 필드를 두 스레드가 수정하면 예기치 않은 결과가 발생할 수 있다**.
- 이를 방지하기 위해 **공유 객체에 접근하는 코드를 `synchronized`로 감싸는 방식이 일반적이다**.
- **하지만 임계 영역의 수를 줄이는 것이 핵심이다**.
- 공유 자료를 줄이고, 캡슐화하며, 가능하면 독립적인 단위로 분할해야 한다.
- 보호해야 할 임계 영역을 빠뜨리면 공유 자료를 수정하는 모든 코드가 깨질 수 있다.
- 모든 임계 영역이 제대로 보호되었는지 확인하려면 많은 수고가 든다.
- 동시성 버그는 **발견이 어렵고**, 문제를 파악하는 데 시간이 오래 걸릴 수 있다.

#### 따름 정리: 자료 사본을 사용하라

- **처음부터 공유하지 않는 것이 가장 좋은 전략이다**.
- 경우에 따라 객체를 복사해 읽기 전용으로 사용하거나, 각 스레드가 사본을 만들어 결과만 가져오게 할 수 있다.
- 복사에 시간이 들 수 있지만, **동기화를 피한다면 오히려 성능이 좋아질 수 있다**.

#### 따름 정리: 스레드는 가능한 독립적으로 구현하라

- **다른 스레드와 자료를 공유하지 않는 스레드를 구현하면 복잡도를 줄일 수 있다**.
- 각 스레드는 클라이언트 요청 하나만 처리하고, 필요한 정보는 로컬 변수에 저장한다.
- 이렇게 하면 동기화 없이 독립적으로 동작할 수 있다.

## 4. 라이브러리를 이해하라

- **언어나 프레임워크에서 제공하는 동시성 라이브러리를 잘 이해하고 활용해야 한다**.
- 동기화, 락, 스레드 풀, 큐 등은 대부분의 언어에서 표준 라이브러리로 제공된다.
- **직접 구현하기보다 검증된 라이브러리를 사용하는 것이 안정성과 생산성을 높이는 길이다**.
- 예를 들어 Java에서는 `synchronized`, `volatile`, `ReentrantLock`, `ExecutorService`, `ConcurrentHashMap` 등이 있다.
