# 냄새와 휴리스틱

## 1. 주석

### 1.1 부적절한 정보

- 다른 시스템(Jira 티켓 ID, 소스 코드 히스토리 등)에 저장할 정보는 **주석으로 작성하는 것이 적절하지 않다**.
- **주석은 코드와 설계에 대한 기술적인 설명을 부연하는 수단이다**.

### 1.2 쓸모없는 주석

- **오래되었거나 현재 코드와 맞지 않는 주석은 의미가 없다**.
- 향후 쓸모없어질 주석이라면 **애초에 달지 않는 것이 낫다**.

### 1.3 중복된 주석

- **코드만으로 충분한 설명을 다시 반복하는 주석은 중복이다**.
- **주석은 코드로 표현할 수 없는 맥락이나 배경 정보를 설명할 때만 사용해야 한다**.

### 1.4 성의 없는 주석

- 주석을 쓸 거라면 **정확하고 간결하게** 작성해야 한다.
- **성의 없는 주석은 오히려 혼란을 초래한다**.

### 1.5 주석 처리된 코드

- 코드 중간에 **주석 처리된 코드가 많으면 가독성을 해친다**.
- 얼마나 오래되었고, 현재 시스템에 어떤 영향을 주는지 **판단할 수 없기 때문에 삭제를 주저하게 된다**.
- 하지만 **그렇기 때문에 더욱더 모듈을 오염시키고 유지보수를 어렵게 만든다**.
- **주석 처리된 코드는 발견 즉시 삭제하는 것이 원칙이다**.
- **버전 관리 시스템이 변경 이력을 보존하므로 필요한 경우 언제든 복원할 수 있다**.

## 2. 환경

### 2.1 여러 단계로 빌드해야 한다

- **빌드는 반드시 한 단계로 끝나야 한다**.
- 소스 코드 관리 시스템에서 이것저것 **따로 체크아웃할 필요가 없어야 한다**.
- **불필요한 명령어, 복잡한 스크립트 실행 없이 전체를 빌드할 수 있어야 한다**.
- **한 명령으로 전체를 체크아웃하고, 한 명령으로 전체를 빌드할 수 있어야 한다**.

### 2.2 여러 단계로 테스트해야 한다

- **모든 단위 테스트는 단 한 줄의 명령으로 실행 가능해야 한다**.
- IDE에서 **버튼 하나로 전체 테스트가 돌아가는 환경이 이상적이다**.
- **빠르고, 쉽고, 명확한 방법으로 전체 테스트를 실행할 수 있어야 한다**.
- 이는 **소프트웨어 품질 유지에 있어 근본적이고 필수적인 요소다**.

## 3. 함수

### 3.1 너무 많은 인수

- **함수의 인수는 작을수록 좋다**.
- 인수가 **0개일 때 가장 이상적이다**.
- **넷 이상이라면 함수 자체의 설계가 의심스럽다**.
- 이럴 땐 **인수 객체로 묶거나 클래스로 추출해 재설계하는 것이 바람직하다**.

### 3.2 출력 인수

- **출력 인수는 직관에 반하는 설계다**.
- 일반적으로 **인수는 입력값이라는 인식이 강하기 때문에**, 출력 인수를 사용하면 **혼란을 초래한다**.
- 어떤 상태를 변경해야 한다면, **함수가 속한 객체의 내부 상태를 변경하거나 명시적으로 반환값으로 처리해야 한다**.

### 3.3 플래그 인수

- **boolean 같은 플래그 인수는 함수가 여러 기능을 한다는 신호다**.
- 하나의 함수가 두 가지 이상의 역할을 하는 것은 **SRP 위반이며 유지보수성을 떨어뜨린다**.
- **플래그 인수를 없애고, 목적별로 함수를 분리하는 것이 좋다**.

### 3.4 죽은 함수

- **아무도 호출하지 않는 함수는 과감히 삭제해야 한다**.
- 낭비를 줄이고 명확성을 높이기 위해 불필요한 코드는 제거한다.

## 4. 일반

### 4.1 한 소스 파일에 여러 언어를 사용한다

- JSP 파일은 HTML, 자바, 태그 라이브러리 구문 등을 포함한다.
- 이상적으로는 **소스 파일 하나에 언어 하나만 사용하는 방식이 좋다**.
- 각별한 노력을 기울여 **소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다**.

### 4.2 당연한 동작을 구현하지 않는다

- 최소 놀람의 원칙(The Principle of Least Surprise)에 따라 **함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작을 제공해야 한다**.
- 그렇지 않으면 **함수 이름만 보고 기능을 직관적으로 예측하기 어려워진다**.

### 4.3 경계를 올바로 처리하지 않는다

- **코드는 올바로 동작해야 한다**. 또한, 올바른 동작이 아주 복잡하다는 사실을 간과해서는 안 된다.
- **모든 경계 조건, 구석진 경우, 기벽, 예외는 철저히 다뤄야 한다**.
- 직관에 의존하지 말고 **테스트 케이스를 작성하여 모든 경계 조건을 확인해야 한다**.

### 4.4 안전 절차 무시

- **안전 절차를 무시하면 위험하다**.
- **컴파일러 경고 일부를 끄면 빌드는 쉬워질지 모르지만, 끝없는 디버깅에 시달릴 수 있다**.

### 4.5 중복

- **중복은 제거해야 한다**.
- 데이비드 토머스와 앤디 헌트는 이를 **DRY(Don’t Repeat Yourself)** 원칙이라 부른다.
- 켄트 벡은 이를 **Once, and only once**라고 했다.
- **코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라**.
- **중복된 코드는 하위 루틴이나 클래스 분리로 제거한다**.
- **추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다**.

#### 중복의 주요 유형과 대응 방식

- **복사-붙여넣기 중복**: 간단한 함수로 치환한다.
- **조건문 반복**: 여러 모듈에서 동일한 `if` / `switch` 조건을 반복한다면 **다형성으로 대체한다**.
- **유사한 알고리즘 중복**: 알고리즘은 유사하나 코드가 다를 경우, **TEMPLATE METHOD** 또는 **STRATEGY 패턴**을 적용한다.

### 4.6 추상화 수준이 올바르지 못하다

- **추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리하는 것이다**.
- 모든 **저차원 개념은 파생 클래스에**, 모든 **고차원 개념은 기초 클래스에 넣어야 한다**.
- **세부 구현과 관련된 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안 된다**.
- **기초 클래스는 구현 세부사항에 무지해야 한다**.

### 4.7 기초 클래스가 파생 클래스에 의존한다

- **기초 클래스와 파생 클래스를 구분하는 이유는 고차원 개념과 저차원 개념을 분리해 독립성을 보장하기 위해서다**.
- 따라서 **기초 클래스는 파생 클래스를 전혀 몰라야 한다**.
- 간혹 **파생 클래스의 수가 고정되어 있으면**, **기초 클래스에 파생 클래스 선택 코드가 들어갈 수 있다**.
- 대표적인 예시로 **FSM(Finite State Machine)** 구조가 있다.
  - FSM: 입력에 따라 현재 상태에서 다음 상태로 전이되는 시스템이다. 미리 정의된 대로 입력에 따라 동작하는 Machine을 의미한다.

### 4.8 과도한 정보

- **잘 정의된 모듈은 작은 인터페이스로도 많은 동작이 가능하다**.
- 부실하게 정의된 모듈은 인터페이스가 구질구질하며, 결합도가 높고 사용이 어렵다.
- **클래스나 모듈은 외부에 노출하는 함수를 최소화해야 한다**.
- 클래스가 제공하는 메서드 수는 작을수록 좋고, 함수가 접근하는 변수 수도 작을수록 좋다.
- 자료, 유틸리티 함수, 상수, 임시 변수는 숨기는 것이 바람직하다.
- **메서드와 인스턴스 변수가 넘쳐나는 클래스는 피해야 한다**.

### 4.9 죽은 코드

- **죽은 코드란 실행되지 않는 코드를 말한다.**
- 예: 불가능한 조건의 if 문, throw 문이 없는 try-catch 구문
- 죽은 코드는 시간이 지나면 설계와 어긋나 악취를 풍기기 시작한다.
- **죽은 코드를 발견하면 시스템에서 제거한다.**

### 4.10 수직 분리

- **변수와 함수는 사용되는 위치에 가깝게 정의한다**.
- 지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치해야 한다.
- **비공개 함수는 처음 호출한 직후에 정의한다.**
- 비공개 함수는 처음으로 호출되는 위치를 찾은 후 조금만 아래로 내려가면 찾을 수 있어야 한다.
