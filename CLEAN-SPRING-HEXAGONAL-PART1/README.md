# 토비의 클린 스프링 - 도메인 모델 패턴과 헥사고날 아키텍처 Part 1

## 1. 도메인 모델

- **도메인(Domain)** 이란, 소프트웨어가 해결하고자 하는 **특정 주제 영역 또는 문제 영역**이다.
- 소프트웨어는 이러한 도메인을 반영해야 하는데, 현실 세계의 도메인을 코드로 직접 옮길 수는 없다. 따라서 도메인을 추상화한 **도메인 모델**을 만들어야 한다.
- 도메인 모델은 특정 문제 영역의 **핵심 지도**와 같다. 이는 도메인에 존재하는 **중요한 개념과 규칙, 그리고 이들 사이의 관계를 표현**하는 것이다.

## 2. 도메인 주도 설계 (DDD)

- **도메인 주도 설계(DDD, Domain-Driven Design)** 는 복잡한 도메인의 문제를 해결하기 위한 접근법으로, **도메인 모델을 개발 과정의 중심에 두는 것**이다.
- DDD에서는 개발자뿐만 아니라, 도메인 전문가와 이해관계자 등 **모두가 함께 참여**하여 도메인 모델을 만들고 지속적으로 발전시킨다.
- DDD의 핵심 사상은 다음과 같다.
  - **모델 주도 설계 (Model-Driven Design)**: 도메인 모델이 실제 설계와 코드까지 일관되게 이어져야 한다.
  - **보편 언어 (Ubiquitous Language)**: 팀 안에서 도메인 모델에 기반한 단일 어휘 체계를 만들고, 이를 회의, 문서, 코드 등 모든 곳에서 일관되게 사용해야 한다.

## 3. 도메인 모델 만들기

- **1. 듣고 배우기**
  - 도메인 전문가(domain expert)의 설명을 통해 **도메인에 대한 지식을 습득**하는 단계이다.
- **2. 핵심 개념 식별**
  - 설명에서 드러나는 **핵심적인 개념과 단어(용어)들을 식별**하는 단계이다.
- **3. 관계 정의**
  - 앞에서 식별한 **개념들 사이의 연결고리, 즉 관계를 정의**하는 단계이다.
- **4. 속성 및 행위 명시**
  - 각 개념이 가지는 **핵심적인 속성(데이터)과 기본 행위(기능)를 명시**하는 단계이다.
- **5. 시각화**
  - 개념들 사이의 관계를 **그림으로 도식화하여 모델을 가시적으로 표현**하는 단계이다.
- **6. 반복하며 다듬기**
  - 완성된 모델을 바탕으로 **전문가와 다시 이야기하며 지속적으로 모델을 다듬고 발전**시키는 단계이다.

## 4. 도메인 전문가가 없다면

- **가상 도메인 전문가 활용**
  - 창업가, 기획자, PO(Product Owner) 등 **비즈니스에 대한 이해도가 가장 높은 사람**을 가상의 도메인 전문가로 삼아 협력하는 것이다.
- **집단적 학습**
  - **이벤트 스토밍(Event Storming)** 과 같은 워크숍을 통해, 여러 이해관계자가 모여 함께 도메인을 탐색하고 학습하는 것이다.
- **가설 기반의 점진적 모델링**
  - 처음부터 완벽한 모델을 추구하는 대신, **가설을 세우고 빠르게 프로토타입을 만들어 검증**하며 점진적으로 모델을 발전시키는 것이다.
- **보편 언어의 의식적 구축**
  - 팀 내에서 사용하는 용어를 **의식적으로 통일하고, 문서를 통해 공유**하며 보편 언어(Ubiquitous Language)를 점진적으로 만들어 나가는 것이다.
- **초기 사용자와의 적극적인 소통**
  - 베타 테스터나 초기 사용자들의 피드백을 통해 **실제 사용자의 관점에서 도메인을 이해**하고 모델을 개선하는 것이다.
- **경쟁 서비스 분석**
  - 경쟁 업체의 서비스를 분석하여, 해당 **도메인의 일반적인 기능과 용어를 학습**하는 것이다.
- 결론적으로, 도메인 전문가가 없는 환경에서는 도메인 모델을 **더욱 적극적으로 공유하고 지속적으로 발전**시키려는 노력이 훨씬 더 중요하다.

## 5. 엔티티(Entity)

- 도메일 모델을 만들 떄 사용하는 패턴
- 도메인 안에 있는 대상이나 개념
- 고유한 식별자(identity)를 가지고 이를 통해서 개별적으로 구분된다
- 생명주기(life cycle)를 가진다. 시간의 흐름에 따라 상태가 변경될 수 있다.

## 6. 도메인 모델 패턴

### 6.1. 도메인 모델 패턴 (Domain Model Pattern)

- **도메인 모델 패턴**은 도메인의 비즈니스 로직을 구성하는 아키텍처 패턴의 한 종류이다.
- 이 패턴은 도메인의 **데이터(속성)와 기능(행위)을 모두 가진 객체 모델**을 만드는 것이 특징이다.
- 객체 모델을 기반으로 하므로, **복잡한 연관 관계, 상속 등 객체지향의 장점을 활용**하여 도메인을 풍부하게 표현할 수 있다.

### 6.2. 트랜잭션 스크립트 패턴 (Transaction Script Pattern)

- **트랜잭션 스크립트 패턴**은 하나의 업무 절차(트랜잭션)를 처리하기 위한 **단일 메서드(스크립트)** 를 만드는 방식이다.
- 이 메서드 안에서 **필요한 비즈니스 로직을 순서대로 코드로 작성**하며, 주로 절차적인 방식으로 구현된다.
- 도메인 모델 패턴에 비해, **단순한 비즈니스 로직을 빠르고 간단하게 구현**할 때 주로 사용된다.

## 7. 값 객체 (Value Object)

- 도메인 모델에서 **고유한 식별자(ID) 없이, 오직 속성(값)만으로 구별**되는 객체를 **값 객체(Value Object)** 라고 한다.
- 값 객체는 다음과 같은 특징과 장점을 가진다.
  - **책임 분리**: 특정 속성과 관련된 행위를 값 객체로 분리하여, **엔티티가 핵심 책임에만 집중**하도록 돕는다.
  - **개념 명시**: `String`과 같은 원시 타입보다 **'Email', 'Money'와 같이 도메인 개념을 더 명시적**으로 나타내어 모델의 명확성을 높인다.
  - **불변성(Immutability)**: 생성된 이후에는 상태가 변하지 않는다. 변경이 필요하면 **새로운 객체로 교체**해야 한다.
  - **풍부한 기능**: 관련된 **비즈니스 로직(행위)을 자신의 메서드로** 가질 수 있다.
  - **자체 유효성 검사**: 생성 시점에 **스스로 자신의 유효성을 검사**하는 로직을 포함할 수 있다.

### 7.1. 원시 타입 포장 (Wrap Primitive Type)

- **원시 타입 포장**은 `String`, `int`와 같은 원시 타입의 남용을 개선하고, **코드의 명시성과 안정성을 높이는 리팩터링 기법**이다.
- 이는 단순한 값을 **도메인의 핵심 구성요소인 값 객체로 만들어**, 값 자체의 의미와 불변성, 동등성 비교와 같은 도메인 로직을 포함하도록 설계하는 방식이다.

## 8. 도메인 모델 패턴의 두 가지 스타일

- **단순한 도메인 모델 (Simple Domain Model)**
  - 데이터베이스 테이블 구조와 유사하게, **하나의 테이블에 하나의 도메인 객체를 매핑**하는 방식이다. 구현이 단순하고 직관적인 장점이 있다.
- **풍성한 도메인 모델 (Rich Domain Model)**
  - 상속, 전략 패턴(Strategy Pattern) 등 **다양한 디자인 패턴을 적용**하여 복잡한 로직을 표현하는 방식이다. 도메인을 풍부하게 표현할 수 있지만, 데이터베이스 매핑이 어려워질 수 있다.

## 9. 도메인 로직의 API 개발

- 도메인 모델 패턴은 객체들의 상호작용으로 로직이 구현되므로, 트랜잭션 스크립트 패턴처럼 **명확한 작업 단위(Use Case)를 API로 제공하기가 어렵다**.
- 따라서, 도메인 모델 위에서 **명확한 작업 단위 API를 제공하는 애플리케이션 서비스(Application Service)** 계층이 별도로 필요하다.

## 10. 헥사고날 아키텍처(Hexagonal Architecture)의 사실과 오해

### 10.1. 아키텍처

- **아키텍처**란, 시스템의 **기본적인 구조와 구성 요소, 그리고 그 관계를 정의**하는 것이다.
- 이는 시스템의 중요한 품질 속성에 큰 영향을 미치며, 설계 결정의 기반이 되는 핵심적인 개념이다.

### 10.2. 계층형 아키텍처

- 서브 시스템을 **계층(Layer)으로 구조화**하는 아키텍처 스타일이다.
- 핵심 제약은 **상위 계층이 하위 계층의 서비스를 사용하는 단방향 의존 관계**를 가져야 한다는 점이다.
- 각 계층은 하위 계층의 내부를 알지 못하며, 제한된 인터페이스만 사용해야 한다 (계층 격리).

### 10.3. 3계층 아키텍처

- 일반적으로 **UI(표현), Domain(비즈니스 로직), Data(영속성)** 세 가지 계층으로 구성된다.
- **UI**: 사용자와의 접점으로, 정보를 보여주고 입력을 받는 역할을 한다.
- **Domain**: 소프트웨어가 해결하고자 하는 핵심 비즈니스 로직을 처리한다.
- **Data**: 데이터베이스와의 통신을 담당하는 영속성 계층이다.

### 10.4. 4계층 아키텍처

- 3계층 구조에서 **Domain 계층을 애플리케이션 서비스(Application Service)와 도메인(Domain)으로 분리**하여 4계층 구조를 만들 수 있다.
- 애플리케이션 서비스는 **명확한 작업 단위(Use Case) API를 제공**하는 역할을 한다.

### 10.5. 헥사고날 아키텍처

- 헥사고날 아키텍처는 계층형 아키텍처와 달리, **'내부(Inside)'와 '외부(Outside)'라는 대칭적인 구조**를 가진다.
- 아키텍처의 대칭 구조를 표현하기 위해 육각형 도형을 사용하며, **육각형 모양 자체가 특별한 의미를 갖는 것은 아니다**.

#### 헥사곤의 내부: 애플리케이션

- 쉽게 변하지 않는, **중요한 비즈니스 로직과 도메인 모델을 담은 코어(Core)** 영역이다.

#### 헥사곤의 외부: 액터(Actor)

- 애플리케이션과 상호작용하는 모든 것을 의미하며, 사용자, 외부 시스템, DB, 테스트 코드 등이 모두 **액터(Actor)** 에 해당한다.

### 10.6. 헥사고날 아키텍처의 특징과 혜택

- **테스트 용이성**: 운영 시스템(DB 등)에 직접 연결하지 않고도 **애플리케이션 코어 로직을 독립적으로 테스트**할 수 있다.
- **관심사의 분리**: UI나 데이터베이스 같은 **기술적인 세부 사항이 도메인 로직에 노출되는 것을 막는다**.
- **유연한 기술 교체**: 시간이 지나면서 **외부 기술(DB, 프레임워크 등)을 다른 것으로 손쉽게 교체**할 수 있다.
- **도메인 집중**: 기술적인 요소가 분리되므로, **개발자가 핵심 비즈니스 로직 설계에만 집중**할 수 있다.

### 10.7. 헥사곤(내부)을 부르는 여러 이름

- 헥사곤(Hexagon)
- **애플리케이션(Application)**
- 앱(App)
- 코어 시스템(Core System)
- SuD(System under Development)
- SuT(System under Test)

### 10.8. 액터와 애플리케이션의 상호작용: 포트(Port)

- **포트**란, 애플리케이션이 **명확한 목적(Intention)을 가지고 외부 세계와 상호작용하는 통로**이다.
- 이는 단순히 데이터를 주고받는 것을 넘어, 명확한 목적과 방향을 가지고 외부와 연결됨을 의미한다.
- 포트는 애플리케이션이 **직접 정의한 인터페이스**로 만들어진다.

### 10.9. 포트의 두 가지 종류: 인터페이스

- **Provided Interface (제공 인터페이스) 🍭**
  - 애플리케이션이 외부 액터에게 **제공하는 기능**에 대한 인터페이스이다.
- **Required Interface (요구 인터페이스) 🧲**
  - 애플리케이션이 외부 액터에게 **요구하는 기능**에 대한 인터페이스이다.

### 10.10. 액터의 두 가지 종류

- **Primary Actor**
  - 애플리케이션이 **제공하는 기능(Provided Interface)을 사용하는 액터**이다. (예: 사용자, 다른 시스템)
- **Secondary Actor**
  - 애플리케이션이 **요구하는 기능(Required Interface)을 제공하는 액터**이다. (예: 데이터베이스, 외부 API)

### 10.11. 어댑터 (Adapter)

- **어댑터**는 애플리케이션의 포트와 외부 액터 간의 **인터페이스를 변환**해주는 역할을 한다.
  - 브라우저(액터)가 회원 가입 포트를 사용하려면, **웹 컨트롤러**가 브라우저의 HTTP 요청을 포트가 이해할 수 있는 메서드 호출로 변환하는 어댑터가 된다.
  - 애플리케이션이 회원 정보 저장 포트를 통해 DB(액터)에 접근하려면, **리포지터리 구현체**가 포트의 인터페이스를 DB가 이해할 수 있는 SQL로 변환하는 어댑터가 된다.

### 10.12. 포트와 어댑터 아키텍처

- 이는 헥사고날 아키텍처의 특징을 잘 담아낸 또 다른 이름이다.
- 하지만 여전히 **헥사고날 아키텍처**라는 이름이 더 널리 사용된다.

### 10.13. 헥사고날 아키텍처의 비대칭성

- **Driving Side**
  - 애플리케이션의 기능을 **'주도적으로 호출하는'** 액터와 어댑터이다. (Primary Actor, Primary Adapter)
- **Driven Side**
  - 애플리케이션에 의해 **'기능 제공을 요청받는'** 액터와 어댑터이다. (Secondary Actor, Secondary Adapter)

### 10.14. 오해: 애플리케이션 내부에 도메인 계층을 만들어야 한다.

- **사실**: 헥사고날 아키텍처는 **내부 구현 방식에 대해 어떠한 요구사항도 없다**. 트랜잭션 스크립트, 도메인 모델 패턴 등 어떤 방식이든 가능하다. (도메인 계층을 필수로 하는 것은 클린 아키텍처이다.)

### 10.15. 오해: 정해진 패키지 구조를 따라야 한다.

- **사실**: 헥사고날 아키텍처가 요구하는 특정 패키지 구조는 없다. 다만, **애플리케이션과 어댑터, 포트 패키지를 분리하는 것은 권장**된다.

### 10.16. 오해: 포트 이름은 `UseCase`여야 한다.

- **사실**: 정해진 이름 규칙은 없다. **포트의 의도를 잘 나타내는 이름**이면 충분하다.
- `For + ~ing` 스타일의 권장 네이밍이 있지만 이를 따를 필요는 없다.

### 10.17. 오해: 도메인 모델과 영속성 모델은 분리해야 한다.

- **사실**: 애플리케이션 코드와 포트 인터페이스가 **외부 기술(JPA 등)에 직접 의존하지만 않으면 된다**. 즉, 도메인 모델이 JPA 엔티티여도 규칙을 위반하는 것은 아니다.

### 10.18. 사실: 헥사고날 아키텍처가 요구하는 것

- 애플리케이션은 **포트(Port)를 통해서만 외부와 상호작용**한다.
- 애플리케이션은 **액터(Actor)에 대한 코드 의존성을 가지면 안 된다**.
- 포트의 인터페이스는 **특정 기술에 의존하지 않는다**.

### 10.19. 헥사고날 아키텍처의 계층 구조

- 헥사고날 아키텍처는 외부에서 내부로 향하는 일종의 계층 구조를 가진다.
- **코드의 의존성 방향은 항상 외부에서 내부로만** 향한다 (어댑터 → 애플리케이션 → 도메인).
- 하지만 **사용의 흐름은 양방향으로 비대칭적**이다. (Driving Actor는 외부에서 내부로, Driven Actor는 내부에서 외부로 호출)

## 11. 엔티티 식별자

- 고유성: 두 개의 엔티티가 같은 값을 가지면 안 된다.
- 불변성: 한 번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안 된다.
  - 참조 정합성을 훼손하고, 연관관계를 깨뜨린다.
- 비즈니스적인 의미로부터 디커플링되는 것이 낫다.
  - 자연 키 대신 인조 키(대리 키) 사용

## 12. JPA 모델과 도메인 모델은 다른 것인가?

### 12.1 도메인 모델은 DB와 매핑되는 데이터 모델과 다르면 이를 분리해야 한다.

- 도메인 모델과 DB와 매핑되는 데이터 모델이 다를 경우, 아래와 같이 두 모델을 분리해야 한다.
  - 어댑터 계층에 JPA 엔티티(`MemberEntity`)와 같은 영속성 모델을 따로 만든다.
  - `Repository`를 구현한 어댑터에서 **도메인 객체와 JPA 엔티티 객체를 서로 매핑**해준다.

#### 이런 접근 방법을 선호하는 이유

- **데이터 모델과 도메인 모델이 너무 다른 경우** (특히 레거시 DB에 도메인 설계를 적용하는 경우)
- 복잡한 도메인 모델이 데이터 모델과 간단히 매핑되지 않는 경우
- 데이터 저장 기술이 바뀔 가능성이 있는 경우
- 도메인 코드에 JPA 애너테이션과 같은 **기술 의존적인 코드가 포함되는 것을 방지**하고 싶을 경우

### 12.2 도메인 모델과 JPA 모델을 반드시 분리해야 한다는 주장에 대한 반박

- 대부분의 경우, **데이터 모델과 도메인 모델은 크게 다르지 않다**.
- JPA는 **복잡한 도메인 모델의 매핑도 대부분 지원**한다.
- 모델을 분리하면, 두 모델 간의 **변환 로직과 유사한 클래스들이 늘어나 불필요한 복잡성**을 증가시킨다.
- JPA는 근본적으로 **도메인 객체의 매핑을 위해 설계된 기술**이다.
- 도메인 계층과 데이터 계층의 **결합은 어느 정도 불가피**하며, 완전히 독립적인 경우는 매우 드물다.
- **스프링 데이터 JPA**는 놀라운 수준의 도메인 중심 개발을 지원한다.

## 13. JPA 기술의 정체성

- **ORM**은 패러다임이 다른 관계형 DB와 객체지향 모델의 불일치를 해결하는 기술이다.
- JPA의 기술적 목표는, 개발자가 **자바 도메인 모델을 활용하여 관계형 데이터베이스를 관리**할 수 있도록 하는 것이다.
- 이러한 관점에서, JPA의 엔티티는 **경량 영속 도메인 오브젝트**라고 할 수 있다.

## 14. 도메인 모델 패턴

- **단순 도메인 모델**은 테이블과 클래스가 1:1로 매핑되는 방식이다.
- 반면, **복잡한 도메인 모델**은 DB 매핑이 어려울 수 있는데, 이 문제를 해결해주는 것이 바로 **JPA(ORM) 기술**이다.
- JPA(ORM)가 해결하려는 대표적인 패러다임 불일치 문제는 다음과 같다.
  1.  세분성(Granularity) 불일치
  2.  상속(Subtype) 불일치
  3.  정체성(Identity) 불일치
  4.  연관(Association) 불일치
  5.  데이터 탐색(Navigation) 불일치

## 15. 스프링 데이터 프로젝트

- **스프링 데이터(Spring Data) 프로젝트**는 다양한 데이터 저장소에 대한 데이터 접근을 **단순하고 일관된 프로그래밍 모델로 제공**한다.
- 이를 통해 **저장소의 종류와 관계없이 동일한 방식으로 데이터에 접근**하게 하고, **보일러플레이트 코드를 크게 감소**시킨다.
- 또한, 데이터 저장소의 고유한 특성은 유지하면서도 확장성과 유연성을 제공한다.
- 핵심적인 추상화는 **`Repository<T, ID>` 인터페이스**이며, 여기서 `T`는 도메인 타입, 즉 **애그리거트 루트**를 의미한다.

## 16. 애그리거트 (Aggregate)

- **애그리거트(Aggregate)** 는 도메인 주도 개발(DDD)에 소개된 도메인 모델 구성 요소/패턴의 하나이다.
- 이는 **데이터 변경의 목적을 위해 하나의 단위로 취급되는 연관된 객체들의 클러스터**이다.
- 애그리거트는 **루트(Root)와 경계(Boundary)** 를 가지며, 경계 내부에는 하나 이상의 엔티티와 값 객체가 존재할 수 있다.
- **애그리거트 루트**는 그 내부에 포함된 단일 엔티티이다.

### 16.1. 애그리거트의 특징

- **데이터 변경 시 하나의 단위로 취급**: 데이터 변경의 일관성을 유지한다.
- **루트를 통한 접근 제어**: 외부 객체는 **애그리거트 루트(Root)에만 참조**를 가질 수 있다.
- **데이터 일관성 유지**: 경계 내의 어떤 변경이 있을 때, **전체 애그리거트의 모든 불변식(invariant)이 충족**되어야 한다. 애그리거트를 넘어서는 불변식은 이벤트를 통해 특정 시간 내에 해결할 수 있다.
- **검색 및 접근 방식**: 리포지터리를 통해서 **애그리거트 루트만 직접 조회**할 수 있으며, 내부 엔티티는 루트로부터 연관 관계를 통해서만 접근한다.
- **생명 주기 관리 캡슐화**: `Factory`와 `Repository`를 이용해서 객체들의 생명 주기를 체계적인 단위로 조작한다.

### 16.2. 애그리거트의 목표

- **일관성 유지**: 객체 그룹에 적용되는 불변식을 유지하는 수단이 된다.
- **이해 용이성**: 객체의 시작과 끝을 명확히 하여 **모델을 더 쉽게 이해**하게 한다.
- **트랜잭션 및 동시성 관리**: 트랜잭션 범위와 데이터 **일관성을 유지하는 방법을 제공**한다.
- **모델 단순화**: 연관 관계 탐색을 제한하고 **루트를 통해서만 접근하도록 강제**한다.
- **생명 주기 캡슐화 단위**: `Factory`와 `Repository`가 **복잡한 생명 주기 전환을 캡슐화하는 단위**가 되도록 한다.

### 16.3. 애그리거트 적용 방법

- JPA의 **영속성 전파(Cascading) 기능을 적절하게 활용**한다.
- **리포지터리는 애그리거트 단위**로 만든다. (이는 스프링 데이터 JPA의 핵심 원칙이다: `Repository<T, ID>`에서 `T`는 애그리거트 루트이다.)
- 가능하다면 **하나의 트랜잭션에서는 하나의 애그리거트만 변경**한다.
- 다른 애그리거트를 참조할 때는, **해당 애그리거트의 루트에 대해서만 참조**한다. (직접적인 객체 레퍼런스 대신 루트의 ID 값만 저장하기도 한다.)

### 16.4. 애그리거트 설계와 적용의 어려움

- **적절한 애그리거트 경계를 선택**하는 것은 꽤 어려운 결정이다.
- 개발 과정에서 **애그리거트의 범위가 달라지기도 한다**. (대체로 초기 설계보다 더 작은 애그리거트가 되는 경향이 있다.)
- 애그리거트 전체를 조회하는 것은 **성능에 부담**을 줄 수 있다. (이 때문에 지연 로딩(Lazy Loading)의 도움이 필요하다.)
- 때로는 내부 엔티티로의 직접 접근이나, **여러 애그리거트를 한 번에 조회하는 기능이 필요**한 경우가 있다.
- **도메인 이벤트와 최종적 일관성(Eventual Consistency)** 의 사용이 요구되기도 한다.
- 처음부터 완벽한 애그리거트를 추구하기보다, **상황에 맞춰 발전시켜 나가는 것**이 중요하다.

### 16.5. 헥사고날 아키텍처와 애그리거트

- **애그리거트 단위로 애플리케이션(헥사곤)을 구성**하는 방법이 유용하다.
- 다른 애그리거트로의 접근은 **애플리케이션 포트(Port)를 통해 ID를 전달하는 방식**으로 강제할 수 있다.
- **도메인 이벤트와 리스너**를 이용해서 애그리거트 사이의 작업을 연결할 수도 있다.
- 궁극적으로는 **각 애그리거트를 독립적인 애플리케이션으로 분리**하는 것을 목표로 할 수 있다.

## 17. 애플리케이션 포트의 리턴 타입은? Entity VS DTO

- 애플리케이션 계층에서 도메인 로직을 처리한 뒤, 프레젠테이션(표현) 계층으로 어떤 타입을 반환해야 하는지에 대해서는 **DTO를 사용해야 한다는 주장**과 **엔티티를 사용해야 한다는 주장**이 대립한다.

### 17.1. 주장 1: 리턴 타입은 DTO여야 한다

- 전통적인 계층형 아키텍처에서는 **각 계층이 바로 하위 계층에만 의존**해야 한다. 이 원칙을 엄격히 따르려면, 도메인 계층의 엔티티는 애플리케이션 계층 밖으로 노출되어서는 안 된다.
- 도메인 로직을 가진 엔티티가 프레젠테이션 계층(컨트롤러 등)으로 유출되면, **뷰(View)를 만드는 과정에서 도메인 로직을 실행**하여 데이터의 일관성을 해칠 위험이 있다.
- 따라서, 애플리케이션 계층 밖으로 데이터를 전달할 때는 반드시 **필요한 값만 DTO(Data Transfer Object)에 담아 전달**해야 한다는 주장이다.

### 17.2. 주장 2: 가능하다면 엔티티를 리턴해야 한다

- 현대적인 애플리케이션은 **완화된 계층형 아키텍처(Relaxed Layered Architecture)**를 주로 사용한다. 계층형 아키텍처의 진짜 목적은 **관심사의 분리(Separation of Concerns)**이지, 무조건적인 계층 간 호출 제한이 아니다.
- DTO를 리턴하는 방식의 가장 큰 문제는 **프레젠테이션 로직이 애플리케이션 계층으로 침투**하는 것이다. 뷰(View)에서 필요한 데이터가 바뀔 때마다 **애플리케이션 계층의 DTO와 매핑 코드가 변경**되어야 한다. 이는 하위 계층(애플리케이션)이 상위 계층(프레젠테이션)에 의존하는 것으로, **아키텍처의 근간을 깨는 행위**이다.
- OSIV(Open Session In View) 패턴이 적용된 환경이라도, 애플리케이션 계층에서 리턴하는 시점에는 트랜잭션이 종료된다. 따라서 **이후에 프레젠테이션 계층에서 엔티티를 변경하더라도 DB에 커밋되지 않는다**.
- 도메인 로직 유출 문제는 DTO를 사용해도 발생할 수 있다. 근본적인 해결책은 **코드 리뷰와 정적 분석 도구 등을 통해, 프레젠테이션 계층에서 엔티티의 상태 변경 메서드를 호출하지 않도록** 규칙을 정하고 지키는 것이다.
- 따라서 **엔티티(애그리거트 루트)를 그대로 반환**하고, 사용자에게 어떤 정보를 보여줄지는 **프레젠테이션 계층이 결정**하도록 하는 것이 더 올바른 설계라는 주장이다. 단, 복잡한 리포트성 조회 결과는 처음부터 DTO로 조회하여 반환하는 것이 효율적이다.

### 17.3. 결론

- 애플리케이션의 리턴 타입은 **기본적으로 엔티티(애그리거트 루트)를 사용**하는 것이 좋다.
- **DTO**는 엔티티만으로는 표현하기 어려운, **여러 애그리거트의 정보를 조합**해야 하는 등 특별한 경우에만 만들어 사용하는 것이 바람직하다.
